<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="%24con2tag_L6gFlnXOx06LoY83SuYDri"><span id="%24con2tag_9Bg7YkgqBnbLWxn1EslhMa"><span id="%24con2tag_7XKnwMJE3vJHz3rIJMErqp"><span id="%24con2tag_8mNRnLFbZv87Ke1vQCC1MG"></span></span></span></span><span class="hs-pragma">{-# Language CPP, DeriveDataTypeable #-}</span><span class="hs-cpp">

#if MIN_VERSION_base(4,4,0)
</span><span class="hs-cpp">#define HAS_GENERICS
</span><span class="hs-pragma">{-# Language DeriveGeneric #-}</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-8"></span><span class="hs-comment">{-|
Module      : Language.Haskell.TH.Datatype
Description : Backwards-compatible interface to reified information about datatypes.
Copyright   : Eric Mertens 2017
License     : ISC
Maintainer  : emertens@gmail.com

This module provides a flattened view of information about data types
and newtypes that can be supported uniformly across multiple versions
of the template-haskell package.

Sample output for @'reifyDatatype' ''Maybe@

@
'DatatypeInfo'
 { 'datatypeContext'   = []
 , 'datatypeName'      = GHC.Base.Maybe
 , 'datatypeVars'      = [ 'KindedTV' a_3530822107858468866 'StarT' ]
 , 'datatypeInstTypes' = [ 'SigT' ('VarT' a_3530822107858468866) 'StarT' ]
 , 'datatypeVariant'   = 'Datatype'
 , 'datatypeCons'      =
     [ 'ConstructorInfo'
         { 'constructorName'       = GHC.Base.Nothing
         , 'constructorVars'       = []
         , 'constructorContext'    = []
         , 'constructorFields'     = []
         , 'constructorStrictness' = []
         , 'constructorVariant'    = 'NormalConstructor'
         }
     , 'ConstructorInfo'
         { 'constructorName'       = GHC.Base.Just
         , 'constructorVars'       = []
         , 'constructorContext'    = []
         , 'constructorFields'     = [ 'VarT' a_3530822107858468866 ]
         , 'constructorStrictness' = [ 'FieldStrictness'
                                         'UnspecifiedUnpackedness'
                                         'Lazy'
                                     ]
         , 'constructorVariant'    = 'NormalConstructor'
         }
     ]
 }
@

Datatypes declared with GADT syntax are normalized to constructors with existentially
quantified type variables and equality constraints.

-}</span><span>
</span><span id="line-56"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.TH.Datatype</span><span>
</span><span id="line-57"></span><span>  </span><span class="hs-special">(</span><span>
</span><span id="line-58"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Types</span></span><span>
</span><span id="line-59"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier">DatatypeInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-60"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier">ConstructorInfo</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-61"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier">DatatypeVariant</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-62"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier">ConstructorVariant</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-63"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier">FieldStrictness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-64"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier">Unpackedness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-65"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier">Strictness</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-66"></span><span>
</span><span id="line-67"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Normalization functions</span></span><span>
</span><span id="line-68"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier">reifyDatatype</span></a></span><span>
</span><span id="line-69"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier">reifyConstructor</span></a></span><span>
</span><span id="line-70"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier">reifyRecord</span></a></span><span>
</span><span id="line-71"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier">normalizeInfo</span></a></span><span>
</span><span id="line-72"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier">normalizeDec</span></a></span><span>
</span><span id="line-73"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier">normalizeCon</span></a></span><span>
</span><span id="line-74"></span><span>
</span><span id="line-75"></span><span>  </span><span class="annot"><span class="hs-comment">-- * 'DatatypeInfo' lookup functions</span></span><span>
</span><span id="line-76"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier">lookupByConstructorName</span></a></span><span>
</span><span id="line-77"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier">lookupByRecordName</span></a></span><span>
</span><span id="line-78"></span><span>
</span><span id="line-79"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Type variable manipulation</span></span><span>
</span><span id="line-80"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier">TypeSubstitution</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><span id="line-81"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier">quantifyType</span></a></span><span>
</span><span id="line-82"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier">freeVariablesWellScoped</span></a></span><span>
</span><span id="line-83"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier">freshenFreeVariables</span></a></span><span>
</span><span id="line-84"></span><span>
</span><span id="line-85"></span><span>  </span><span class="annot"><span class="hs-comment">-- * 'Pred' functions</span></span><span>
</span><span id="line-86"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier">equalPred</span></a></span><span>
</span><span id="line-87"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier">classPred</span></a></span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier">asEqualPred</span></a></span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier">asClassPred</span></a></span><span>
</span><span id="line-90"></span><span>
</span><span id="line-91"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Backward compatible data definitions</span></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier">dataDCompat</span></a></span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier">newtypeDCompat</span></a></span><span>
</span><span id="line-94"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier">tySynInstDCompat</span></a></span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier">pragLineDCompat</span></a></span><span>
</span><span id="line-96"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier">arrowKCompat</span></a></span><span>
</span><span id="line-97"></span><span>
</span><span id="line-98"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Strictness annotations</span></span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier">isStrictAnnot</span></a></span><span>
</span><span id="line-100"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier">notStrictAnnot</span></a></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier">unpackedAnnot</span></a></span><span>
</span><span id="line-102"></span><span>
</span><span id="line-103"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Type simplification</span></span><span>
</span><span id="line-104"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier">resolveTypeSynonyms</span></a></span><span>
</span><span id="line-105"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier">resolveKindSynonyms</span></a></span><span>
</span><span id="line-106"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier">resolvePredSynonyms</span></a></span><span>
</span><span id="line-107"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier">resolveInfixT</span></a></span><span>
</span><span id="line-108"></span><span>
</span><span id="line-109"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Fixities</span></span><span>
</span><span id="line-110"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier">reifyFixityCompat</span></a></span><span>
</span><span id="line-111"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier">showFixity</span></a></span><span>
</span><span id="line-112"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier">showFixityDirection</span></a></span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span>  </span><span class="annot"><span class="hs-comment">-- * Convenience functions</span></span><span>
</span><span id="line-115"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier">unifyTypes</span></a></span><span>
</span><span id="line-116"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier">tvName</span></a></span><span>
</span><span id="line-117"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier">tvKind</span></a></span><span>
</span><span id="line-118"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier">datatypeType</span></a></span><span>
</span><span id="line-119"></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-120"></span><span>
</span><span id="line-121"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Data</span></span><span class="hs-special">)</span><span>
</span><span id="line-122"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Foldable</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">foldMap</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">foldl'</span></span><span class="hs-special">)</span><span>
</span><span id="line-123"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">nub</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">find</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">union</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(\\)</span></span><span class="hs-special">)</span><span>
</span><span id="line-124"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Map</span></span><span class="hs-special">)</span><span>
</span><span id="line-125"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Map</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Map</span></span><span>
</span><span id="line-126"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span>
</span><span id="line-127"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">Set</span></span><span>
</span><span id="line-128"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Data.Set</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Set</span></span><span class="hs-special">)</span><span>
</span><span id="line-129"></span><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="annot"><span class="hs-identifier">Data.Traversable</span></span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">T</span></span><span>
</span><span id="line-130"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Control.Monad</span></span><span>
</span><span id="line-131"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>                                     </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Extension</span></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span>           </span><span class="annot"><a href="Language.Haskell.TH.Datatype.Internal.html"><span class="hs-identifier">Language.Haskell.TH.Datatype.Internal</span></a></span><span>
</span><span id="line-136"></span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH.Lib</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">arrowK</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">starK</span></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- needed for th-2.4</span><span class="hs-cpp">

#ifdef HAS_GENERICS
</span><span class="hs-keyword">import</span><span>           </span><span class="annot"><span class="hs-identifier">GHC.Generics</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Generic</span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if !MIN_VERSION_base(4,8,0)
</span><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Control.Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Applicative</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator">&lt;$&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-144"></span><span class="hs-keyword">import</span><span>           </span><span class="hs-identifier">Data.Monoid</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Monoid</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-147"></span><span class="hs-comment">-- | Normalized information about newtypes and data types.</span><span>
</span><span id="line-148"></span><span class="hs-comment">--</span><span>
</span><span id="line-149"></span><span class="hs-comment">-- 'DatatypeInfo' contains two fields, 'datatypeVars' and 'datatypeInstTypes',</span><span>
</span><span id="line-150"></span><span class="hs-comment">-- which encode information about the argument types. The simplest explanation</span><span>
</span><span id="line-151"></span><span class="hs-comment">-- is that 'datatypeVars' contains all the type /variables/ bound by the data</span><span>
</span><span id="line-152"></span><span class="hs-comment">-- type constructor, while 'datatypeInstTypes' contains the type /arguments/</span><span>
</span><span id="line-153"></span><span class="hs-comment">-- to the data type constructor. To be more precise:</span><span>
</span><span id="line-154"></span><span class="hs-comment">--</span><span>
</span><span id="line-155"></span><span class="hs-comment">-- * For ADTs declared with @data@ and @newtype@, it will likely be the case</span><span>
</span><span id="line-156"></span><span class="hs-comment">--   that 'datatypeVars' and 'datatypeInstTypes' coincide. For instance, given</span><span>
</span><span id="line-157"></span><span class="hs-comment">--   @newtype Id a = MkId a@, in the 'DatatypeInfo' for @Id@ we would</span><span>
</span><span id="line-158"></span><span class="hs-comment">--   have @'datatypeVars' = ['KindedTV' a 'StarT']@ and</span><span>
</span><span id="line-159"></span><span class="hs-comment">--   @'datatypeInstVars' = ['SigT' ('VarT' a) 'StarT']@.</span><span>
</span><span id="line-160"></span><span class="hs-comment">--</span><span>
</span><span id="line-161"></span><span class="hs-comment">--   ADTs that leverage @PolyKinds@ may have more 'datatypeVars' than</span><span>
</span><span id="line-162"></span><span class="hs-comment">--   'datatypeInstTypes'. For instance, given @data Proxy (a :: k) = MkProxy@,</span><span>
</span><span id="line-163"></span><span class="hs-comment">--   in the 'DatatypeInfo' for @Proxy@ we would have</span><span>
</span><span id="line-164"></span><span class="hs-comment">--   @'datatypeVars' = ['KindedTV' k 'StarT', 'KindedTV' a ('VarT' k)]@ (since</span><span>
</span><span id="line-165"></span><span class="hs-comment">--   there are two variables, @k@ and @a@), whereas</span><span>
</span><span id="line-166"></span><span class="hs-comment">--   @'datatypeInstTypes' = ['SigT' ('VarT' a) ('VarT' k)]@, since there is</span><span>
</span><span id="line-167"></span><span class="hs-comment">--   only one explicit type argument to @Proxy@.</span><span>
</span><span id="line-168"></span><span class="hs-comment">--</span><span>
</span><span id="line-169"></span><span class="hs-comment">-- * For @data instance@s and @newtype instance@s of data families,</span><span>
</span><span id="line-170"></span><span class="hs-comment">--   'datatypeVars' and 'datatypeInstTypes' can be quite different. Here is</span><span>
</span><span id="line-171"></span><span class="hs-comment">--   an example to illustrate the difference:</span><span>
</span><span id="line-172"></span><span class="hs-comment">--</span><span>
</span><span id="line-173"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-174"></span><span class="hs-comment">--   data family F a b</span><span>
</span><span id="line-175"></span><span class="hs-comment">--   data instance F (Maybe c) (f x) = MkF c (f x)</span><span>
</span><span id="line-176"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-177"></span><span class="hs-comment">--</span><span>
</span><span id="line-178"></span><span class="hs-comment">--   Then in the 'DatatypeInfo' for @F@'s data instance, we would have:</span><span>
</span><span id="line-179"></span><span class="hs-comment">--</span><span>
</span><span id="line-180"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-181"></span><span class="hs-comment">--   'datatypeVars'      = [ 'KindedTV' c 'StarT'</span><span>
</span><span id="line-182"></span><span class="hs-comment">--                         , 'KindedTV' f 'StarT'</span><span>
</span><span id="line-183"></span><span class="hs-comment">--                         , 'KindedTV' x 'StarT' ]</span><span>
</span><span id="line-184"></span><span class="hs-comment">--   'datatypeInstTypes' = [ 'AppT' ('ConT' ''Maybe) ('VarT' c)</span><span>
</span><span id="line-185"></span><span class="hs-comment">--                         , 'AppT' ('VarT' f) ('VarT' x) ]</span><span>
</span><span id="line-186"></span><span class="hs-comment">--   @</span><span>
</span><span id="line-187"></span><span id="local-6989586621679083694"><span id="local-6989586621679083695"></span></span><span class="hs-keyword">data</span><span> </span><span id="DatatypeInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-var">DatatypeInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="DatatypeInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-var">DatatypeInfo</span></a></span></span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="datatypeContext"><span class="annot"><span class="annottext">DatatypeInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeContext"><span class="hs-identifier hs-var hs-var">datatypeContext</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>               </span><span class="hs-comment">-- ^ Data type context (deprecated)</span><span>
</span><span id="line-189"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeName"><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var hs-var">datatypeName</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>              </span><span class="hs-comment">-- ^ Type constructor</span><span>
</span><span id="line-190"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeVars"><span class="annot"><span class="annottext">DatatypeInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var hs-var">datatypeVars</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>       </span><span class="hs-comment">-- ^ Type parameters</span><span>
</span><span id="line-191"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeInstTypes"><span class="annot"><span class="annottext">DatatypeInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var hs-var">datatypeInstTypes</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="hs-comment">-- ^ Argument types</span><span>
</span><span id="line-192"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeVariant"><span class="annot"><span class="annottext">DatatypeInfo -&gt; DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier hs-var hs-var">datatypeVariant</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span>   </span><span class="hs-comment">-- ^ Extra information</span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="datatypeCons"><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ Normalize constructor information</span><span>
</span><span id="line-194"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-195"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083681"><span id="local-6989586621679083683"><span id="local-6989586621679083685"><span class="annot"><span class="annottext">Int -&gt; DatatypeInfo -&gt; ShowS
[DatatypeInfo] -&gt; ShowS
DatatypeInfo -&gt; String
(Int -&gt; DatatypeInfo -&gt; ShowS)
-&gt; (DatatypeInfo -&gt; String)
-&gt; ([DatatypeInfo] -&gt; ShowS)
-&gt; Show DatatypeInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DatatypeInfo] -&gt; ShowS
$cshowList :: [DatatypeInfo] -&gt; ShowS
show :: DatatypeInfo -&gt; String
$cshow :: DatatypeInfo -&gt; String
showsPrec :: Int -&gt; DatatypeInfo -&gt; ShowS
$cshowsPrec :: Int -&gt; DatatypeInfo -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083676"><span id="local-6989586621679083678"><span class="annot"><span class="annottext">DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
(DatatypeInfo -&gt; DatatypeInfo -&gt; Bool)
-&gt; (DatatypeInfo -&gt; DatatypeInfo -&gt; Bool) -&gt; Eq DatatypeInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
$c/= :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
== :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
$c== :: DatatypeInfo -&gt; DatatypeInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cDatatypeInfo"><span id="%24tDatatypeInfo"><span id="local-6989586621679083646"><span id="local-6989586621679083648"><span id="local-6989586621679083650"><span id="local-6989586621679083652"><span id="local-6989586621679083654"><span id="local-6989586621679083656"><span id="local-6989586621679083658"><span id="local-6989586621679083660"><span id="local-6989586621679083662"><span id="local-6989586621679083664"><span id="local-6989586621679083666"><span id="local-6989586621679083668"><span id="local-6989586621679083670"><span id="local-6989586621679083672"><span class="annot"><span class="annottext">Typeable DatatypeInfo
DataType
Constr
Typeable DatatypeInfo =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo)
-&gt; (DatatypeInfo -&gt; Constr)
-&gt; (DatatypeInfo -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DatatypeInfo))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo)
-&gt; Data DatatypeInfo
DatatypeInfo -&gt; DataType
DatatypeInfo -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeInfo)
$cDatatypeInfo :: Constr
$tDatatypeInfo :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; DatatypeInfo -&gt; m DatatypeInfo
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeInfo -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeInfo -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeInfo -&gt; DatatypeInfo
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeInfo)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeInfo)
dataTypeOf :: DatatypeInfo -&gt; DataType
$cdataTypeOf :: DatatypeInfo -&gt; DataType
toConstr :: DatatypeInfo -&gt; Constr
$ctoConstr :: DatatypeInfo -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeInfo
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeInfo -&gt; c DatatypeInfo
$cp1Data :: Typeable DatatypeInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. DatatypeInfo -&gt; Rep DatatypeInfo x)
-&gt; (forall x. Rep DatatypeInfo x -&gt; DatatypeInfo)
-&gt; Generic DatatypeInfo
forall x. Rep DatatypeInfo x -&gt; DatatypeInfo
forall x. DatatypeInfo -&gt; Rep DatatypeInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DatatypeInfo x -&gt; DatatypeInfo
$cfrom :: forall x. DatatypeInfo -&gt; Rep DatatypeInfo x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-200"></span><span>
</span><span id="line-201"></span><span class="hs-comment">-- | Possible variants of data type declarations.</span><span>
</span><span id="line-202"></span><span id="local-6989586621679083638"><span id="local-6989586621679083639"></span></span><span class="hs-keyword">data</span><span> </span><span id="DatatypeVariant"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-var">DatatypeVariant</span></a></span></span><span>
</span><span id="line-203"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="Datatype"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-var">Datatype</span></a></span></span><span>        </span><span class="hs-comment">-- ^ Type declared with @data@</span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Newtype"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span></span><span>         </span><span class="hs-comment">-- ^ Type declared with @newtype@</span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataInstance"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-var">DataInstance</span></a></span></span><span>    </span><span class="hs-comment">-- ^ Type declared with @data instance@</span><span>
</span><span id="line-206"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NewtypeInstance"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-var">NewtypeInstance</span></a></span></span><span> </span><span class="hs-comment">-- ^ Type declared with @newtype instance@</span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083628"><span id="local-6989586621679083630"><span id="local-6989586621679083632"><span class="annot"><span class="annottext">Int -&gt; DatatypeVariant -&gt; ShowS
[DatatypeVariant] -&gt; ShowS
DatatypeVariant -&gt; String
(Int -&gt; DatatypeVariant -&gt; ShowS)
-&gt; (DatatypeVariant -&gt; String)
-&gt; ([DatatypeVariant] -&gt; ShowS)
-&gt; Show DatatypeVariant
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [DatatypeVariant] -&gt; ShowS
$cshowList :: [DatatypeVariant] -&gt; ShowS
show :: DatatypeVariant -&gt; String
$cshow :: DatatypeVariant -&gt; String
showsPrec :: Int -&gt; DatatypeVariant -&gt; ShowS
$cshowsPrec :: Int -&gt; DatatypeVariant -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083620"><span id="local-6989586621679083622"><span id="local-6989586621679083624"><span id="local-6989586621679083626"><span class="annot"><span class="annottext">ReadPrec [DatatypeVariant]
ReadPrec DatatypeVariant
Int -&gt; ReadS DatatypeVariant
ReadS [DatatypeVariant]
(Int -&gt; ReadS DatatypeVariant)
-&gt; ReadS [DatatypeVariant]
-&gt; ReadPrec DatatypeVariant
-&gt; ReadPrec [DatatypeVariant]
-&gt; Read DatatypeVariant
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
readListPrec :: ReadPrec [DatatypeVariant]
$creadListPrec :: ReadPrec [DatatypeVariant]
readPrec :: ReadPrec DatatypeVariant
$creadPrec :: ReadPrec DatatypeVariant
readList :: ReadS [DatatypeVariant]
$creadList :: ReadS [DatatypeVariant]
readsPrec :: Int -&gt; ReadS DatatypeVariant
$creadsPrec :: Int -&gt; ReadS DatatypeVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083615"><span id="local-6989586621679083617"><span class="annot"><span class="annottext">DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
(DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; Eq DatatypeVariant
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c/= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
== :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c== :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083600"><span id="local-6989586621679083602"><span id="local-6989586621679083604"><span id="local-6989586621679083606"><span id="local-6989586621679083608"><span id="local-6989586621679083610"><span id="local-6989586621679083612"><span class="annot"><span class="annottext">Eq DatatypeVariant
Eq DatatypeVariant =&gt;
(DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; Bool)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant)
-&gt; (DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant)
-&gt; Ord DatatypeVariant
DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering
DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
$cmin :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
max :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
$cmax :: DatatypeVariant -&gt; DatatypeVariant -&gt; DatatypeVariant
&gt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&gt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&gt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&gt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&lt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&lt;= :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
&lt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
$c&lt; :: DatatypeVariant -&gt; DatatypeVariant -&gt; Bool
compare :: DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering
$ccompare :: DatatypeVariant -&gt; DatatypeVariant -&gt; Ordering
$cp1Ord :: Eq DatatypeVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cNewtypeInstance"><span id="%24cDataInstance"><span id="%24cNewtype"><span id="%24cDatatype"><span id="%24tDatatypeVariant"><span id="local-6989586621679083570"><span id="local-6989586621679083572"><span id="local-6989586621679083574"><span id="local-6989586621679083576"><span id="local-6989586621679083578"><span id="local-6989586621679083580"><span id="local-6989586621679083582"><span id="local-6989586621679083584"><span id="local-6989586621679083586"><span id="local-6989586621679083588"><span id="local-6989586621679083590"><span id="local-6989586621679083592"><span id="local-6989586621679083594"><span id="local-6989586621679083596"><span class="annot"><span class="annottext">Typeable DatatypeVariant
DataType
Constr
Typeable DatatypeVariant =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant)
-&gt; (DatatypeVariant -&gt; Constr)
-&gt; (DatatypeVariant -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c DatatypeVariant))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; DatatypeVariant -&gt; DatatypeVariant)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DatatypeVariant -&gt; m DatatypeVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DatatypeVariant -&gt; m DatatypeVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; DatatypeVariant -&gt; m DatatypeVariant)
-&gt; Data DatatypeVariant
DatatypeVariant -&gt; DataType
DatatypeVariant -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeVariant -&gt; DatatypeVariant
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeVariant)
$cNewtypeInstance :: Constr
$cDataInstance :: Constr
$cNewtype :: Constr
$cDatatype :: Constr
$tDatatypeVariant :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; DatatypeVariant -&gt; m DatatypeVariant
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; DatatypeVariant -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; DatatypeVariant -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeVariant -&gt; DatatypeVariant
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; DatatypeVariant -&gt; DatatypeVariant
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeVariant)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c DatatypeVariant)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c DatatypeVariant)
dataTypeOf :: DatatypeVariant -&gt; DataType
$cdataTypeOf :: DatatypeVariant -&gt; DataType
toConstr :: DatatypeVariant -&gt; Constr
$ctoConstr :: DatatypeVariant -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c DatatypeVariant
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; DatatypeVariant -&gt; c DatatypeVariant
$cp1Data :: Typeable DatatypeVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. DatatypeVariant -&gt; Rep DatatypeVariant x)
-&gt; (forall x. Rep DatatypeVariant x -&gt; DatatypeVariant)
-&gt; Generic DatatypeVariant
forall x. Rep DatatypeVariant x -&gt; DatatypeVariant
forall x. DatatypeVariant -&gt; Rep DatatypeVariant x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep DatatypeVariant x -&gt; DatatypeVariant
$cfrom :: forall x. DatatypeVariant -&gt; Rep DatatypeVariant x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-212"></span><span>
</span><span id="line-213"></span><span class="hs-comment">-- | Normalized information about constructors associated with newtypes and</span><span>
</span><span id="line-214"></span><span class="hs-comment">-- data types.</span><span>
</span><span id="line-215"></span><span id="local-6989586621679083561"><span id="local-6989586621679083562"></span></span><span class="hs-keyword">data</span><span> </span><span id="ConstructorInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ConstructorInfo"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span></span><span>
</span><span id="line-216"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="constructorName"><span class="annot"><span class="annottext">ConstructorInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier hs-var hs-var">constructorName</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>               </span><span class="hs-comment">-- ^ Constructor name</span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorVars"><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span></span><span>       </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>        </span><span class="hs-comment">-- ^ Constructor type parameters</span><span>
</span><span id="line-218"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorContext"><span class="annot"><span class="annottext">ConstructorInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var hs-var">constructorContext</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>                </span><span class="hs-comment">-- ^ Constructor constraints</span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorFields"><span class="annot"><span class="annottext">ConstructorInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var hs-var">constructorFields</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>             </span><span class="hs-comment">-- ^ Constructor fields</span><span>
</span><span id="line-220"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorStrictness"><span class="annot"><span class="annottext">ConstructorInfo -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#constructorStrictness"><span class="hs-identifier hs-var hs-var">constructorStrictness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span class="hs-special">]</span><span>  </span><span class="hs-comment">-- ^ Constructor fields' strictness</span><span>
</span><span id="line-221"></span><span>                                                </span><span class="hs-comment">--   (Invariant: has the same length</span><span>
</span><span id="line-222"></span><span>                                                </span><span class="hs-comment">--   as constructorFields)</span><span>
</span><span id="line-223"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="constructorVariant"><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#constructorVariant"><span class="hs-identifier hs-var hs-var">constructorVariant</span></a></span></span><span>    </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a></span><span> </span><span class="hs-comment">-- ^ Extra information</span><span>
</span><span id="line-224"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083548"><span id="local-6989586621679083550"><span id="local-6989586621679083552"><span class="annot"><span class="annottext">Int -&gt; ConstructorInfo -&gt; ShowS
[ConstructorInfo] -&gt; ShowS
ConstructorInfo -&gt; String
(Int -&gt; ConstructorInfo -&gt; ShowS)
-&gt; (ConstructorInfo -&gt; String)
-&gt; ([ConstructorInfo] -&gt; ShowS)
-&gt; Show ConstructorInfo
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ConstructorInfo] -&gt; ShowS
$cshowList :: [ConstructorInfo] -&gt; ShowS
show :: ConstructorInfo -&gt; String
$cshow :: ConstructorInfo -&gt; String
showsPrec :: Int -&gt; ConstructorInfo -&gt; ShowS
$cshowsPrec :: Int -&gt; ConstructorInfo -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083544"><span id="local-6989586621679083546"><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
(ConstructorInfo -&gt; ConstructorInfo -&gt; Bool)
-&gt; (ConstructorInfo -&gt; ConstructorInfo -&gt; Bool)
-&gt; Eq ConstructorInfo
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
$c/= :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
== :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
$c== :: ConstructorInfo -&gt; ConstructorInfo -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cConstructorInfo"><span id="%24tConstructorInfo"><span id="local-6989586621679083515"><span id="local-6989586621679083517"><span id="local-6989586621679083519"><span id="local-6989586621679083521"><span id="local-6989586621679083523"><span id="local-6989586621679083525"><span id="local-6989586621679083527"><span id="local-6989586621679083529"><span id="local-6989586621679083531"><span id="local-6989586621679083533"><span id="local-6989586621679083535"><span id="local-6989586621679083537"><span id="local-6989586621679083539"><span id="local-6989586621679083541"><span class="annot"><span class="annottext">Typeable ConstructorInfo
DataType
Constr
Typeable ConstructorInfo =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo)
-&gt; (ConstructorInfo -&gt; Constr)
-&gt; (ConstructorInfo -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c ConstructorInfo))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; ConstructorInfo -&gt; ConstructorInfo)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorInfo -&gt; m ConstructorInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorInfo -&gt; m ConstructorInfo)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorInfo -&gt; m ConstructorInfo)
-&gt; Data ConstructorInfo
ConstructorInfo -&gt; DataType
ConstructorInfo -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; ConstructorInfo -&gt; ConstructorInfo
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorInfo)
$cConstructorInfo :: Constr
$tConstructorInfo :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorInfo -&gt; m ConstructorInfo
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorInfo -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorInfo -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ConstructorInfo -&gt; ConstructorInfo
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; ConstructorInfo -&gt; ConstructorInfo
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorInfo)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorInfo)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorInfo)
dataTypeOf :: ConstructorInfo -&gt; DataType
$cdataTypeOf :: ConstructorInfo -&gt; DataType
toConstr :: ConstructorInfo -&gt; Constr
$ctoConstr :: ConstructorInfo -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorInfo
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; ConstructorInfo -&gt; c ConstructorInfo
$cp1Data :: Typeable ConstructorInfo
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. ConstructorInfo -&gt; Rep ConstructorInfo x)
-&gt; (forall x. Rep ConstructorInfo x -&gt; ConstructorInfo)
-&gt; Generic ConstructorInfo
forall x. Rep ConstructorInfo x -&gt; ConstructorInfo
forall x. ConstructorInfo -&gt; Rep ConstructorInfo x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep ConstructorInfo x -&gt; ConstructorInfo
$cfrom :: forall x. ConstructorInfo -&gt; Rep ConstructorInfo x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-230"></span><span>
</span><span id="line-231"></span><span class="hs-comment">-- | Possible variants of data constructors.</span><span>
</span><span id="line-232"></span><span id="local-6989586621679083509"><span id="local-6989586621679083510"></span></span><span class="hs-keyword">data</span><span> </span><span id="ConstructorVariant"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-var">ConstructorVariant</span></a></span></span><span>
</span><span id="line-233"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="NormalConstructor"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span></span><span>        </span><span class="hs-comment">-- ^ Constructor without field names</span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InfixConstructor"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span></span><span>         </span><span class="hs-comment">-- ^ Constructor without field names that is</span><span>
</span><span id="line-235"></span><span>                             </span><span class="hs-comment">--   declared infix</span><span>
</span><span id="line-236"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordConstructor"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- ^ Constructor with field names</span><span>
</span><span id="line-237"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083500"><span id="local-6989586621679083502"><span id="local-6989586621679083504"><span class="annot"><span class="annottext">Int -&gt; ConstructorVariant -&gt; ShowS
[ConstructorVariant] -&gt; ShowS
ConstructorVariant -&gt; String
(Int -&gt; ConstructorVariant -&gt; ShowS)
-&gt; (ConstructorVariant -&gt; String)
-&gt; ([ConstructorVariant] -&gt; ShowS)
-&gt; Show ConstructorVariant
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [ConstructorVariant] -&gt; ShowS
$cshowList :: [ConstructorVariant] -&gt; ShowS
show :: ConstructorVariant -&gt; String
$cshow :: ConstructorVariant -&gt; String
showsPrec :: Int -&gt; ConstructorVariant -&gt; ShowS
$cshowsPrec :: Int -&gt; ConstructorVariant -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083496"><span id="local-6989586621679083498"><span class="annot"><span class="annottext">ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
(ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; Eq ConstructorVariant
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c/= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
== :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c== :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083481"><span id="local-6989586621679083483"><span id="local-6989586621679083485"><span id="local-6989586621679083487"><span id="local-6989586621679083489"><span id="local-6989586621679083491"><span id="local-6989586621679083493"><span class="annot"><span class="annottext">Eq ConstructorVariant
Eq ConstructorVariant =&gt;
(ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; Bool)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant)
-&gt; (ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant)
-&gt; Ord ConstructorVariant
ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering
ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
$cmin :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
max :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
$cmax :: ConstructorVariant -&gt; ConstructorVariant -&gt; ConstructorVariant
&gt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&gt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&gt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&gt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&lt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&lt;= :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
&lt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
$c&lt; :: ConstructorVariant -&gt; ConstructorVariant -&gt; Bool
compare :: ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering
$ccompare :: ConstructorVariant -&gt; ConstructorVariant -&gt; Ordering
$cp1Ord :: Eq ConstructorVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cRecordConstructor"><span id="%24cInfixConstructor"><span id="%24cNormalConstructor"><span id="%24tConstructorVariant"><span id="local-6989586621679083452"><span id="local-6989586621679083454"><span id="local-6989586621679083456"><span id="local-6989586621679083458"><span id="local-6989586621679083460"><span id="local-6989586621679083462"><span id="local-6989586621679083464"><span id="local-6989586621679083466"><span id="local-6989586621679083468"><span id="local-6989586621679083470"><span id="local-6989586621679083472"><span id="local-6989586621679083474"><span id="local-6989586621679083476"><span id="local-6989586621679083478"><span class="annot"><span class="annottext">Typeable ConstructorVariant
DataType
Constr
Typeable ConstructorVariant =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g)
 -&gt; ConstructorVariant
 -&gt; c ConstructorVariant)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant)
-&gt; (ConstructorVariant -&gt; Constr)
-&gt; (ConstructorVariant -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c ConstructorVariant))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; ConstructorVariant -&gt; ConstructorVariant)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorVariant -&gt; m ConstructorVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorVariant -&gt; m ConstructorVariant)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; ConstructorVariant -&gt; m ConstructorVariant)
-&gt; Data ConstructorVariant
ConstructorVariant -&gt; DataType
ConstructorVariant -&gt; Constr
(forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorVariant -&gt; ConstructorVariant
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorVariant)
$cRecordConstructor :: Constr
$cInfixConstructor :: Constr
$cNormalConstructor :: Constr
$tConstructorVariant :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; ConstructorVariant -&gt; m ConstructorVariant
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; ConstructorVariant -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; ConstructorVariant -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorVariant -&gt; ConstructorVariant
$cgmapT :: (forall b. Data b =&gt; b -&gt; b)
-&gt; ConstructorVariant -&gt; ConstructorVariant
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorVariant)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c ConstructorVariant)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c ConstructorVariant)
dataTypeOf :: ConstructorVariant -&gt; DataType
$cdataTypeOf :: ConstructorVariant -&gt; DataType
toConstr :: ConstructorVariant -&gt; Constr
$ctoConstr :: ConstructorVariant -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c ConstructorVariant
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g)
-&gt; ConstructorVariant
-&gt; c ConstructorVariant
$cp1Data :: Typeable ConstructorVariant
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. ConstructorVariant -&gt; Rep ConstructorVariant x)
-&gt; (forall x. Rep ConstructorVariant x -&gt; ConstructorVariant)
-&gt; Generic ConstructorVariant
forall x. Rep ConstructorVariant x -&gt; ConstructorVariant
forall x. ConstructorVariant -&gt; Rep ConstructorVariant x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep ConstructorVariant x -&gt; ConstructorVariant
$cfrom :: forall x. ConstructorVariant -&gt; Rep ConstructorVariant x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-242"></span><span>
</span><span id="line-243"></span><span class="hs-comment">-- | Normalized information about a constructor field's @UNPACK@ and</span><span>
</span><span id="line-244"></span><span class="hs-comment">-- strictness annotations.</span><span>
</span><span id="line-245"></span><span class="hs-comment">--</span><span>
</span><span id="line-246"></span><span class="hs-comment">-- Note that the interface for reifying strictness in Template Haskell changed</span><span>
</span><span id="line-247"></span><span class="hs-comment">-- considerably in GHC 8.0. The presentation in this library mirrors that which</span><span>
</span><span id="line-248"></span><span class="hs-comment">-- can be found in GHC 8.0 or later, whereas previously, unpackedness and</span><span>
</span><span id="line-249"></span><span class="hs-comment">-- strictness were represented with a single data type:</span><span>
</span><span id="line-250"></span><span class="hs-comment">--</span><span>
</span><span id="line-251"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-252"></span><span class="hs-comment">-- data Strict</span><span>
</span><span id="line-253"></span><span class="hs-comment">--   = IsStrict</span><span>
</span><span id="line-254"></span><span class="hs-comment">--   | NotStrict</span><span>
</span><span id="line-255"></span><span class="hs-comment">--   | Unpacked -- On GHC 7.4 or later</span><span>
</span><span id="line-256"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-257"></span><span class="hs-comment">--</span><span>
</span><span id="line-258"></span><span class="hs-comment">-- For backwards compatibility, we retrofit these constructors onto the</span><span>
</span><span id="line-259"></span><span class="hs-comment">-- following three values, respectively:</span><span>
</span><span id="line-260"></span><span class="hs-comment">--</span><span>
</span><span id="line-261"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-262"></span><span class="hs-comment">-- 'isStrictAnnot'  = 'FieldStrictness' 'UnspecifiedUnpackedness' 'Strict'</span><span>
</span><span id="line-263"></span><span class="hs-comment">-- 'notStrictAnnot' = 'FieldStrictness' 'UnspecifiedUnpackedness' 'UnspecifiedStrictness'</span><span>
</span><span id="line-264"></span><span class="hs-comment">-- 'unpackedAnnot'  = 'FieldStrictness' 'Unpack' 'Strict'</span><span>
</span><span id="line-265"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-266"></span><span id="local-6989586621679083444"><span id="local-6989586621679083445"></span></span><span class="hs-keyword">data</span><span> </span><span id="FieldStrictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="FieldStrictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span></span><span>
</span><span id="line-267"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="fieldUnpackedness"><span class="annot"><span class="annottext">FieldStrictness -&gt; Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#fieldUnpackedness"><span class="hs-identifier hs-var hs-var">fieldUnpackedness</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a></span><span>
</span><span id="line-268"></span><span>  </span><span class="hs-special">,</span><span> </span><span id="fieldStrictness"><span class="annot"><span class="annottext">FieldStrictness -&gt; Strictness
</span><a href="Language.Haskell.TH.Datatype.html#fieldStrictness"><span class="hs-identifier hs-var hs-var">fieldStrictness</span></a></span></span><span>   </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a></span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-270"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083435"><span id="local-6989586621679083437"><span id="local-6989586621679083439"><span class="annot"><span class="annottext">Int -&gt; FieldStrictness -&gt; ShowS
[FieldStrictness] -&gt; ShowS
FieldStrictness -&gt; String
(Int -&gt; FieldStrictness -&gt; ShowS)
-&gt; (FieldStrictness -&gt; String)
-&gt; ([FieldStrictness] -&gt; ShowS)
-&gt; Show FieldStrictness
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [FieldStrictness] -&gt; ShowS
$cshowList :: [FieldStrictness] -&gt; ShowS
show :: FieldStrictness -&gt; String
$cshow :: FieldStrictness -&gt; String
showsPrec :: Int -&gt; FieldStrictness -&gt; ShowS
$cshowsPrec :: Int -&gt; FieldStrictness -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083431"><span id="local-6989586621679083433"><span class="annot"><span class="annottext">FieldStrictness -&gt; FieldStrictness -&gt; Bool
(FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; Eq FieldStrictness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c/= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
== :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c== :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083416"><span id="local-6989586621679083418"><span id="local-6989586621679083420"><span id="local-6989586621679083422"><span id="local-6989586621679083424"><span id="local-6989586621679083426"><span id="local-6989586621679083428"><span class="annot"><span class="annottext">Eq FieldStrictness
Eq FieldStrictness =&gt;
(FieldStrictness -&gt; FieldStrictness -&gt; Ordering)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; Bool)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness)
-&gt; (FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness)
-&gt; Ord FieldStrictness
FieldStrictness -&gt; FieldStrictness -&gt; Bool
FieldStrictness -&gt; FieldStrictness -&gt; Ordering
FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
$cmin :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
max :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
$cmax :: FieldStrictness -&gt; FieldStrictness -&gt; FieldStrictness
&gt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&gt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&gt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&gt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&lt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&lt;= :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
&lt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
$c&lt; :: FieldStrictness -&gt; FieldStrictness -&gt; Bool
compare :: FieldStrictness -&gt; FieldStrictness -&gt; Ordering
$ccompare :: FieldStrictness -&gt; FieldStrictness -&gt; Ordering
$cp1Ord :: Eq FieldStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cFieldStrictness"><span id="%24tFieldStrictness"><span id="local-6989586621679083387"><span id="local-6989586621679083389"><span id="local-6989586621679083391"><span id="local-6989586621679083393"><span id="local-6989586621679083395"><span id="local-6989586621679083397"><span id="local-6989586621679083399"><span id="local-6989586621679083401"><span id="local-6989586621679083403"><span id="local-6989586621679083405"><span id="local-6989586621679083407"><span id="local-6989586621679083409"><span id="local-6989586621679083411"><span id="local-6989586621679083413"><span class="annot"><span class="annottext">Typeable FieldStrictness
DataType
Constr
Typeable FieldStrictness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness)
-&gt; (FieldStrictness -&gt; Constr)
-&gt; (FieldStrictness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c FieldStrictness))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; FieldStrictness -&gt; FieldStrictness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FieldStrictness -&gt; m FieldStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FieldStrictness -&gt; m FieldStrictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; FieldStrictness -&gt; m FieldStrictness)
-&gt; Data FieldStrictness
FieldStrictness -&gt; DataType
FieldStrictness -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; FieldStrictness -&gt; FieldStrictness
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FieldStrictness)
$cFieldStrictness :: Constr
$tFieldStrictness :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; FieldStrictness -&gt; m FieldStrictness
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; FieldStrictness -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; FieldStrictness -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FieldStrictness -&gt; FieldStrictness
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; FieldStrictness -&gt; FieldStrictness
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FieldStrictness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c FieldStrictness)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c FieldStrictness)
dataTypeOf :: FieldStrictness -&gt; DataType
$cdataTypeOf :: FieldStrictness -&gt; DataType
toConstr :: FieldStrictness -&gt; Constr
$ctoConstr :: FieldStrictness -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c FieldStrictness
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; FieldStrictness -&gt; c FieldStrictness
$cp1Data :: Typeable FieldStrictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. FieldStrictness -&gt; Rep FieldStrictness x)
-&gt; (forall x. Rep FieldStrictness x -&gt; FieldStrictness)
-&gt; Generic FieldStrictness
forall x. Rep FieldStrictness x -&gt; FieldStrictness
forall x. FieldStrictness -&gt; Rep FieldStrictness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep FieldStrictness x -&gt; FieldStrictness
$cfrom :: forall x. FieldStrictness -&gt; Rep FieldStrictness x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-275"></span><span>
</span><span id="line-276"></span><span class="hs-comment">-- | Information about a constructor field's unpackedness annotation.</span><span>
</span><span id="line-277"></span><span id="local-6989586621679083381"><span id="local-6989586621679083382"></span></span><span class="hs-keyword">data</span><span> </span><span id="Unpackedness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-var">Unpackedness</span></a></span></span><span>
</span><span id="line-278"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UnspecifiedUnpackedness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span></span><span> </span><span class="hs-comment">-- ^ No annotation whatsoever</span><span>
</span><span id="line-279"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NoUnpack"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NoUnpack"><span class="hs-identifier hs-var">NoUnpack</span></a></span></span><span>                </span><span class="hs-comment">-- ^ Annotated with @{\-\# NOUNPACK \#-\}@</span><span>
</span><span id="line-280"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Unpack"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span></span><span>                  </span><span class="hs-comment">-- ^ Annotated with @{\-\# UNPACK \#-\}@</span><span>
</span><span id="line-281"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083372"><span id="local-6989586621679083374"><span id="local-6989586621679083376"><span class="annot"><span class="annottext">Int -&gt; Unpackedness -&gt; ShowS
[Unpackedness] -&gt; ShowS
Unpackedness -&gt; String
(Int -&gt; Unpackedness -&gt; ShowS)
-&gt; (Unpackedness -&gt; String)
-&gt; ([Unpackedness] -&gt; ShowS)
-&gt; Show Unpackedness
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Unpackedness] -&gt; ShowS
$cshowList :: [Unpackedness] -&gt; ShowS
show :: Unpackedness -&gt; String
$cshow :: Unpackedness -&gt; String
showsPrec :: Int -&gt; Unpackedness -&gt; ShowS
$cshowsPrec :: Int -&gt; Unpackedness -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083368"><span id="local-6989586621679083370"><span class="annot"><span class="annottext">Unpackedness -&gt; Unpackedness -&gt; Bool
(Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool) -&gt; Eq Unpackedness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c/= :: Unpackedness -&gt; Unpackedness -&gt; Bool
== :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c== :: Unpackedness -&gt; Unpackedness -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083353"><span id="local-6989586621679083355"><span id="local-6989586621679083357"><span id="local-6989586621679083359"><span id="local-6989586621679083361"><span id="local-6989586621679083363"><span id="local-6989586621679083365"><span class="annot"><span class="annottext">Eq Unpackedness
Eq Unpackedness =&gt;
(Unpackedness -&gt; Unpackedness -&gt; Ordering)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Bool)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Unpackedness)
-&gt; (Unpackedness -&gt; Unpackedness -&gt; Unpackedness)
-&gt; Ord Unpackedness
Unpackedness -&gt; Unpackedness -&gt; Bool
Unpackedness -&gt; Unpackedness -&gt; Ordering
Unpackedness -&gt; Unpackedness -&gt; Unpackedness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
$cmin :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
max :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
$cmax :: Unpackedness -&gt; Unpackedness -&gt; Unpackedness
&gt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&gt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
&gt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&gt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
&lt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&lt;= :: Unpackedness -&gt; Unpackedness -&gt; Bool
&lt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
$c&lt; :: Unpackedness -&gt; Unpackedness -&gt; Bool
compare :: Unpackedness -&gt; Unpackedness -&gt; Ordering
$ccompare :: Unpackedness -&gt; Unpackedness -&gt; Ordering
$cp1Ord :: Eq Unpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cUnpack"><span id="%24cNoUnpack"><span id="%24cUnspecifiedUnpackedness"><span id="%24tUnpackedness"><span id="local-6989586621679083324"><span id="local-6989586621679083326"><span id="local-6989586621679083328"><span id="local-6989586621679083330"><span id="local-6989586621679083332"><span id="local-6989586621679083334"><span id="local-6989586621679083336"><span id="local-6989586621679083338"><span id="local-6989586621679083340"><span id="local-6989586621679083342"><span id="local-6989586621679083344"><span id="local-6989586621679083346"><span id="local-6989586621679083348"><span id="local-6989586621679083350"><span class="annot"><span class="annottext">Typeable Unpackedness
DataType
Constr
Typeable Unpackedness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness)
-&gt; (Unpackedness -&gt; Constr)
-&gt; (Unpackedness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c Unpackedness))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness)
-&gt; Data Unpackedness
Unpackedness -&gt; DataType
Unpackedness -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Unpackedness)
$cUnpack :: Constr
$cNoUnpack :: Constr
$cUnspecifiedUnpackedness :: Constr
$tUnpackedness :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Unpackedness -&gt; m Unpackedness
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Unpackedness -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Unpackedness -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Unpackedness -&gt; Unpackedness
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Unpackedness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c Unpackedness)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Unpackedness)
dataTypeOf :: Unpackedness -&gt; DataType
$cdataTypeOf :: Unpackedness -&gt; DataType
toConstr :: Unpackedness -&gt; Constr
$ctoConstr :: Unpackedness -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Unpackedness
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Unpackedness -&gt; c Unpackedness
$cp1Data :: Typeable Unpackedness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. Unpackedness -&gt; Rep Unpackedness x)
-&gt; (forall x. Rep Unpackedness x -&gt; Unpackedness)
-&gt; Generic Unpackedness
forall x. Rep Unpackedness x -&gt; Unpackedness
forall x. Unpackedness -&gt; Rep Unpackedness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep Unpackedness x -&gt; Unpackedness
$cfrom :: forall x. Unpackedness -&gt; Rep Unpackedness x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-286"></span><span>
</span><span id="line-287"></span><span class="hs-comment">-- | Information about a constructor field's strictness annotation.</span><span>
</span><span id="line-288"></span><span id="local-6989586621679083316"><span id="local-6989586621679083317"></span></span><span class="hs-keyword">data</span><span> </span><span id="Strictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-var">Strictness</span></a></span></span><span>
</span><span id="line-289"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="UnspecifiedStrictness"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a></span></span><span> </span><span class="hs-comment">-- ^ No annotation whatsoever</span><span>
</span><span id="line-290"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Lazy"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Lazy"><span class="hs-identifier hs-var">Lazy</span></a></span></span><span>                  </span><span class="hs-comment">-- ^ Annotated with @~@</span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Strict"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span></span><span>                </span><span class="hs-comment">-- ^ Annotated with @!@</span><span>
</span><span id="line-292"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083307"><span id="local-6989586621679083309"><span id="local-6989586621679083311"><span class="annot"><span class="annottext">Int -&gt; Strictness -&gt; ShowS
[Strictness] -&gt; ShowS
Strictness -&gt; String
(Int -&gt; Strictness -&gt; ShowS)
-&gt; (Strictness -&gt; String)
-&gt; ([Strictness] -&gt; ShowS)
-&gt; Show Strictness
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Strictness] -&gt; ShowS
$cshowList :: [Strictness] -&gt; ShowS
show :: Strictness -&gt; String
$cshow :: Strictness -&gt; String
showsPrec :: Int -&gt; Strictness -&gt; ShowS
$cshowsPrec :: Int -&gt; Strictness -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083303"><span id="local-6989586621679083305"><span class="annot"><span class="annottext">Strictness -&gt; Strictness -&gt; Bool
(Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool) -&gt; Eq Strictness
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Strictness -&gt; Strictness -&gt; Bool
$c/= :: Strictness -&gt; Strictness -&gt; Bool
== :: Strictness -&gt; Strictness -&gt; Bool
$c== :: Strictness -&gt; Strictness -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083288"><span id="local-6989586621679083290"><span id="local-6989586621679083292"><span id="local-6989586621679083294"><span id="local-6989586621679083296"><span id="local-6989586621679083298"><span id="local-6989586621679083300"><span class="annot"><span class="annottext">Eq Strictness
Eq Strictness =&gt;
(Strictness -&gt; Strictness -&gt; Ordering)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Bool)
-&gt; (Strictness -&gt; Strictness -&gt; Strictness)
-&gt; (Strictness -&gt; Strictness -&gt; Strictness)
-&gt; Ord Strictness
Strictness -&gt; Strictness -&gt; Bool
Strictness -&gt; Strictness -&gt; Ordering
Strictness -&gt; Strictness -&gt; Strictness
forall a.
Eq a =&gt;
(a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: Strictness -&gt; Strictness -&gt; Strictness
$cmin :: Strictness -&gt; Strictness -&gt; Strictness
max :: Strictness -&gt; Strictness -&gt; Strictness
$cmax :: Strictness -&gt; Strictness -&gt; Strictness
&gt;= :: Strictness -&gt; Strictness -&gt; Bool
$c&gt;= :: Strictness -&gt; Strictness -&gt; Bool
&gt; :: Strictness -&gt; Strictness -&gt; Bool
$c&gt; :: Strictness -&gt; Strictness -&gt; Bool
&lt;= :: Strictness -&gt; Strictness -&gt; Bool
$c&lt;= :: Strictness -&gt; Strictness -&gt; Bool
&lt; :: Strictness -&gt; Strictness -&gt; Bool
$c&lt; :: Strictness -&gt; Strictness -&gt; Bool
compare :: Strictness -&gt; Strictness -&gt; Ordering
$ccompare :: Strictness -&gt; Strictness -&gt; Ordering
$cp1Ord :: Eq Strictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">,</span><span> </span><span id="%24cStrict"><span id="%24cLazy"><span id="%24cUnspecifiedStrictness"><span id="%24tStrictness"><span id="local-6989586621679083259"><span id="local-6989586621679083261"><span id="local-6989586621679083263"><span id="local-6989586621679083265"><span id="local-6989586621679083267"><span id="local-6989586621679083269"><span id="local-6989586621679083271"><span id="local-6989586621679083273"><span id="local-6989586621679083275"><span id="local-6989586621679083277"><span id="local-6989586621679083279"><span id="local-6989586621679083281"><span id="local-6989586621679083283"><span id="local-6989586621679083285"><span class="annot"><span class="annottext">Typeable Strictness
DataType
Constr
Typeable Strictness =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness)
-&gt; (Strictness -&gt; Constr)
-&gt; (Strictness -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c Strictness))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness)
-&gt; Data Strictness
Strictness -&gt; DataType
Strictness -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
forall a.
Typeable a =&gt;
(forall (c :: * -&gt; *).
 (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
 -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Strictness)
$cStrict :: Constr
$cLazy :: Constr
$cUnspecifiedStrictness :: Constr
$tStrictness :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Strictness -&gt; m Strictness
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Strictness -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Strictness -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Strictness -&gt; Strictness
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Strictness)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Strictness)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Strictness)
dataTypeOf :: Strictness -&gt; DataType
$cdataTypeOf :: Strictness -&gt; DataType
toConstr :: Strictness -&gt; Constr
$ctoConstr :: Strictness -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Strictness
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Strictness -&gt; c Strictness
$cp1Data :: Typeable Strictness
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-cpp">
#ifdef HAS_GENERICS
</span><span>           </span><span class="hs-special">,</span><span class="annot"><span class="annottext">(forall x. Strictness -&gt; Rep Strictness x)
-&gt; (forall x. Rep Strictness x -&gt; Strictness) -&gt; Generic Strictness
forall x. Rep Strictness x -&gt; Strictness
forall x. Strictness -&gt; Rep Strictness x
forall a.
(forall x. a -&gt; Rep a x) -&gt; (forall x. Rep a x -&gt; a) -&gt; Generic a
$cto :: forall x. Rep Strictness x -&gt; Strictness
$cfrom :: forall x. Strictness -&gt; Rep Strictness x
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">Generic</span></span><span class="hs-cpp">
#endif
</span><span>           </span><span class="hs-special">)</span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier hs-type">isStrictAnnot</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier hs-type">notStrictAnnot</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier hs-type">unpackedAnnot</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span>
</span><span id="line-299"></span><span id="isStrictAnnot"><span class="annot"><span class="annottext">isStrictAnnot :: FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#isStrictAnnot"><span class="hs-identifier hs-var hs-var">isStrictAnnot</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span><span>
</span><span id="line-300"></span><span id="notStrictAnnot"><span class="annot"><span class="annottext">notStrictAnnot :: FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#notStrictAnnot"><span class="hs-identifier hs-var hs-var">notStrictAnnot</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a></span><span>
</span><span id="line-301"></span><span id="unpackedAnnot"><span class="annot"><span class="annottext">unpackedAnnot :: FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#unpackedAnnot"><span class="hs-identifier hs-var hs-var">unpackedAnnot</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span><span>
</span><span id="line-302"></span><span>
</span><span id="line-303"></span><span class="hs-comment">-- | Construct a Type using the datatype's type constructor and type</span><span>
</span><span id="line-304"></span><span class="hs-comment">-- parameters. Kind signatures are removed.</span><span>
</span><span id="line-305"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier hs-type">datatypeType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-306"></span><span id="datatypeType"><span class="annot"><span class="annottext">datatypeType :: DatatypeInfo -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#datatypeType"><span class="hs-identifier hs-var hs-var">datatypeType</span></a></span></span><span> </span><span id="local-6989586621679083252"><span class="annot"><span class="annottext">di :: DatatypeInfo
</span><a href="#local-6989586621679083252"><span class="hs-identifier hs-var">di</span></a></span></span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; Cxt -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var hs-var">datatypeName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083252"><span class="hs-identifier hs-var">di</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-308"></span><span>  </span><span class="annot"><span class="annottext">(Cxt -&gt; Type) -&gt; Cxt -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Cxt -&gt; Cxt
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var">stripSigT</span></a></span><span>
</span><span id="line-309"></span><span>  </span><span class="annot"><span class="annottext">(Cxt -&gt; Cxt) -&gt; Cxt -&gt; Cxt
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var hs-var">datatypeInstTypes</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083252"><span class="hs-identifier hs-var">di</span></a></span><span>
</span><span id="line-310"></span><span>
</span><span id="line-311"></span><span>
</span><span id="line-312"></span><span class="hs-comment">-- | Compute a normalized view of the metadata about a data type or newtype</span><span>
</span><span id="line-313"></span><span class="hs-comment">-- given a constructor.</span><span>
</span><span id="line-314"></span><span class="hs-comment">--</span><span>
</span><span id="line-315"></span><span class="hs-comment">-- This function will accept any constructor (value or type) for a type</span><span>
</span><span id="line-316"></span><span class="hs-comment">-- declared with newtype or data. Value constructors must be used to</span><span>
</span><span id="line-317"></span><span class="hs-comment">-- lookup datatype information about /data instances/ and /newtype instances/,</span><span>
</span><span id="line-318"></span><span class="hs-comment">-- as giving the type constructor of a data family is often not enough to</span><span>
</span><span id="line-319"></span><span class="hs-comment">-- determine a particular data family instance.</span><span>
</span><span id="line-320"></span><span class="hs-comment">--</span><span>
</span><span id="line-321"></span><span class="hs-comment">-- In addition, this function will also accept a record selector for a</span><span>
</span><span id="line-322"></span><span class="hs-comment">-- data type with a constructor which uses that record.</span><span>
</span><span id="line-323"></span><span class="hs-comment">--</span><span>
</span><span id="line-324"></span><span class="hs-comment">-- GADT constructors are normalized into datatypes with explicit equality</span><span>
</span><span id="line-325"></span><span class="hs-comment">-- constraints. Note that no effort is made to distinguish between equalities of</span><span>
</span><span id="line-326"></span><span class="hs-comment">-- the same (homogeneous) kind and equalities between different (heterogeneous)</span><span>
</span><span id="line-327"></span><span class="hs-comment">-- kinds. For instance, the following GADT's constructors:</span><span>
</span><span id="line-328"></span><span class="hs-comment">--</span><span>
</span><span id="line-329"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-330"></span><span class="hs-comment">-- data T (a :: k -&gt; *) where</span><span>
</span><span id="line-331"></span><span class="hs-comment">--   MkT1 :: T Proxy</span><span>
</span><span id="line-332"></span><span class="hs-comment">--   MkT2 :: T Maybe</span><span>
</span><span id="line-333"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-334"></span><span class="hs-comment">--</span><span>
</span><span id="line-335"></span><span class="hs-comment">-- will be normalized to the following equality constraints:</span><span>
</span><span id="line-336"></span><span class="hs-comment">--</span><span>
</span><span id="line-337"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-338"></span><span class="hs-comment">-- AppT (AppT EqualityT (VarT a)) (ConT Proxy) -- MkT1</span><span>
</span><span id="line-339"></span><span class="hs-comment">-- AppT (AppT EqualityT (VarT a)) (ConT Maybe) -- MkT2</span><span>
</span><span id="line-340"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-341"></span><span class="hs-comment">--</span><span>
</span><span id="line-342"></span><span class="hs-comment">-- But only the first equality constraint is well kinded, since in the second</span><span>
</span><span id="line-343"></span><span class="hs-comment">-- constraint, the kinds of @(a :: k -&gt; *)@ and @(Maybe :: * -&gt; *)@ are different.</span><span>
</span><span id="line-344"></span><span class="hs-comment">-- Trying to categorize which constraints need homogeneous or heterogeneous</span><span>
</span><span id="line-345"></span><span class="hs-comment">-- equality is tricky, so we leave that task to users of this library.</span><span>
</span><span id="line-346"></span><span class="hs-comment">--</span><span>
</span><span id="line-347"></span><span class="hs-comment">-- This function will apply various bug-fixes to the output of the underlying</span><span>
</span><span id="line-348"></span><span class="hs-comment">-- @template-haskell@ library in order to provide a view of datatypes in</span><span>
</span><span id="line-349"></span><span class="hs-comment">-- as uniform a way as possible.</span><span>
</span><span id="line-350"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-type">reifyDatatype</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-351"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">{- ^ data type or constructor name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-352"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-353"></span><span id="reifyDatatype"><span class="annot"><span class="annottext">reifyDatatype :: Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var hs-var">reifyDatatype</span></a></span></span><span> </span><span id="local-6989586621679083247"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679083247"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool -&gt; Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var">normalizeInfo'</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;reifyDatatype&quot;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">(Info -&gt; Q DatatypeInfo) -&gt; Q Info -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><span class="hs-identifier hs-var">reify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083247"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-354"></span><span>
</span><span id="line-355"></span><span class="hs-comment">-- | Compute a normalized view of the metadata about a constructor given its</span><span>
</span><span id="line-356"></span><span class="hs-comment">-- 'Name'. This is useful for scenarios when you don't care about the info for</span><span>
</span><span id="line-357"></span><span class="hs-comment">-- the enclosing data type.</span><span>
</span><span id="line-358"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier hs-type">reifyConstructor</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-359"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">{- ^ constructor name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-360"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-361"></span><span id="reifyConstructor"><span class="annot"><span class="annottext">reifyConstructor :: Name -&gt; Q ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyConstructor"><span class="hs-identifier hs-var hs-var">reifyConstructor</span></a></span></span><span> </span><span id="local-6989586621679083242"><span class="annot"><span class="annottext">conName :: Name
</span><a href="#local-6989586621679083242"><span class="hs-identifier hs-var">conName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-362"></span><span>  </span><span id="local-6989586621679083241"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083241"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083242"><span class="hs-identifier hs-var">conName</span></a></span><span>
</span><span id="line-363"></span><span>  </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Q ConstructorInfo
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Q ConstructorInfo)
-&gt; ConstructorInfo -&gt; Q ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-var">lookupByConstructorName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083242"><span class="hs-identifier hs-var">conName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083241"><span class="hs-identifier hs-var">dataInfo</span></a></span><span>
</span><span id="line-364"></span><span>
</span><span id="line-365"></span><span class="hs-comment">-- | Compute a normalized view of the metadata about a constructor given the</span><span>
</span><span id="line-366"></span><span class="hs-comment">-- 'Name' of one of its record selectors. This is useful for scenarios when you</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- don't care about the info for the enclosing data type.</span><span>
</span><span id="line-368"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier hs-type">reifyRecord</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-369"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">{- ^ record name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-370"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-371"></span><span id="reifyRecord"><span class="annot"><span class="annottext">reifyRecord :: Name -&gt; Q ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyRecord"><span class="hs-identifier hs-var hs-var">reifyRecord</span></a></span></span><span> </span><span id="local-6989586621679083240"><span class="annot"><span class="annottext">recordName :: Name
</span><a href="#local-6989586621679083240"><span class="hs-identifier hs-var">recordName</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-372"></span><span>  </span><span id="local-6989586621679083239"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083239"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyDatatype"><span class="hs-identifier hs-var">reifyDatatype</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083240"><span class="hs-identifier hs-var">recordName</span></a></span><span>
</span><span id="line-373"></span><span>  </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Q ConstructorInfo
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Q ConstructorInfo)
-&gt; ConstructorInfo -&gt; Q ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-var">lookupByRecordName</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083240"><span class="hs-identifier hs-var">recordName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083239"><span class="hs-identifier hs-var">dataInfo</span></a></span><span>
</span><span id="line-374"></span><span>
</span><span id="line-375"></span><span class="hs-comment">-- | Given a 'DatatypeInfo', find the 'ConstructorInfo' corresponding to the</span><span>
</span><span id="line-376"></span><span class="hs-comment">-- 'Name' of one of its constructors.</span><span>
</span><span id="line-377"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-type">lookupByConstructorName</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-378"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">{- ^ constructor name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-379"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-comment">{- ^ info for the datatype which has that constructor -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-380"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-381"></span><span id="lookupByConstructorName"><span class="annot"><span class="annottext">lookupByConstructorName :: Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByConstructorName"><span class="hs-identifier hs-var hs-var">lookupByConstructorName</span></a></span></span><span> </span><span id="local-6989586621679083238"><span class="annot"><span class="annottext">conName :: Name
</span><a href="#local-6989586621679083238"><span class="hs-identifier hs-var">conName</span></a></span></span><span> </span><span id="local-6989586621679083237"><span class="annot"><span class="annottext">dataInfo :: DatatypeInfo
</span><a href="#local-6989586621679083237"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-382"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Bool)
-&gt; [ConstructorInfo] -&gt; Maybe ConstructorInfo
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">find</span></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083238"><span class="hs-identifier hs-var">conName</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Bool)
-&gt; (ConstructorInfo -&gt; Name) -&gt; ConstructorInfo -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier hs-var hs-var">constructorName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083237"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-383"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679083235"><span class="annot"><span class="annottext">conInfo :: ConstructorInfo
</span><a href="#local-6989586621679083235"><span class="hs-identifier hs-var">conInfo</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679083235"><span class="hs-identifier hs-var">conInfo</span></a></span><span>
</span><span id="line-384"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; ConstructorInfo
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ConstructorInfo) -&gt; String -&gt; ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;Datatype &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var hs-var">datatypeName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083237"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-385"></span><span>                         </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot; does not have a constructor named &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083238"><span class="hs-identifier hs-var">conName</span></a></span><span>
</span><span id="line-386"></span><span class="hs-comment">-- | Given a 'DatatypeInfo', find the 'ConstructorInfo' corresponding to the</span><span>
</span><span id="line-387"></span><span class="hs-comment">-- 'Name' of one of its constructors.</span><span>
</span><span id="line-388"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-type">lookupByRecordName</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-389"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">{- ^ record name -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-390"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-comment">{- ^ info for the datatype which has that constructor -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-391"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-392"></span><span id="lookupByRecordName"><span class="annot"><span class="annottext">lookupByRecordName :: Name -&gt; DatatypeInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#lookupByRecordName"><span class="hs-identifier hs-var hs-var">lookupByRecordName</span></a></span></span><span> </span><span id="local-6989586621679083232"><span class="annot"><span class="annottext">recordName :: Name
</span><a href="#local-6989586621679083232"><span class="hs-identifier hs-var">recordName</span></a></span></span><span> </span><span id="local-6989586621679083231"><span class="annot"><span class="annottext">dataInfo :: DatatypeInfo
</span><a href="#local-6989586621679083231"><span class="hs-identifier hs-var">dataInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-393"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Bool)
-&gt; [ConstructorInfo] -&gt; Maybe ConstructorInfo
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">find</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ConstructorInfo -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var">conHasRecord</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083232"><span class="hs-identifier hs-var">recordName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083231"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-394"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679083229"><span class="annot"><span class="annottext">conInfo :: ConstructorInfo
</span><a href="#local-6989586621679083229"><span class="hs-identifier hs-var">conInfo</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679083229"><span class="hs-identifier hs-var">conInfo</span></a></span><span>
</span><span id="line-395"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; ConstructorInfo
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; ConstructorInfo) -&gt; String -&gt; ConstructorInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;Datatype &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var hs-var">datatypeName</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083231"><span class="hs-identifier hs-var">dataInfo</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-396"></span><span>                         </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot; does not have any constructors with a &quot;</span></span><span>
</span><span id="line-397"></span><span>                         </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;record selector named &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083232"><span class="hs-identifier hs-var">recordName</span></a></span><span>
</span><span id="line-398"></span><span>
</span><span id="line-399"></span><span class="hs-comment">-- | Normalize 'Info' for a newtype or datatype into a 'DatatypeInfo'.</span><span>
</span><span id="line-400"></span><span class="hs-comment">-- Fail in 'Q' otherwise.</span><span>
</span><span id="line-401"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier hs-type">normalizeInfo</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Info</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-402"></span><span id="normalizeInfo"><span class="annot"><span class="annottext">normalizeInfo :: Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo"><span class="hs-identifier hs-var hs-var">normalizeInfo</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool -&gt; Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var">normalizeInfo'</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;normalizeInfo&quot;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a></span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-type">normalizeInfo'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Info</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-405"></span><span id="normalizeInfo%27"><span class="annot"><span class="annottext">normalizeInfo' :: String -&gt; Bool -&gt; Info -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeInfo%27"><span class="hs-identifier hs-var hs-var">normalizeInfo'</span></a></span></span><span> </span><span id="local-6989586621679083226"><span class="annot"><span class="annottext">entry :: String
</span><a href="#local-6989586621679083226"><span class="hs-identifier hs-var">entry</span></a></span></span><span> </span><span id="local-6989586621679083225"><span class="annot"><span class="annottext">reifiedDec :: Bool
</span><a href="#local-6989586621679083225"><span class="hs-identifier hs-var">reifiedDec</span></a></span></span><span> </span><span id="local-6989586621679083224"><span class="annot"><span class="annottext">i :: Info
</span><a href="#local-6989586621679083224"><span class="hs-identifier hs-var">i</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-406"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679083224"><span class="hs-identifier hs-var">i</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-407"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">PrimTyConI</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>                      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679083222"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Primitive type not supported&quot;</span></span><span>
</span><span id="line-408"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">ClassI</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>                          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679083222"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Class not supported&quot;</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">FamilyI</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataFamilyD</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-identifier">_</span><span>           </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,7,0)
</span><span>    </span><span class="hs-identifier">FamilyI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">DataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">DataFam</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">-&gt;</span><span class="hs-cpp">
#endif
</span><span>                                         </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679083222"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Use a value constructor to reify a data family instance&quot;</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,7,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">FamilyI</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679083222"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Type families not supported&quot;</span></span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">TyConI</span></span><span> </span><span id="local-6989586621679083217"><span class="annot"><span class="annottext">dec :: Dec
</span><a href="#local-6989586621679083217"><span class="hs-identifier hs-var">dec</span></a></span></span><span>                        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679083225"><span class="hs-identifier hs-var">reifiedDec</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083217"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">DataConI</span></span><span> </span><span id="local-6989586621679083214"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083214"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679083213"><span class="annot"><span class="annottext">parent :: Name
</span><a href="#local-6989586621679083213"><span class="hs-identifier hs-var">parent</span></a></span></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-var">reifyParent</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083214"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083213"><span class="hs-identifier hs-var">parent</span></a></span><span>
</span><span id="line-423"></span><span>                                         </span><span class="hs-comment">-- NB: We do not pass the IsReifiedDec information here</span><span>
</span><span id="line-424"></span><span>                                         </span><span class="hs-comment">-- because there's no point. We have no choice but to</span><span>
</span><span id="line-425"></span><span>                                         </span><span class="hs-comment">-- call reify here, since we need to determine the</span><span>
</span><span id="line-426"></span><span>                                         </span><span class="hs-comment">-- parent data type/family.</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">parent</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">reifyParent</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">parent</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">VarI</span></span><span> </span><span id="local-6989586621679083210"><span class="annot"><span class="annottext">recName :: Name
</span><a href="#local-6989586621679083210"><span class="hs-identifier hs-var">recName</span></a></span></span><span> </span><span id="local-6989586621679083209"><span class="annot"><span class="annottext">recTy :: Type
</span><a href="#local-6989586621679083209"><span class="hs-identifier hs-var">recTy</span></a></span></span><span> </span><span class="hs-identifier">_</span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-var">reifyRecordType</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083210"><span class="hs-identifier hs-var">recName</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083209"><span class="hs-identifier hs-var">recTy</span></a></span><span>
</span><span id="line-432"></span><span>                                         </span><span class="hs-comment">-- NB: Similarly, we do not pass the IsReifiedDec</span><span>
</span><span id="line-433"></span><span>                                         </span><span class="hs-comment">-- information here.</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">VarI</span><span> </span><span class="hs-identifier">recName</span><span> </span><span class="hs-identifier">recTy</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">reifyRecordType</span><span> </span><span class="hs-identifier">recName</span><span> </span><span class="hs-identifier">recTy</span><span class="hs-cpp">
#endif
</span><span>    </span><span class="hs-identifier">_</span><span>                                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><a href="#local-6989586621679083222"><span class="hs-identifier hs-var">bad</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;Expected a type constructor&quot;</span></span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-439"></span><span>    </span><span id="local-6989586621679083222"><span class="annot"><span class="annottext">bad :: String -&gt; m a
</span><a href="#local-6989586621679083222"><span class="hs-identifier hs-var hs-var">bad</span></a></span></span><span> </span><span id="local-6989586621679083207"><span class="annot"><span class="annottext">msg :: String
</span><a href="#local-6989586621679083207"><span class="hs-identifier hs-var">msg</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; m a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679083226"><span class="hs-identifier hs-var">entry</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679083207"><span class="hs-identifier hs-var">msg</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-440"></span><span>
</span><span id="line-441"></span><span>
</span><span id="line-442"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-type">reifyParent</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-443"></span><span id="reifyParent"><span class="annot"><span class="annottext">reifyParent :: Name -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParent"><span class="hs-identifier hs-var hs-var">reifyParent</span></a></span></span><span> </span><span id="local-6989586621679083206"><span class="annot"><span class="annottext">con :: Name
</span><a href="#local-6989586621679083206"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; (DatatypeInfo -&gt; Bool) -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var">reifyParentWith</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;reifyParent&quot;</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679083204"><span class="hs-identifier hs-var">p</span></a></span><span>
</span><span id="line-444"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-445"></span><span>    </span><span class="annot"><a href="#local-6989586621679083204"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-446"></span><span>    </span><span id="local-6989586621679083204"><span class="annot"><span class="annottext">p :: DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679083204"><span class="hs-identifier hs-var hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679083203"><span class="annot"><span class="annottext">info :: DatatypeInfo
</span><a href="#local-6989586621679083203"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083206"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Name) -&gt; [ConstructorInfo] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#constructorName"><span class="hs-identifier hs-var hs-var">constructorName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083203"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-447"></span><span>
</span><span id="line-448"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-type">reifyRecordType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-449"></span><span id="reifyRecordType"><span class="annot"><span class="annottext">reifyRecordType :: Name -&gt; Type -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyRecordType"><span class="hs-identifier hs-var hs-var">reifyRecordType</span></a></span></span><span> </span><span id="local-6989586621679083201"><span class="annot"><span class="annottext">recName :: Name
</span><a href="#local-6989586621679083201"><span class="hs-identifier hs-var">recName</span></a></span></span><span> </span><span id="local-6989586621679083200"><span class="annot"><span class="annottext">recTy :: Type
</span><a href="#local-6989586621679083200"><span class="hs-identifier hs-var">recTy</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-450"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083199"><span class="annot"><span class="annottext">argTys :: Cxt
</span><a href="#local-6989586621679083199"><span class="hs-identifier hs-var">argTys</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-type">:|-</span></a></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-var">uncurryType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083200"><span class="hs-identifier hs-var">recTy</span></a></span><span>
</span><span id="line-451"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083199"><span class="hs-identifier hs-var">argTys</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-452"></span><span>       </span><span id="local-6989586621679083196"><span class="annot"><span class="annottext">dataTy :: Type
</span><a href="#local-6989586621679083196"><span class="hs-identifier hs-var">dataTy</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083195"><span class="hs-identifier hs-var">decomposeDataType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083196"><span class="hs-identifier hs-var">dataTy</span></a></span><span>
</span><span id="line-453"></span><span>       </span><span class="hs-identifier">_</span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q DatatypeInfo
forall a. Q a
</span><a href="#local-6989586621679083194"><span class="hs-identifier hs-var">notRecSelFailure</span></a></span><span>
</span><span id="line-454"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-455"></span><span>    </span><span class="annot"><a href="#local-6989586621679083195"><span class="hs-identifier hs-type">decomposeDataType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-456"></span><span>    </span><span id="local-6989586621679083195"><span class="annot"><span class="annottext">decomposeDataType :: Type -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083195"><span class="hs-identifier hs-var hs-var">decomposeDataType</span></a></span></span><span> </span><span id="local-6989586621679083193"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679083193"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-457"></span><span>      </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083193"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-458"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679083191"><span class="annot"><span class="annottext">parent :: Name
</span><a href="#local-6989586621679083191"><span class="hs-identifier hs-var">parent</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; (DatatypeInfo -&gt; Bool) -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var">reifyParentWith</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;reifyRecordType&quot;</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679083189"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083191"><span class="hs-identifier hs-var">parent</span></a></span><span>
</span><span id="line-459"></span><span>           </span><span class="hs-identifier">_</span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q DatatypeInfo
forall a. Q a
</span><a href="#local-6989586621679083194"><span class="hs-identifier hs-var">notRecSelFailure</span></a></span><span>
</span><span id="line-460"></span><span>
</span><span id="line-461"></span><span>    </span><span id="local-6989586621679083892"><span class="annot"><a href="#local-6989586621679083194"><span class="hs-identifier hs-type">notRecSelFailure</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679083892"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-462"></span><span>    </span><span id="local-6989586621679083194"><span class="annot"><span class="annottext">notRecSelFailure :: Q a
</span><a href="#local-6989586621679083194"><span class="hs-identifier hs-var hs-var">notRecSelFailure</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-463"></span><span>      </span><span class="annot"><span class="hs-string">&quot;reifyRecordType: Not a record selector type: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-464"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083201"><span class="hs-identifier hs-var">recName</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot; :: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083200"><span class="hs-identifier hs-var">recTy</span></a></span><span>
</span><span id="line-465"></span><span>
</span><span id="line-466"></span><span>    </span><span class="annot"><a href="#local-6989586621679083189"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-467"></span><span>    </span><span id="local-6989586621679083189"><span class="annot"><span class="annottext">p :: DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679083189"><span class="hs-identifier hs-var hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679083187"><span class="annot"><span class="annottext">info :: DatatypeInfo
</span><a href="#local-6989586621679083187"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; Bool) -&gt; [ConstructorInfo] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">any</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; ConstructorInfo -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var">conHasRecord</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083201"><span class="hs-identifier hs-var">recName</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083187"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-468"></span><span>
</span><span id="line-469"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-type">reifyParentWith</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-470"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>                 </span><span class="hs-comment">{- ^ prefix for error messages -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-471"></span><span>  </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span class="hs-special">)</span><span> </span><span class="hs-comment">{- ^ predicate for finding the right
                              data family instance -}</span><span>      </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-473"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>                   </span><span class="hs-comment">{- ^ parent data type name -}</span><span>     </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-474"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-475"></span><span id="reifyParentWith"><span class="annot"><span class="annottext">reifyParentWith :: String -&gt; (DatatypeInfo -&gt; Bool) -&gt; Name -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#reifyParentWith"><span class="hs-identifier hs-var hs-var">reifyParentWith</span></a></span></span><span> </span><span id="local-6989586621679083185"><span class="annot"><span class="annottext">prefix :: String
</span><a href="#local-6989586621679083185"><span class="hs-identifier hs-var">prefix</span></a></span></span><span> </span><span id="local-6989586621679083184"><span class="annot"><span class="annottext">p :: DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679083184"><span class="hs-identifier hs-var">p</span></a></span></span><span> </span><span id="local-6989586621679083183"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679083183"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-476"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679083182"><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679083182"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><span class="hs-identifier hs-var">reify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083183"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-477"></span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Info
</span><a href="#local-6989586621679083182"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if !(MIN_VERSION_template_haskell(2,11,0))
</span><span>       </span><span class="hs-comment">-- This unusual combination of Info and Dec is only possible to reify on</span><span>
</span><span id="line-480"></span><span>       </span><span class="hs-comment">-- GHC 7.0 and 7.2, when you try to reify a data family. Because there's</span><span>
</span><span id="line-481"></span><span>       </span><span class="hs-comment">-- no way to reify the data family *instances* on these versions of GHC,</span><span>
</span><span id="line-482"></span><span>       </span><span class="hs-comment">-- we have no choice but to fail.</span><span>
</span><span id="line-483"></span><span>       </span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-identifier">FamilyD</span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamiliesOnOldGHCsError</span><span class="hs-cpp">
#endif
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">TyConI</span></span><span> </span><span id="local-6989586621679083181"><span class="annot"><span class="annottext">dec :: Dec
</span><a href="#local-6989586621679083181"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083181"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,7,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">FamilyI</span></span><span> </span><span id="local-6989586621679083180"><span class="annot"><span class="annottext">dec :: Dec
</span><a href="#local-6989586621679083180"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span id="local-6989586621679083179"><span class="annot"><span class="annottext">instances :: [Dec]
</span><a href="#local-6989586621679083179"><span class="hs-identifier hs-var">instances</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-488"></span><span>         </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679083178"><span class="annot"><span class="annottext">instances1 :: [Dec]
</span><a href="#local-6989586621679083178"><span class="hs-identifier hs-var hs-var">instances1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Dec) -&gt; [Dec] -&gt; [Dec]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Dec -&gt; Dec -&gt; Dec
</span><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var">repairDataFam</span></a></span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083180"><span class="hs-identifier hs-var">dec</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679083179"><span class="hs-identifier hs-var">instances</span></a></span><span>
</span><span id="line-489"></span><span>            </span><span id="local-6989586621679083176"><span class="annot"><span class="annottext">[DatatypeInfo]
</span><a href="#local-6989586621679083176"><span class="hs-identifier hs-var">instances2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Dec -&gt; Q DatatypeInfo) -&gt; [Dec] -&gt; Q [DatatypeInfo]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var">isReified</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Dec]
</span><a href="#local-6989586621679083178"><span class="hs-identifier hs-var">instances1</span></a></span><span>
</span><span id="line-490"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(DatatypeInfo -&gt; Bool) -&gt; [DatatypeInfo] -&gt; Maybe DatatypeInfo
forall (t :: * -&gt; *) a. Foldable t =&gt; (a -&gt; Bool) -&gt; t a -&gt; Maybe a
</span><span class="hs-identifier hs-var">find</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Bool
</span><a href="#local-6989586621679083184"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">[DatatypeInfo]
</span><a href="#local-6989586621679083176"><span class="hs-identifier hs-var">instances2</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-491"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679083174"><span class="annot"><span class="annottext">inst :: DatatypeInfo
</span><a href="#local-6989586621679083174"><span class="hs-identifier hs-var">inst</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083174"><span class="hs-identifier hs-var">inst</span></a></span><span>
</span><span id="line-492"></span><span>              </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall a. String -&gt; Q a
</span><a href="#local-6989586621679083173"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;lost the instance&quot;</span></span><span class="hs-cpp">
#endif
</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall a. String -&gt; Q a
</span><a href="#local-6989586621679083173"><span class="hs-identifier hs-var">panic</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;unexpected parent&quot;</span></span><span>
</span><span id="line-495"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-496"></span><span>    </span><span id="local-6989586621679083172"><span class="annot"><a href="#local-6989586621679083171"><span class="hs-identifier hs-type">dataFamiliesOnOldGHCsError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679083172"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-497"></span><span>    </span><span id="local-6989586621679083171"><span class="annot"><span class="annottext">dataFamiliesOnOldGHCsError :: Q a
</span><a href="#local-6989586621679083171"><span class="hs-identifier hs-var hs-var">dataFamiliesOnOldGHCsError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-498"></span><span>      </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679083185"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;: Data family instances can only be reified with GHC 7.4 or later&quot;</span></span><span>
</span><span id="line-499"></span><span>
</span><span id="line-500"></span><span>    </span><span id="local-6989586621679083883"><span class="annot"><a href="#local-6989586621679083173"><span class="hs-identifier hs-type">panic</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="#local-6989586621679083883"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-501"></span><span>    </span><span id="local-6989586621679083173"><span class="annot"><span class="annottext">panic :: String -&gt; Q a
</span><a href="#local-6989586621679083173"><span class="hs-identifier hs-var hs-var">panic</span></a></span></span><span> </span><span id="local-6989586621679083170"><span class="annot"><span class="annottext">message :: String
</span><a href="#local-6989586621679083170"><span class="hs-identifier hs-var">message</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q a
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q a) -&gt; String -&gt; Q a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;PANIC: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679083185"><span class="hs-identifier hs-var">prefix</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot; &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679083170"><span class="hs-identifier hs-var">message</span></a></span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,8,0) &amp;&amp; (!MIN_VERSION_template_haskell(2,10,0))
</span><span>
</span><span id="line-505"></span><span class="hs-comment">-- A GHC 7.6-specific bug requires us to replace all occurrences of</span><span>
</span><span id="line-506"></span><span class="hs-comment">-- (ConT GHC.Prim.*) with StarT, or else Template Haskell will reject it.</span><span>
</span><span id="line-507"></span><span class="hs-comment">-- Luckily, (ConT GHC.Prim.*) only seems to occur in this one spot.</span><span>
</span><span id="line-508"></span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind</span><span>
</span><span id="line-509"></span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span>
</span><span id="line-510"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-511"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Kind</span><span>
</span><span id="line-512"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">AppT</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">AppT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t1</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span>
</span><span id="line-513"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">SigT</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">SigT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span>
</span><span id="line-514"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">n</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">starKindName</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">StarT</span><span>
</span><span id="line-515"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">t</span><span>                            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">t</span><span>
</span><span id="line-516"></span><span>
</span><span id="line-517"></span><span class="hs-comment">-- A version of repairVarKindsWith that does much more extra work to</span><span>
</span><span id="line-518"></span><span class="hs-comment">-- (1) eta-expand missing type patterns, and (2) ensure that the kind</span><span>
</span><span id="line-519"></span><span class="hs-comment">-- signatures for these new type patterns match accordingly.</span><span>
</span><span id="line-520"></span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">TyVarBndr</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span>
</span><span id="line-521"></span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-522"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">kindVars</span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">kindPart</span><span>
</span><span id="line-523"></span><span>      </span><span class="hs-identifier">kindPart</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">KindedTV</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">k</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">k</span><span class="hs-special">]</span><span>
</span><span id="line-524"></span><span>      </span><span class="hs-identifier">kindPart</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">PlainTV</span><span>  </span><span class="hs-identifier">_</span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-525"></span><span>
</span><span id="line-526"></span><span>      </span><span class="hs-identifier">nparams</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">dvars</span><span>
</span><span id="line-527"></span><span>      </span><span class="hs-identifier">kparams</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">kindVars</span><span> </span><span class="hs-identifier">dvars</span><span>
</span><span id="line-528"></span><span>      </span><span class="hs-special">(</span><span class="hs-identifier">tsKinds</span><span class="hs-special">,</span><span class="hs-identifier">tsNoKinds</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">splitAt</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">kparams</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-529"></span><span>      </span><span class="hs-identifier">tsKinds'</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">sanitizeStars</span><span> </span><span class="hs-identifier">tsKinds</span><span>
</span><span id="line-530"></span><span>      </span><span class="hs-identifier">extraTys</span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">drop</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">length</span><span> </span><span class="hs-identifier">tsNoKinds</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">bndrParams</span><span> </span><span class="hs-identifier">dvars</span><span class="hs-special">)</span><span>
</span><span id="line-531"></span><span>      </span><span class="hs-identifier">ts'</span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">tsNoKinds</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">extraTys</span><span> </span><span class="hs-comment">-- eta-expand</span><span>
</span><span id="line-532"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Map.fromList</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">zip</span><span> </span><span class="hs-identifier">kparams</span><span> </span><span class="hs-identifier">tsKinds'</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-operator">$</span><span>
</span><span id="line-533"></span><span>     </span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts'</span><span>
</span><span id="line-534"></span><span>
</span><span id="line-535"></span><span>
</span><span id="line-536"></span><span class="hs-comment">-- Sadly, Template Haskell's treatment of data family instances leaves much</span><span>
</span><span id="line-537"></span><span class="hs-comment">-- to be desired. Here are some problems that we have to work around:</span><span>
</span><span id="line-538"></span><span class="hs-comment">--</span><span>
</span><span id="line-539"></span><span class="hs-comment">-- 1. On all versions of GHC, TH leaves off the kind signatures on the</span><span>
</span><span id="line-540"></span><span class="hs-comment">--    type patterns of data family instances where a kind signature isn't</span><span>
</span><span id="line-541"></span><span class="hs-comment">--    specified explicitly. Here, we can use the parent data family's</span><span>
</span><span id="line-542"></span><span class="hs-comment">--    type variable binders to reconstruct the kind signatures if they</span><span>
</span><span id="line-543"></span><span class="hs-comment">--    are missing.</span><span>
</span><span id="line-544"></span><span class="hs-comment">-- 2. On GHC 7.6 and 7.8, TH will eta-reduce data instances. We can find</span><span>
</span><span id="line-545"></span><span class="hs-comment">--    the missing type variables on the data constructor.</span><span>
</span><span id="line-546"></span><span class="hs-comment">--</span><span>
</span><span id="line-547"></span><span class="hs-comment">-- We opt to avoid propagating these new type variables through to the</span><span>
</span><span id="line-548"></span><span class="hs-comment">-- constructor now, but we will return to this task in normalizeCon.</span><span>
</span><span id="line-549"></span><span class="hs-identifier">repairDataFam</span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-550"></span><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ family declaration   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-551"></span><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ instance declaration -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-552"></span><span>  </span><span class="hs-identifier">Dec</span><span> </span><span class="hs-comment">{- ^ instance declaration -}</span><span>
</span><span id="line-553"></span><span>
</span><span id="line-554"></span><span class="hs-identifier">repairDataFam</span><span>
</span><span id="line-555"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><span id="line-556"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-557"></span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><span id="line-558"></span><span class="hs-identifier">repairDataFam</span><span>
</span><span id="line-559"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>
</span><span id="line-560"></span><span>  </span><span class="hs-special">(</span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-561"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith'</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-cpp">
#else
</span><span id="repairDataFam"><span class="annot"><span class="annottext">repairDataFam :: Dec -&gt; Dec -&gt; Dec
</span><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var hs-var">repairDataFam</span></a></span></span><span> </span><span id="local-6989586621679083169"><span class="annot"><span class="annottext">famD :: Dec
</span><a href="#local-6989586621679083169"><span class="hs-identifier hs-var">famD</span></a></span></span><span> </span><span id="local-6989586621679083168"><span class="annot"><span class="annottext">instD :: Dec
</span><a href="#local-6989586621679083168"><span class="hs-identifier hs-var">instD</span></a></span></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,15,0)
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataFamilyD</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679083167"><span class="annot"><span class="annottext">dvars :: [TyVarBndr]
</span><a href="#local-6989586621679083167"><span class="hs-identifier hs-var">dvars</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083169"><span class="hs-identifier hs-var">famD</span></a></span><span>
</span><span id="line-566"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">NewtypeInstD</span></span><span> </span><span id="local-6989586621679083165"><span class="annot"><span class="annottext">cx :: Cxt
</span><a href="#local-6989586621679083165"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679083164"><span class="annot"><span class="annottext">mbInstVars :: Maybe [TyVarBndr]
</span><a href="#local-6989586621679083164"><span class="hs-identifier hs-var">mbInstVars</span></a></span></span><span> </span><span id="local-6989586621679083163"><span class="annot"><span class="annottext">nts :: Type
</span><a href="#local-6989586621679083163"><span class="hs-identifier hs-var">nts</span></a></span></span><span> </span><span id="local-6989586621679083162"><span class="annot"><span class="annottext">k :: Maybe Type
</span><a href="#local-6989586621679083162"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679083161"><span class="annot"><span class="annottext">c :: Con
</span><a href="#local-6989586621679083161"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679083160"><span class="annot"><span class="annottext">deriv :: [DerivClause]
</span><a href="#local-6989586621679083160"><span class="hs-identifier hs-var">deriv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083168"><span class="hs-identifier hs-var">instD</span></a></span><span>
</span><span id="line-567"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083159"><span class="annot"><span class="annottext">con :: Type
</span><a href="#local-6989586621679083159"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679083158"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679083158"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083163"><span class="hs-identifier hs-var">nts</span></a></span><span>
</span><span id="line-568"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt
-&gt; Maybe [TyVarBndr]
-&gt; Type
-&gt; Maybe Type
-&gt; Con
-&gt; [DerivClause]
-&gt; Dec
</span><span class="hs-identifier hs-var">NewtypeInstD</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083165"><span class="hs-identifier hs-var">cx</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndr]
</span><a href="#local-6989586621679083164"><span class="hs-identifier hs-var">mbInstVars</span></a></span><span>
</span><span id="line-569"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; Cxt -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083159"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var">repairVarKindsWith</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083167"><span class="hs-identifier hs-var">dvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083158"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-570"></span><span>          </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083162"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679083161"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679083160"><span class="hs-identifier hs-var">deriv</span></a></span><span>
</span><span id="line-571"></span><span>
</span><span id="line-572"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataFamilyD</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679083156"><span class="annot"><span class="annottext">dvars :: [TyVarBndr]
</span><a href="#local-6989586621679083156"><span class="hs-identifier hs-var">dvars</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083169"><span class="hs-identifier hs-var">famD</span></a></span><span>
</span><span id="line-573"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">DataInstD</span></span><span> </span><span id="local-6989586621679083154"><span class="annot"><span class="annottext">cx :: Cxt
</span><a href="#local-6989586621679083154"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679083153"><span class="annot"><span class="annottext">mbInstVars :: Maybe [TyVarBndr]
</span><a href="#local-6989586621679083153"><span class="hs-identifier hs-var">mbInstVars</span></a></span></span><span> </span><span id="local-6989586621679083152"><span class="annot"><span class="annottext">nts :: Type
</span><a href="#local-6989586621679083152"><span class="hs-identifier hs-var">nts</span></a></span></span><span> </span><span id="local-6989586621679083151"><span class="annot"><span class="annottext">k :: Maybe Type
</span><a href="#local-6989586621679083151"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span id="local-6989586621679083150"><span class="annot"><span class="annottext">c :: [Con]
</span><a href="#local-6989586621679083150"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679083149"><span class="annot"><span class="annottext">deriv :: [DerivClause]
</span><a href="#local-6989586621679083149"><span class="hs-identifier hs-var">deriv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083168"><span class="hs-identifier hs-var">instD</span></a></span><span>
</span><span id="line-574"></span><span>      </span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083148"><span class="annot"><span class="annottext">con :: Type
</span><a href="#local-6989586621679083148"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679083147"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679083147"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083152"><span class="hs-identifier hs-var">nts</span></a></span><span>
</span><span id="line-575"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt
-&gt; Maybe [TyVarBndr]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; [DerivClause]
-&gt; Dec
</span><span class="hs-identifier hs-var">DataInstD</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083154"><span class="hs-identifier hs-var">cx</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndr]
</span><a href="#local-6989586621679083153"><span class="hs-identifier hs-var">mbInstVars</span></a></span><span>
</span><span id="line-576"></span><span>          </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; Cxt -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083148"><span class="hs-identifier hs-var">con</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var">repairVarKindsWith</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083156"><span class="hs-identifier hs-var">dvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083147"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-577"></span><span>          </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083151"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083150"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">[DerivClause]
</span><a href="#local-6989586621679083149"><span class="hs-identifier hs-var">deriv</span></a></span><span class="hs-cpp">
# elif MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">DataFamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-580"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-581"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><span id="line-582"></span><span>
</span><span id="line-583"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">DataFamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-584"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-585"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-cpp">
# else
</span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-588"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-589"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span>
</span><span id="line-590"></span><span>
</span><span id="line-591"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">FamilyD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">famD</span><span>
</span><span id="line-592"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">instD</span><span>
</span><span id="line-593"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">cx</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">repairVarKindsWith</span><span> </span><span class="hs-identifier">dvars</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">deriv</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#repairDataFam"><span class="hs-identifier hs-var">repairDataFam</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679083146"><span class="annot"><span class="annottext">instD :: Dec
</span><a href="#local-6989586621679083146"><span class="hs-identifier hs-var">instD</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083146"><span class="hs-identifier hs-var">instD</span></a></span><span>
</span><span id="line-597"></span><span>
</span><span id="line-598"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-type">repairVarKindsWith</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-599"></span><span id="repairVarKindsWith"><span class="annot"><span class="annottext">repairVarKindsWith :: [TyVarBndr] -&gt; Cxt -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#repairVarKindsWith"><span class="hs-identifier hs-var hs-var">repairVarKindsWith</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Type -&gt; Type) -&gt; [TyVarBndr] -&gt; Cxt -&gt; Cxt
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var">stealKindForType</span></a></span><span>
</span><span id="line-600"></span><span>
</span><span id="line-601"></span><span class="hs-comment">-- If a VarT is missing an explicit kind signature, steal it from a TyVarBndr.</span><span>
</span><span id="line-602"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-type">stealKindForType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-603"></span><span id="stealKindForType"><span class="annot"><span class="annottext">stealKindForType :: TyVarBndr -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var hs-var">stealKindForType</span></a></span></span><span> </span><span id="local-6989586621679083143"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679083143"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span id="local-6989586621679083142"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679083142"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083142"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679083143"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-604"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stealKindForType"><span class="hs-identifier hs-var">stealKindForType</span></a></span><span> </span><span class="hs-identifier">_</span><span>   </span><span id="local-6989586621679083139"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679083139"><span class="hs-identifier hs-var">t</span></a></span></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083139"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-605"></span><span>
</span><span id="line-606"></span><span class="hs-comment">-- | Normalize 'Dec' for a newtype or datatype into a 'DatatypeInfo'.</span><span>
</span><span id="line-607"></span><span class="hs-comment">-- Fail in 'Q' otherwise.</span><span>
</span><span id="line-608"></span><span class="hs-comment">--</span><span>
</span><span id="line-609"></span><span class="hs-comment">-- Beware: 'normalizeDec' can have surprising behavior when it comes to fixity.</span><span>
</span><span id="line-610"></span><span class="hs-comment">-- For instance, if you have this quasiquoted data declaration:</span><span>
</span><span id="line-611"></span><span class="hs-comment">--</span><span>
</span><span id="line-612"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-613"></span><span class="hs-comment">-- [d| infix 5 :^^:</span><span>
</span><span id="line-614"></span><span class="hs-comment">--     data Foo where</span><span>
</span><span id="line-615"></span><span class="hs-comment">--       (:^^:) :: Int -&gt; Int -&gt; Foo |]</span><span>
</span><span id="line-616"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-617"></span><span class="hs-comment">--</span><span>
</span><span id="line-618"></span><span class="hs-comment">-- Then if you pass the 'Dec' for @Foo@ to 'normalizeDec' without splicing it</span><span>
</span><span id="line-619"></span><span class="hs-comment">-- in a previous Template Haskell splice, then @(:^^:)@ will be labeled a 'NormalConstructor'</span><span>
</span><span id="line-620"></span><span class="hs-comment">-- instead of an 'InfixConstructor'. This is because Template Haskell has no way to</span><span>
</span><span id="line-621"></span><span class="hs-comment">-- reify the fixity declaration for @(:^^:)@, so it must assume there isn't one. To</span><span>
</span><span id="line-622"></span><span class="hs-comment">-- work around this behavior, use 'reifyDatatype' instead.</span><span>
</span><span id="line-623"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier hs-type">normalizeDec</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-624"></span><span id="normalizeDec"><span class="annot"><span class="annottext">normalizeDec :: Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDec"><span class="hs-identifier hs-var hs-var">normalizeDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var">normalizeDecFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a></span><span>
</span><span id="line-625"></span><span>
</span><span id="line-626"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-type">normalizeDecFor</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Dec</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-627"></span><span id="normalizeDecFor"><span class="annot"><span class="annottext">normalizeDecFor :: Bool -&gt; Dec -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDecFor"><span class="hs-identifier hs-var hs-var">normalizeDecFor</span></a></span></span><span> </span><span id="local-6989586621679083138"><span class="annot"><span class="annottext">isReified :: Bool
</span><a href="#local-6989586621679083138"><span class="hs-identifier hs-var">isReified</span></a></span></span><span> </span><span id="local-6989586621679083137"><span class="annot"><span class="annottext">dec :: Dec
</span><a href="#local-6989586621679083137"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-628"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Dec
</span><a href="#local-6989586621679083137"><span class="hs-identifier hs-var">dec</span></a></span><span> </span><span class="hs-keyword">of</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,12,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">NewtypeD</span></span><span> </span><span id="local-6989586621679083135"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083135"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083134"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083134"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679083133"><span class="annot"><span class="annottext">tyvars :: [TyVarBndr]
</span><a href="#local-6989586621679083133"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679083132"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083132"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083131"><span class="annot"><span class="annottext">con :: Con
</span><a href="#local-6989586621679083131"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621679083130"><span class="annot"><span class="annottext">_derives :: [DerivClause]
</span><a href="#local-6989586621679083130"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-631"></span><span>      </span><span class="annot"><span class="annottext">Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083129"><span class="hs-identifier hs-var">normalizeDataD</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083135"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083134"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083133"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083132"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679083131"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-var">Newtype</span></a></span><span>
</span><span id="line-632"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">DataD</span></span><span> </span><span id="local-6989586621679083127"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083127"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083126"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083126"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679083125"><span class="annot"><span class="annottext">tyvars :: [TyVarBndr]
</span><a href="#local-6989586621679083125"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679083124"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083124"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083123"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083123"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083122"><span class="annot"><span class="annottext">_derives :: [DerivClause]
</span><a href="#local-6989586621679083122"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-633"></span><span>      </span><span class="annot"><span class="annottext">Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083129"><span class="hs-identifier hs-var">normalizeDataD</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083127"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083126"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083125"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083124"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083123"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-var">Datatype</span></a></span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,15,0)
</span><span>    </span><span class="annot"><span class="hs-identifier hs-type">NewtypeInstD</span></span><span> </span><span id="local-6989586621679083121"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083121"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083120"><span class="annot"><span class="annottext">mbTyvars :: Maybe [TyVarBndr]
</span><a href="#local-6989586621679083120"><span class="hs-identifier hs-var">mbTyvars</span></a></span></span><span> </span><span id="local-6989586621679083119"><span class="annot"><span class="annottext">nameInstTys :: Type
</span><a href="#local-6989586621679083119"><span class="hs-identifier hs-var">nameInstTys</span></a></span></span><span> </span><span id="local-6989586621679083118"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083118"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083117"><span class="annot"><span class="annottext">con :: Con
</span><a href="#local-6989586621679083117"><span class="hs-identifier hs-var">con</span></a></span></span><span> </span><span id="local-6989586621679083116"><span class="annot"><span class="annottext">_derives :: [DerivClause]
</span><a href="#local-6989586621679083116"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-636"></span><span>      </span><span class="annot"><span class="annottext">String
-&gt; Cxt
-&gt; Maybe [TyVarBndr]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083115"><span class="hs-identifier hs-var">normalizeDataInstDPostTH2'15</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;newtype&quot;</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083121"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndr]
</span><a href="#local-6989586621679083120"><span class="hs-identifier hs-var">mbTyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083119"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span>
</span><span id="line-637"></span><span>                                   </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083118"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679083117"><span class="hs-identifier hs-var">con</span></a></span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-var">NewtypeInstance</span></a></span><span>
</span><span id="line-638"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">DataInstD</span></span><span> </span><span id="local-6989586621679083114"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083114"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083113"><span class="annot"><span class="annottext">mbTyvars :: Maybe [TyVarBndr]
</span><a href="#local-6989586621679083113"><span class="hs-identifier hs-var">mbTyvars</span></a></span></span><span> </span><span id="local-6989586621679083112"><span class="annot"><span class="annottext">nameInstTys :: Type
</span><a href="#local-6989586621679083112"><span class="hs-identifier hs-var">nameInstTys</span></a></span></span><span> </span><span id="local-6989586621679083111"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083111"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083110"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083110"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083109"><span class="annot"><span class="annottext">_derives :: [DerivClause]
</span><a href="#local-6989586621679083109"><span class="hs-identifier hs-var">_derives</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-639"></span><span>      </span><span class="annot"><span class="annottext">String
-&gt; Cxt
-&gt; Maybe [TyVarBndr]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083115"><span class="hs-identifier hs-var">normalizeDataInstDPostTH2'15</span></a></span><span> </span><span class="annot"><span class="hs-string">&quot;data&quot;</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083114"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndr]
</span><a href="#local-6989586621679083113"><span class="hs-identifier hs-var">mbTyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083112"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span>
</span><span id="line-640"></span><span>                                   </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083111"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083110"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-var">DataInstance</span></a></span><span class="hs-cpp">
# else
</span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-643"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-644"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-645"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#elif MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="hs-identifier">NewtypeD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-649"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">Newtype</span><span>
</span><span id="line-650"></span><span>    </span><span class="hs-identifier">DataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-651"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">Datatype</span><span>
</span><span id="line-652"></span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-653"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-654"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-655"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">mbKind</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span class="hs-cpp">
#else
</span><span>    </span><span class="hs-identifier">NewtypeD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-658"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">Newtype</span><span>
</span><span id="line-659"></span><span>    </span><span class="hs-identifier">DataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-660"></span><span>      </span><span class="hs-identifier">normalizeDataD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">Datatype</span><span>
</span><span id="line-661"></span><span>    </span><span class="hs-identifier">NewtypeInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">con</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-662"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">con</span><span class="hs-special">]</span><span> </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-663"></span><span>    </span><span class="hs-identifier">DataInstD</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">_derives</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-664"></span><span>      </span><span class="hs-identifier">normalizeDataInstDPreTH2'15</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-identifier">name</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cons</span><span> </span><span class="hs-identifier">DataInstance</span><span class="hs-cpp">
#endif
</span><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="hs-string">&quot;normalizeDecFor: DataD or NewtypeD required&quot;</span></span><span>
</span><span id="line-667"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-668"></span><span>    </span><span class="hs-comment">-- We only need to repair reified declarations for data family instances.</span><span>
</span><span id="line-669"></span><span>    </span><span class="annot"><a href="#local-6989586621679083108"><span class="hs-identifier hs-type">repair13618'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-670"></span><span>    </span><span id="local-6989586621679083108"><span class="annot"><span class="annottext">repair13618' :: DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083108"><span class="hs-identifier hs-var hs-var">repair13618'</span></a></span></span><span> </span><span id="local-6989586621679083107"><span class="annot"><span class="annottext">di :: DatatypeInfo
</span><a href="#local-6989586621679083107"><span class="hs-identifier hs-var">di</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span class="hs-special">{</span><span class="annot"><span class="annottext">datatypeVariant :: DatatypeInfo -&gt; DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier hs-var">datatypeVariant</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="local-6989586621679083106"><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083106"><span class="hs-identifier hs-var">variant</span></a></span></span><span class="hs-special">}</span><span>
</span><span id="line-671"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679083138"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#isFamInstVariant"><span class="hs-identifier hs-var">isFamInstVariant</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083106"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-672"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-var">repair13618</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083107"><span class="hs-identifier hs-var">di</span></a></span><span>
</span><span id="line-673"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-674"></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083107"><span class="hs-identifier hs-var">di</span></a></span><span>
</span><span id="line-675"></span><span>
</span><span id="line-676"></span><span>    </span><span class="hs-comment">-- Given a data type's instance types and kind, compute its free variables.</span><span>
</span><span id="line-677"></span><span>    </span><span class="annot"><a href="#local-6989586621679083102"><span class="hs-identifier hs-type">datatypeFreeVars</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>
</span><span id="line-678"></span><span>    </span><span id="local-6989586621679083102"><span class="annot"><span class="annottext">datatypeFreeVars :: Cxt -&gt; Maybe Type -&gt; [TyVarBndr]
</span><a href="#local-6989586621679083102"><span class="hs-identifier hs-var hs-var">datatypeFreeVars</span></a></span></span><span> </span><span id="local-6989586621679083100"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679083100"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679083099"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083099"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-679"></span><span>      </span><span class="annot"><span class="annottext">Cxt -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span> </span><span class="annot"><span class="annottext">(Cxt -&gt; [TyVarBndr]) -&gt; Cxt -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083100"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; Cxt
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                                           </span><span class="annot"><span class="annottext">Maybe Type -&gt; Cxt
forall a. Maybe a -&gt; [a]
</span><span class="hs-identifier hs-var">maybeToList</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083099"><span class="hs-identifier hs-var">mbKind</span></a></span><span class="hs-cpp">
#else
</span><span>                                           </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- No kind variables</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-686"></span><span>    </span><span class="annot"><a href="#local-6989586621679083129"><span class="hs-identifier hs-type">normalizeDataD</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-687"></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-688"></span><span>    </span><span id="local-6989586621679083129"><span class="annot"><span class="annottext">normalizeDataD :: Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083129"><span class="hs-identifier hs-var hs-var">normalizeDataD</span></a></span></span><span> </span><span id="local-6989586621679083097"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083097"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083096"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083096"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679083095"><span class="annot"><span class="annottext">tyvars :: [TyVarBndr]
</span><a href="#local-6989586621679083095"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679083094"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083094"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083093"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083093"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083092"><span class="annot"><span class="annottext">variant :: DatatypeVariant
</span><a href="#local-6989586621679083092"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-689"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679083091"><span class="annot"><span class="annottext">params :: Cxt
</span><a href="#local-6989586621679083091"><span class="hs-identifier hs-var hs-var">params</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083095"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-690"></span><span>      </span><span class="annot"><span class="annottext">Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083089"><span class="hs-identifier hs-var">normalize'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083097"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083096"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Maybe Type -&gt; [TyVarBndr]
</span><a href="#local-6989586621679083102"><span class="hs-identifier hs-var">datatypeFreeVars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083091"><span class="hs-identifier hs-var">params</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083094"><span class="hs-identifier hs-var">mbKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-691"></span><span>                 </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083091"><span class="hs-identifier hs-var">params</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083094"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083093"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083092"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-692"></span><span>
</span><span id="line-693"></span><span>    </span><span class="annot"><a href="#local-6989586621679083115"><span class="hs-identifier hs-type">normalizeDataInstDPostTH2'15</span></a></span><span>
</span><span id="line-694"></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-695"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-696"></span><span>    </span><span id="local-6989586621679083115"><span class="annot"><span class="annottext">normalizeDataInstDPostTH2'15 :: String
-&gt; Cxt
-&gt; Maybe [TyVarBndr]
-&gt; Type
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083115"><span class="hs-identifier hs-var hs-var">normalizeDataInstDPostTH2'15</span></a></span></span><span> </span><span id="local-6989586621679083088"><span class="annot"><span class="annottext">what :: String
</span><a href="#local-6989586621679083088"><span class="hs-identifier hs-var">what</span></a></span></span><span> </span><span id="local-6989586621679083087"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083087"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083086"><span class="annot"><span class="annottext">mbTyvars :: Maybe [TyVarBndr]
</span><a href="#local-6989586621679083086"><span class="hs-identifier hs-var">mbTyvars</span></a></span></span><span> </span><span id="local-6989586621679083085"><span class="annot"><span class="annottext">nameInstTys :: Type
</span><a href="#local-6989586621679083085"><span class="hs-identifier hs-var">nameInstTys</span></a></span></span><span>
</span><span id="line-697"></span><span>                                 </span><span id="local-6989586621679083084"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083084"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083083"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083083"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083082"><span class="annot"><span class="annottext">variant :: DatatypeVariant
</span><a href="#local-6989586621679083082"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-698"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083085"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-699"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679083081"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083081"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679083080"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679083080"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-700"></span><span>          </span><span class="annot"><span class="annottext">Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083089"><span class="hs-identifier hs-var">normalize'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083087"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083081"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-701"></span><span>                     </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Maybe [TyVarBndr] -&gt; [TyVarBndr]
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Maybe Type -&gt; [TyVarBndr]
</span><a href="#local-6989586621679083102"><span class="hs-identifier hs-var">datatypeFreeVars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083080"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083084"><span class="hs-identifier hs-var">mbKind</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Maybe [TyVarBndr]
</span><a href="#local-6989586621679083086"><span class="hs-identifier hs-var">mbTyvars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-702"></span><span>                     </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083080"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083084"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083083"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083082"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-703"></span><span>        </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q DatatypeInfo) -&gt; String -&gt; Q DatatypeInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;Unexpected &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679083088"><span class="hs-identifier hs-var">what</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot; instance head: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; String
forall a. Ppr a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">pprint</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083085"><span class="hs-identifier hs-var">nameInstTys</span></a></span><span>
</span><span id="line-704"></span><span>
</span><span id="line-705"></span><span>    </span><span class="annot"><a href="#local-6989586621679083077"><span class="hs-identifier hs-type">normalizeDataInstDPreTH2'15</span></a></span><span>
</span><span id="line-706"></span><span>      </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-707"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-708"></span><span>    </span><span id="local-6989586621679083077"><span class="annot"><span class="annottext">normalizeDataInstDPreTH2'15 :: Cxt
-&gt; Name
-&gt; Cxt
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083077"><span class="hs-identifier hs-var hs-var">normalizeDataInstDPreTH2'15</span></a></span></span><span> </span><span id="local-6989586621679083076"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083076"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083075"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083075"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679083074"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679083074"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679083073"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083073"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083072"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083072"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083071"><span class="annot"><span class="annottext">variant :: DatatypeVariant
</span><a href="#local-6989586621679083071"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-709"></span><span>      </span><span class="annot"><span class="annottext">Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083089"><span class="hs-identifier hs-var">normalize'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083076"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083075"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Maybe Type -&gt; [TyVarBndr]
</span><a href="#local-6989586621679083102"><span class="hs-identifier hs-var">datatypeFreeVars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083074"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083073"><span class="hs-identifier hs-var">mbKind</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-710"></span><span>                 </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083074"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083073"><span class="hs-identifier hs-var">mbKind</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083072"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083071"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-711"></span><span>
</span><span id="line-712"></span><span>    </span><span class="hs-comment">-- The main worker of this function.</span><span>
</span><span id="line-713"></span><span>    </span><span class="annot"><a href="#local-6989586621679083089"><span class="hs-identifier hs-type">normalize'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-714"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-715"></span><span>    </span><span id="local-6989586621679083089"><span class="annot"><span class="annottext">normalize' :: Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Maybe Type
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083089"><span class="hs-identifier hs-var hs-var">normalize'</span></a></span></span><span> </span><span id="local-6989586621679083070"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083070"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083069"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083069"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679083068"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679083068"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679083067"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679083067"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679083066"><span class="annot"><span class="annottext">mbKind :: Maybe Type
</span><a href="#local-6989586621679083066"><span class="hs-identifier hs-var">mbKind</span></a></span></span><span> </span><span id="local-6989586621679083065"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083065"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083064"><span class="annot"><span class="annottext">variant :: DatatypeVariant
</span><a href="#local-6989586621679083064"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-716"></span><span>      </span><span id="local-6989586621679083063"><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083063"><span class="hs-identifier hs-var">extra_tvbs</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraKindBinders"><span class="hs-identifier hs-var">mkExtraKindBinders</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q [TyVarBndr]) -&gt; Type -&gt; Q [TyVarBndr]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type -&gt; Type
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span> </span><span class="annot"><span class="annottext">Maybe Type
</span><a href="#local-6989586621679083066"><span class="hs-identifier hs-var">mbKind</span></a></span><span>
</span><span id="line-717"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679083061"><span class="annot"><span class="annottext">tvbs' :: [TyVarBndr]
</span><a href="#local-6989586621679083061"><span class="hs-identifier hs-var hs-var">tvbs'</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083068"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083063"><span class="hs-identifier hs-var">extra_tvbs</span></a></span><span>
</span><span id="line-718"></span><span>          </span><span id="local-6989586621679083060"><span class="annot"><span class="annottext">instTys' :: Cxt
</span><a href="#local-6989586621679083060"><span class="hs-identifier hs-var hs-var">instTys'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083067"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; Cxt
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var">bndrParams</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083063"><span class="hs-identifier hs-var">extra_tvbs</span></a></span><span>
</span><span id="line-719"></span><span>      </span><span id="local-6989586621679083059"><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083059"><span class="hs-identifier hs-var">dec</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var">normalizeDec'</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679083138"><span class="hs-identifier hs-var">isReified</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083070"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083069"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083061"><span class="hs-identifier hs-var">tvbs'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083060"><span class="hs-identifier hs-var">instTys'</span></a></span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083065"><span class="hs-identifier hs-var">cons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083064"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-720"></span><span>      </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="#local-6989586621679083108"><span class="hs-identifier hs-var">repair13618'</span></a></span><span> </span><span class="annot"><span class="annottext">(DatatypeInfo -&gt; Q DatatypeInfo) -&gt; DatatypeInfo -&gt; Q DatatypeInfo
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveDIVarsStarKinds"><span class="hs-identifier hs-var">giveDIVarsStarKinds</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679083059"><span class="hs-identifier hs-var">dec</span></a></span><span>
</span><span id="line-721"></span><span>
</span><span id="line-722"></span><span class="hs-comment">-- | Create new kind variable binder names corresponding to the return kind of</span><span>
</span><span id="line-723"></span><span class="hs-comment">-- a data type. This is useful when you have a data type like:</span><span>
</span><span id="line-724"></span><span class="hs-comment">--</span><span>
</span><span id="line-725"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-726"></span><span class="hs-comment">-- data Foo :: forall k. k -&gt; Type -&gt; Type where ...</span><span>
</span><span id="line-727"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-728"></span><span class="hs-comment">--</span><span>
</span><span id="line-729"></span><span class="hs-comment">-- But you want to be able to refer to the type @Foo a b@.</span><span>
</span><span id="line-730"></span><span class="hs-comment">-- 'mkExtraKindBinders' will take the kind @forall k. k -&gt; Type -&gt; Type@,</span><span>
</span><span id="line-731"></span><span class="hs-comment">-- discover that is has two visible argument kinds, and return as a result</span><span>
</span><span id="line-732"></span><span class="hs-comment">-- two new kind variable binders @[a :: k, b :: Type]@, where @a@ and @b@</span><span>
</span><span id="line-733"></span><span class="hs-comment">-- are fresh type variable names.</span><span>
</span><span id="line-734"></span><span class="hs-comment">--</span><span>
</span><span id="line-735"></span><span class="hs-comment">-- This expands kind synonyms if necessary.</span><span>
</span><span id="line-736"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mkExtraKindBinders"><span class="hs-identifier hs-type">mkExtraKindBinders</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>
</span><span id="line-737"></span><span id="mkExtraKindBinders"><span class="annot"><span class="annottext">mkExtraKindBinders :: Type -&gt; Q [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#mkExtraKindBinders"><span class="hs-identifier hs-var hs-var">mkExtraKindBinders</span></a></span></span><span> </span><span id="local-6989586621679083056"><span class="annot"><span class="annottext">kind :: Type
</span><a href="#local-6989586621679083056"><span class="hs-identifier hs-var">kind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-738"></span><span>  </span><span id="local-6989586621679083055"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083055"><span class="hs-identifier hs-var">kind'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083056"><span class="hs-identifier hs-var">kind</span></a></span><span>
</span><span id="line-739"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083054"><span class="annot"><span class="annottext">args :: Cxt
</span><a href="#local-6989586621679083054"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-type">:|-</span></a></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryKind"><span class="hs-identifier hs-var">uncurryKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083055"><span class="hs-identifier hs-var">kind'</span></a></span><span>
</span><span id="line-740"></span><span>  </span><span id="local-6989586621679083052"><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679083052"><span class="hs-identifier hs-var">names</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Q Name -&gt; Q [Name]
forall (m :: * -&gt; *) a. Applicative m =&gt; Int -&gt; m a -&gt; m [a]
</span><span class="hs-identifier hs-var">replicateM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083054"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Q Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="annot"><span class="hs-string">&quot;x&quot;</span></span><span class="hs-special">)</span><span>
</span><span id="line-741"></span><span>  </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Q [TyVarBndr]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndr] -&gt; Q [TyVarBndr]) -&gt; [TyVarBndr] -&gt; Q [TyVarBndr]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type -&gt; TyVarBndr) -&gt; [Name] -&gt; Cxt -&gt; [TyVarBndr]
forall a b c. (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]
</span><span class="hs-identifier hs-var">zipWith</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679083052"><span class="hs-identifier hs-var">names</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083054"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-742"></span><span>
</span><span id="line-743"></span><span class="hs-comment">-- | Is a declaration for a @data instance@ or @newtype instance@?</span><span>
</span><span id="line-744"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isFamInstVariant"><span class="hs-identifier hs-type">isFamInstVariant</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-745"></span><span id="isFamInstVariant"><span class="annot"><span class="annottext">isFamInstVariant :: DatatypeVariant -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#isFamInstVariant"><span class="hs-identifier hs-var hs-var">isFamInstVariant</span></a></span></span><span> </span><span id="local-6989586621679083048"><span class="annot"><span class="annottext">dv :: DatatypeVariant
</span><a href="#local-6989586621679083048"><span class="hs-identifier hs-var">dv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-746"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083048"><span class="hs-identifier hs-var">dv</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-747"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Datatype"><span class="hs-identifier hs-type">Datatype</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-748"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Newtype"><span class="hs-identifier hs-type">Newtype</span></a></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-749"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DataInstance"><span class="hs-identifier hs-type">DataInstance</span></a></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-750"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NewtypeInstance"><span class="hs-identifier hs-type">NewtypeInstance</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-751"></span><span>
</span><span id="line-752"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-type">bndrParams</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-753"></span><span id="bndrParams"><span class="annot"><span class="annottext">bndrParams :: [TyVarBndr] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#bndrParams"><span class="hs-identifier hs-var hs-var">bndrParams</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Type) -&gt; [TyVarBndr] -&gt; Cxt
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">((TyVarBndr -&gt; Type) -&gt; [TyVarBndr] -&gt; Cxt)
-&gt; (TyVarBndr -&gt; Type) -&gt; [TyVarBndr] -&gt; Cxt
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679083047"><span class="annot"><span class="annottext">bndr :: TyVarBndr
</span><a href="#local-6989586621679083047"><span class="hs-identifier hs-var">bndr</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-754"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679083047"><span class="hs-identifier hs-var">bndr</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-755"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679083046"><span class="annot"><span class="annottext">t :: Name
</span><a href="#local-6989586621679083046"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679083045"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679083045"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083046"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083045"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-756"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span>  </span><span id="local-6989586621679083043"><span class="annot"><span class="annottext">t :: Name
</span><a href="#local-6989586621679083043"><span class="hs-identifier hs-var">t</span></a></span></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083043"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-757"></span><span>
</span><span id="line-758"></span><span class="hs-comment">-- | Extract the kind from a 'TyVarBndr'. Assumes 'PlainTV' has kind @*@.</span><span>
</span><span id="line-759"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-type">tvKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-760"></span><span id="tvKind"><span class="annot"><span class="annottext">tvKind :: TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var hs-var">tvKind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span>  </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span>
</span><span id="line-761"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679083042"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679083042"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083042"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-762"></span><span>
</span><span id="line-763"></span><span class="hs-comment">-- | Remove the outermost 'SigT'.</span><span>
</span><span id="line-764"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-type">stripSigT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-765"></span><span id="stripSigT"><span class="annot"><span class="annottext">stripSigT :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var hs-var">stripSigT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679083041"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679083041"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083041"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-766"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#stripSigT"><span class="hs-identifier hs-var">stripSigT</span></a></span><span> </span><span id="local-6989586621679083040"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679083040"><span class="hs-identifier hs-var">t</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679083040"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-767"></span><span>
</span><span id="line-768"></span><span>
</span><span id="line-769"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-type">normalizeDec'</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-770"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span>    </span><span class="hs-comment">{- ^ Is this a reified 'Dec'? -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-771"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>             </span><span class="hs-comment">{- ^ Datatype context         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-772"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>            </span><span class="hs-comment">{- ^ Type constructor         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-773"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">{- ^ Type parameters          -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-774"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>          </span><span class="hs-comment">{- ^ Argument types           -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-775"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span class="hs-special">]</span><span>           </span><span class="hs-comment">{- ^ Constructors             -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-776"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-comment">{- ^ Extra information        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-777"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-778"></span><span id="normalizeDec%27"><span class="annot"><span class="annottext">normalizeDec' :: Bool
-&gt; Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; [Con]
-&gt; DatatypeVariant
-&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#normalizeDec%27"><span class="hs-identifier hs-var hs-var">normalizeDec'</span></a></span></span><span> </span><span id="local-6989586621679083039"><span class="annot"><span class="annottext">reifiedDec :: Bool
</span><a href="#local-6989586621679083039"><span class="hs-identifier hs-var">reifiedDec</span></a></span></span><span> </span><span id="local-6989586621679083038"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083038"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083037"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679083037"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621679083036"><span class="annot"><span class="annottext">params :: [TyVarBndr]
</span><a href="#local-6989586621679083036"><span class="hs-identifier hs-var">params</span></a></span></span><span> </span><span id="local-6989586621679083035"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679083035"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679083034"><span class="annot"><span class="annottext">cons :: [Con]
</span><a href="#local-6989586621679083034"><span class="hs-identifier hs-var">cons</span></a></span></span><span> </span><span id="local-6989586621679083033"><span class="annot"><span class="annottext">variant :: DatatypeVariant
</span><a href="#local-6989586621679083033"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-779"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679083032"><span class="annot"><span class="annottext">[ConstructorInfo]
</span><a href="#local-6989586621679083032"><span class="hs-identifier hs-var">cons'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[[ConstructorInfo]] -&gt; [ConstructorInfo]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[ConstructorInfo]] -&gt; [ConstructorInfo])
-&gt; Q [[ConstructorInfo]] -&gt; Q [ConstructorInfo]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Con -&gt; Q [ConstructorInfo]) -&gt; [Con] -&gt; Q [[ConstructorInfo]]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var">normalizeConFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679083039"><span class="hs-identifier hs-var">reifiedDec</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083037"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083036"><span class="hs-identifier hs-var">params</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083035"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083033"><span class="hs-identifier hs-var">variant</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Con]
</span><a href="#local-6989586621679083034"><span class="hs-identifier hs-var">cons</span></a></span><span>
</span><span id="line-780"></span><span>     </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo :: Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; DatatypeVariant
-&gt; [ConstructorInfo]
-&gt; DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-781"></span><span>       </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">datatypeContext :: Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeContext"><span class="hs-identifier hs-var">datatypeContext</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083038"><span class="hs-identifier hs-var">context</span></a></span><span>
</span><span id="line-782"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeName :: Name
</span><a href="Language.Haskell.TH.Datatype.html#datatypeName"><span class="hs-identifier hs-var">datatypeName</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083037"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-783"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeVars :: [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var">datatypeVars</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083036"><span class="hs-identifier hs-var">params</span></a></span><span>
</span><span id="line-784"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeInstTypes :: Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var">datatypeInstTypes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083035"><span class="hs-identifier hs-var">instTys</span></a></span><span>
</span><span id="line-785"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeCons :: [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ConstructorInfo]
</span><a href="#local-6989586621679083032"><span class="hs-identifier hs-var">cons'</span></a></span><span>
</span><span id="line-786"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeVariant :: DatatypeVariant
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVariant"><span class="hs-identifier hs-var">datatypeVariant</span></a></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DatatypeVariant
</span><a href="#local-6989586621679083033"><span class="hs-identifier hs-var">variant</span></a></span><span>
</span><span id="line-787"></span><span>       </span><span class="hs-special">}</span><span>
</span><span id="line-788"></span><span>
</span><span id="line-789"></span><span class="hs-comment">-- | Normalize a 'Con' into a 'ConstructorInfo'. This requires knowledge of</span><span>
</span><span id="line-790"></span><span class="hs-comment">-- the type and parameters of the constructor, as well as whether the constructor</span><span>
</span><span id="line-791"></span><span class="hs-comment">-- is for a data family instance, as extracted from the outer</span><span>
</span><span id="line-792"></span><span class="hs-comment">-- 'Dec'.</span><span>
</span><span id="line-793"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier hs-type">normalizeCon</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-794"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>            </span><span class="hs-comment">{- ^ Type constructor  -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-795"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">{- ^ Type parameters   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-796"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>          </span><span class="hs-comment">{- ^ Argument types    -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-797"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-comment">{- ^ Extra information -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-798"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span>             </span><span class="hs-comment">{- ^ Constructor       -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-799"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-800"></span><span id="normalizeCon"><span class="annot"><span class="annottext">normalizeCon :: Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeCon"><span class="hs-identifier hs-var hs-var">normalizeCon</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var">normalizeConFor</span></a></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var">isn'tReified</span></a></span><span>
</span><span id="line-801"></span><span>
</span><span id="line-802"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-type">normalizeConFor</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-803"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span>    </span><span class="hs-comment">{- ^ Is this a reified 'Dec'? -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-804"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>            </span><span class="hs-comment">{- ^ Type constructor         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-805"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">{- ^ Type parameters          -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-806"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>          </span><span class="hs-comment">{- ^ Argument types           -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-807"></span><span>  </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeVariant"><span class="hs-identifier hs-type">DatatypeVariant</span></a></span><span> </span><span class="hs-comment">{- ^ Extra information        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-808"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span>             </span><span class="hs-comment">{- ^ Constructor              -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-809"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-810"></span><span id="normalizeConFor"><span class="annot"><span class="annottext">normalizeConFor :: Bool
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; DatatypeVariant
-&gt; Con
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeConFor"><span class="hs-identifier hs-var hs-var">normalizeConFor</span></a></span></span><span> </span><span id="local-6989586621679083027"><span class="annot"><span class="annottext">reifiedDec :: Bool
</span><a href="#local-6989586621679083027"><span class="hs-identifier hs-var">reifiedDec</span></a></span></span><span> </span><span id="local-6989586621679083026"><span class="annot"><span class="annottext">typename :: Name
</span><a href="#local-6989586621679083026"><span class="hs-identifier hs-var">typename</span></a></span></span><span> </span><span id="local-6989586621679083025"><span class="annot"><span class="annottext">params :: [TyVarBndr]
</span><a href="#local-6989586621679083025"><span class="hs-identifier hs-var">params</span></a></span></span><span> </span><span id="local-6989586621679083024"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679083024"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679083023"><span class="annot"><span class="annottext">variant :: DatatypeVariant
</span><a href="#local-6989586621679083023"><span class="hs-identifier hs-var">variant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-811"></span><span>  </span><span class="annot"><span class="annottext">([ConstructorInfo] -&gt; [ConstructorInfo])
-&gt; Q [ConstructorInfo] -&gt; Q [ConstructorInfo]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(ConstructorInfo -&gt; ConstructorInfo)
-&gt; [ConstructorInfo] -&gt; [ConstructorInfo]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveCIVarsStarKinds"><span class="hs-identifier hs-var">giveCIVarsStarKinds</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Q [ConstructorInfo] -&gt; Q [ConstructorInfo])
-&gt; (Con -&gt; Q [ConstructorInfo]) -&gt; Con -&gt; Q [ConstructorInfo]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083021"><span class="hs-identifier hs-var">dispatch</span></a></span><span>
</span><span id="line-812"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-813"></span><span>    </span><span class="hs-comment">-- A GADT constructor is declared infix when:</span><span>
</span><span id="line-814"></span><span>    </span><span class="hs-comment">--</span><span>
</span><span id="line-815"></span><span>    </span><span class="hs-comment">-- 1. Its name uses operator syntax (e.g., (:*:))</span><span>
</span><span id="line-816"></span><span>    </span><span class="hs-comment">-- 2. It has exactly two fields</span><span>
</span><span id="line-817"></span><span>    </span><span class="hs-comment">-- 3. It has a programmer-supplied fixity declaration</span><span>
</span><span id="line-818"></span><span>    </span><span class="annot"><a href="#local-6989586621679083020"><span class="hs-identifier hs-type">checkGadtFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a></span><span>
</span><span id="line-819"></span><span>    </span><span id="local-6989586621679083020"><span class="annot"><span class="annottext">checkGadtFixity :: Cxt -&gt; Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679083020"><span class="hs-identifier hs-var hs-var">checkGadtFixity</span></a></span></span><span> </span><span id="local-6989586621679083019"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679083019"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679083018"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679083018"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="hs-comment">-- Don't call reifyFixityCompat here! We need to be able to distinguish</span><span>
</span><span id="line-822"></span><span>      </span><span class="hs-comment">-- between a default fixity and an explicit @infixl 9@.</span><span>
</span><span id="line-823"></span><span>      </span><span id="local-6989586621679083017"><span class="annot"><span class="annottext">Maybe Fixity
</span><a href="#local-6989586621679083017"><span class="hs-identifier hs-var">mbFi</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Q (Maybe Fixity)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Fixity
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">Q (Maybe Fixity) -&gt; Q (Maybe Fixity) -&gt; Q (Maybe Fixity)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-operator hs-var">`recover`</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><span class="hs-identifier hs-var">reifyFixity</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083018"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-824"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679083014"><span class="annot"><span class="annottext">userSuppliedFixity :: Bool
</span><a href="#local-6989586621679083014"><span class="hs-identifier hs-var hs-var">userSuppliedFixity</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Bool
forall a. Maybe a -&gt; Bool
</span><span class="hs-identifier hs-var">isJust</span></span><span> </span><span class="annot"><span class="annottext">Maybe Fixity
</span><a href="#local-6989586621679083017"><span class="hs-identifier hs-var">mbFi</span></a></span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-comment">-- On old GHCs, there is a bug where infix GADT constructors will</span><span>
</span><span id="line-827"></span><span>      </span><span class="hs-comment">-- mistakenly be marked as (ForallC (NormalC ...)) instead of</span><span>
</span><span id="line-828"></span><span>      </span><span class="hs-comment">-- (ForallC (InfixC ...)). This is especially annoying since on these</span><span>
</span><span id="line-829"></span><span>      </span><span class="hs-comment">-- versions of GHC, Template Haskell doesn't grant the ability to query</span><span>
</span><span id="line-830"></span><span>      </span><span class="hs-comment">-- whether a constructor was given a user-supplied fixity declaration.</span><span>
</span><span id="line-831"></span><span>      </span><span class="hs-comment">-- Rather, you can only check the fixity that GHC ultimately decides on</span><span>
</span><span id="line-832"></span><span>      </span><span class="hs-comment">-- for a constructor, regardless of whether it was a default fixity or</span><span>
</span><span id="line-833"></span><span>      </span><span class="hs-comment">-- it was user-supplied.</span><span>
</span><span id="line-834"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-835"></span><span>      </span><span class="hs-comment">-- We can approximate whether a fixity was user-supplied by checking if</span><span>
</span><span id="line-836"></span><span>      </span><span class="hs-comment">-- it is not equal to defaultFixity (infixl 9). Unfortunately,</span><span>
</span><span id="line-837"></span><span>      </span><span class="hs-comment">-- there is no way to distinguish between a user-supplied fixity of</span><span>
</span><span id="line-838"></span><span>      </span><span class="hs-comment">-- infixl 9 and the fixity that GHC defaults to, so we cannot properly</span><span>
</span><span id="line-839"></span><span>      </span><span class="hs-comment">-- handle that case.</span><span>
</span><span id="line-840"></span><span>      </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-841"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">userSuppliedFixity</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">isJust</span><span> </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-operator">&amp;&amp;</span><span> </span><span class="hs-identifier">mbFi</span><span> </span><span class="hs-operator">/=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">defaultFixity</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><span class="annottext">ConstructorVariant -&gt; Q ConstructorVariant
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorVariant -&gt; Q ConstructorVariant)
-&gt; ConstructorVariant -&gt; Q ConstructorVariant
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">String -&gt; Bool
</span><a href="#local-6989586621679083012"><span class="hs-identifier hs-var">isInfixDataCon</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083018"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-844"></span><span>                  </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083019"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="hs-number">2</span></span><span>
</span><span id="line-845"></span><span>                  </span><span class="annot"><span class="annottext">Bool -&gt; Bool -&gt; Bool
</span><span class="hs-operator hs-var">&amp;&amp;</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679083014"><span class="hs-identifier hs-var">userSuppliedFixity</span></a></span><span>
</span><span id="line-846"></span><span>               </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span><span>
</span><span id="line-847"></span><span>               </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span><span>
</span><span id="line-848"></span><span>
</span><span id="line-849"></span><span>    </span><span class="hs-comment">-- Checks if a String names a valid Haskell infix data</span><span>
</span><span id="line-850"></span><span>    </span><span class="hs-comment">-- constructor (i.e., does it begin with a colon?).</span><span>
</span><span id="line-851"></span><span>    </span><span class="annot"><a href="#local-6989586621679083012"><span class="hs-identifier hs-type">isInfixDataCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-852"></span><span>    </span><span id="local-6989586621679083012"><span class="annot"><span class="annottext">isInfixDataCon :: String -&gt; Bool
</span><a href="#local-6989586621679083012"><span class="hs-identifier hs-var hs-var">isInfixDataCon</span></a></span></span><span> </span><span class="hs-special">(</span><span class="hs-char">':'</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-853"></span><span>    </span><span class="annot"><a href="#local-6989586621679083012"><span class="hs-identifier hs-var">isInfixDataCon</span></a></span><span> </span><span class="hs-identifier">_</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-854"></span><span>
</span><span id="line-855"></span><span>    </span><span class="annot"><a href="#local-6989586621679083021"><span class="hs-identifier hs-type">dispatch</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-856"></span><span>    </span><span id="local-6989586621679083021"><span class="annot"><span class="annottext">dispatch :: Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083021"><span class="hs-identifier hs-var hs-var">dispatch</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-857"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679083011"><span class="hs-identifier hs-type">defaultCase</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-858"></span><span>          </span><span id="local-6989586621679083011"><span class="annot"><span class="annottext">defaultCase :: Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083011"><span class="hs-identifier hs-var hs-var">defaultCase</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Bool -&gt; Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083010"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-859"></span><span>            </span><span class="hs-keyword">where</span><span>
</span><span id="line-860"></span><span>              </span><span class="annot"><a href="#local-6989586621679083010"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>
</span><span id="line-861"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>
</span><span id="line-862"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span> </span><span class="hs-comment">-- Is this a GADT? (see the documentation for</span><span>
</span><span id="line-863"></span><span>                         </span><span class="hs-comment">-- for checkGadtFixity)</span><span>
</span><span id="line-864"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Con</span></span><span>
</span><span id="line-865"></span><span>                 </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-866"></span><span>              </span><span id="local-6989586621679083010"><span class="annot"><span class="annottext">go :: [TyVarBndr] -&gt; Cxt -&gt; Bool -&gt; Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083010"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679083009"><span class="annot"><span class="annottext">tyvars :: [TyVarBndr]
</span><a href="#local-6989586621679083009"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679083008"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679083008"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679083007"><span class="annot"><span class="annottext">gadt :: Bool
</span><a href="#local-6989586621679083007"><span class="hs-identifier hs-var">gadt</span></a></span></span><span> </span><span id="local-6989586621679083006"><span class="annot"><span class="annottext">c :: Con
</span><a href="#local-6989586621679083006"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-867"></span><span>                </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679083006"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-868"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">NormalC</span></span><span> </span><span id="local-6989586621679083004"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679083004"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679083003"><span class="annot"><span class="annottext">xs :: [BangType]
</span><a href="#local-6989586621679083003"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-869"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679083002"><span class="annot"><span class="annottext">bangs :: [Bang]
</span><a href="#local-6989586621679083002"><span class="hs-identifier hs-var">bangs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679083001"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679083001"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BangType] -&gt; ([Bang], Cxt)
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">[BangType]
</span><a href="#local-6989586621679083003"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-870"></span><span>                        </span><span id="local-6989586621679082999"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679082999"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bang -&gt; FieldStrictness) -&gt; [Bang] -&gt; [FieldStrictness]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679083002"><span class="hs-identifier hs-var">bangs</span></a></span><span>
</span><span id="line-871"></span><span>                    </span><span id="local-6989586621679082997"><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="#local-6989586621679082997"><span class="hs-identifier hs-var">fi</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Bool
</span><a href="#local-6989586621679083007"><span class="hs-identifier hs-var">gadt</span></a></span><span>
</span><span id="line-872"></span><span>                             </span><span class="hs-keyword">then</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679083020"><span class="hs-identifier hs-var">checkGadtFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083001"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083004"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-873"></span><span>                             </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">ConstructorVariant -&gt; Q ConstructorVariant
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-var">NormalConstructor</span></a></span><span>
</span><span id="line-874"></span><span>                    </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; Q [ConstructorInfo]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083004"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083009"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083008"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083001"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679082999"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="#local-6989586621679082997"><span class="hs-identifier hs-var">fi</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-875"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">InfixC</span></span><span> </span><span id="local-6989586621679082995"><span class="annot"><span class="annottext">l :: BangType
</span><a href="#local-6989586621679082995"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679082994"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082994"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082993"><span class="annot"><span class="annottext">r :: BangType
</span><a href="#local-6989586621679082993"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-876"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082992"><span class="annot"><span class="annottext">bangs :: [Bang]
</span><a href="#local-6989586621679082992"><span class="hs-identifier hs-var">bangs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082991"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679082991"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BangType] -&gt; ([Bang], Cxt)
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">BangType
</span><a href="#local-6989586621679082995"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">BangType
</span><a href="#local-6989586621679082993"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-877"></span><span>                        </span><span id="local-6989586621679082990"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679082990"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bang -&gt; FieldStrictness) -&gt; [Bang] -&gt; [FieldStrictness]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679082992"><span class="hs-identifier hs-var">bangs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-878"></span><span>                    </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; Q [ConstructorInfo]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082994"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083009"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083008"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082991"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679082990"><span class="hs-identifier hs-var">stricts</span></a></span><span>
</span><span id="line-879"></span><span>                                            </span><span class="annot"><span class="annottext">ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-var">InfixConstructor</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-880"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">RecC</span></span><span> </span><span id="local-6989586621679082988"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082988"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082987"><span class="annot"><span class="annottext">xs :: [VarBangType]
</span><a href="#local-6989586621679082987"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-881"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082986"><span class="annot"><span class="annottext">fns :: [Name]
</span><a href="#local-6989586621679082986"><span class="hs-identifier hs-var hs-var">fns</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [Name]
forall a b. [(Name, a, b)] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var">takeFieldNames</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679082987"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-882"></span><span>                        </span><span id="local-6989586621679082984"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679082984"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [FieldStrictness]
forall a b. [(a, Bang, b)] -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var">takeFieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679082987"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-883"></span><span>                    </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; Q [ConstructorInfo]
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082988"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083009"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083008"><span class="hs-identifier hs-var">context</span></a></span><span>
</span><span id="line-884"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarBangType] -&gt; Cxt
forall a b. [(a, b, Type)] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var">takeFieldTypes</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679082987"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679082984"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082986"><span class="hs-identifier hs-var">fns</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-885"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">ForallC</span></span><span> </span><span id="local-6989586621679082980"><span class="annot"><span class="annottext">tyvars' :: [TyVarBndr]
</span><a href="#local-6989586621679082980"><span class="hs-identifier hs-var">tyvars'</span></a></span></span><span> </span><span id="local-6989586621679082979"><span class="annot"><span class="annottext">context' :: Cxt
</span><a href="#local-6989586621679082979"><span class="hs-identifier hs-var">context'</span></a></span></span><span> </span><span id="local-6989586621679082978"><span class="annot"><span class="annottext">c' :: Con
</span><a href="#local-6989586621679082978"><span class="hs-identifier hs-var">c'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-886"></span><span>                    </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Bool -&gt; Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083010"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082980"><span class="hs-identifier hs-var">tyvars'</span></a></span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083009"><span class="hs-identifier hs-var">tyvars</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082979"><span class="hs-identifier hs-var">context'</span></a></span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; Cxt
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083008"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span> </span><span class="annot"><span class="annottext">Con
</span><a href="#local-6989586621679082978"><span class="hs-identifier hs-var">c'</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">GadtC</span></span><span> </span><span id="local-6989586621679082976"><span class="annot"><span class="annottext">ns :: [Name]
</span><a href="#local-6989586621679082976"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679082975"><span class="annot"><span class="annottext">xs :: [BangType]
</span><a href="#local-6989586621679082975"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679082974"><span class="annot"><span class="annottext">innerType :: Type
</span><a href="#local-6989586621679082974"><span class="hs-identifier hs-var">innerType</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-889"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082973"><span class="annot"><span class="annottext">bangs :: [Bang]
</span><a href="#local-6989586621679082973"><span class="hs-identifier hs-var">bangs</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082972"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679082972"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[BangType] -&gt; ([Bang], Cxt)
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">[BangType]
</span><a href="#local-6989586621679082975"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-890"></span><span>                        </span><span id="local-6989586621679082971"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679082971"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Bang -&gt; FieldStrictness) -&gt; [Bang] -&gt; [FieldStrictness]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[Bang]
</span><a href="#local-6989586621679082973"><span class="hs-identifier hs-var">bangs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-891"></span><span>                    </span><span class="annot"><span class="annottext">[Name]
-&gt; Type
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679082970"><span class="hs-identifier hs-var">gadtCase</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082976"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082974"><span class="hs-identifier hs-var">innerType</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082972"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679082971"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679083020"><span class="hs-identifier hs-var">checkGadtFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082972"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-892"></span><span>                  </span><span class="annot"><span class="hs-identifier hs-type">RecGadtC</span></span><span> </span><span id="local-6989586621679082968"><span class="annot"><span class="annottext">ns :: [Name]
</span><a href="#local-6989586621679082968"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679082967"><span class="annot"><span class="annottext">xs :: [VarBangType]
</span><a href="#local-6989586621679082967"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span id="local-6989586621679082966"><span class="annot"><span class="annottext">innerType :: Type
</span><a href="#local-6989586621679082966"><span class="hs-identifier hs-var">innerType</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-893"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082965"><span class="annot"><span class="annottext">fns :: [Name]
</span><a href="#local-6989586621679082965"><span class="hs-identifier hs-var hs-var">fns</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [Name]
forall a b. [(Name, a, b)] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var">takeFieldNames</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679082967"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-894"></span><span>                        </span><span id="local-6989586621679082964"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679082964"><span class="hs-identifier hs-var hs-var">stricts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[VarBangType] -&gt; [FieldStrictness]
forall a b. [(a, Bang, b)] -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var">takeFieldStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679082967"><span class="hs-identifier hs-var">xs</span></a></span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-895"></span><span>                    </span><span class="annot"><span class="annottext">[Name]
-&gt; Type
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679082970"><span class="hs-identifier hs-var">gadtCase</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082968"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082966"><span class="hs-identifier hs-var">innerType</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[VarBangType] -&gt; Cxt
forall a b. [(a, b, Type)] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var">takeFieldTypes</span></a></span><span> </span><span class="annot"><span class="annottext">[VarBangType]
</span><a href="#local-6989586621679082967"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679082964"><span class="hs-identifier hs-var">stricts</span></a></span><span>
</span><span id="line-896"></span><span>                             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Q ConstructorVariant -&gt; Name -&gt; Q ConstructorVariant
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">(Q ConstructorVariant -&gt; Name -&gt; Q ConstructorVariant)
-&gt; Q ConstructorVariant -&gt; Name -&gt; Q ConstructorVariant
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ConstructorVariant -&gt; Q ConstructorVariant
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">(ConstructorVariant -&gt; Q ConstructorVariant)
-&gt; ConstructorVariant -&gt; Q ConstructorVariant
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-var">RecordConstructor</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082965"><span class="hs-identifier hs-var">fns</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-897"></span><span>                </span><span class="hs-keyword">where</span><span>
</span><span id="line-898"></span><span>                  </span><span id="local-6989586621679082970"><span class="annot"><span class="annottext">gadtCase :: [Name]
-&gt; Type
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679082970"><span class="hs-identifier hs-var hs-var">gadtCase</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; [Name]
-&gt; Type
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-var">normalizeGadtC</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679083026"><span class="hs-identifier hs-var">typename</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083025"><span class="hs-identifier hs-var">params</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083024"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679083009"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679083008"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,8,0) &amp;&amp; (!MIN_VERSION_template_haskell(2,10,0))
</span><span>          </span><span class="hs-identifier">dataFamCompatCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Con</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">ConstructorInfo</span><span class="hs-special">]</span><span>
</span><span id="line-902"></span><span>          </span><span class="hs-identifier">dataFamCompatCase</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-903"></span><span>            </span><span class="hs-keyword">where</span><span>
</span><span id="line-904"></span><span>              </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-905"></span><span>                </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-906"></span><span>                  </span><span class="hs-identifier">NormalC</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-907"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">fst</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-908"></span><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">NormalConstructor</span><span>
</span><span id="line-909"></span><span>                  </span><span class="hs-identifier">InfixC</span><span> </span><span class="hs-identifier">l</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">r</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-910"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-operator">.</span><span> </span><span class="hs-identifier">fst</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">l</span><span class="hs-special">,</span><span class="hs-identifier">r</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-911"></span><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">InfixConstructor</span><span>
</span><span id="line-912"></span><span>                  </span><span class="hs-identifier">RecC</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-913"></span><span>                    </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-914"></span><span>                    </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span>
</span><span id="line-915"></span><span>                                 </span><span class="hs-special">(</span><span class="hs-identifier">RecordConstructor</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">takeFieldNames</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-916"></span><span>                  </span><span class="hs-identifier">ForallC</span><span> </span><span class="hs-identifier">tyvars'</span><span> </span><span class="hs-identifier">context'</span><span> </span><span class="hs-identifier">c'</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-917"></span><span>                    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">tyvars'</span><span class="hs-operator">++</span><span class="hs-identifier">tyvars</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">c'</span><span>
</span><span id="line-918"></span><span>
</span><span id="line-919"></span><span>          </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Name</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FieldStrictness</span><span class="hs-special">]</span><span>
</span><span id="line-920"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ConstructorVariant</span><span>
</span><span id="line-921"></span><span>                       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Q</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">ConstructorInfo</span><span class="hs-special">]</span><span>
</span><span id="line-922"></span><span>          </span><span class="hs-identifier">dataFamCase'</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-identifier">variant</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-923"></span><span>            </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-924"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-925"></span><span>              </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ty</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-926"></span><span>                </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">tyvars</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">context</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">argTys</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">returnTy</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">uncurryType</span><span> </span><span class="hs-identifier">ty</span><span>
</span><span id="line-927"></span><span>                </span><span class="hs-identifier">returnTy'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">returnTy</span><span>
</span><span id="line-928"></span><span>                </span><span class="hs-comment">-- Notice that we've ignored the TyVarBndrs, Cxt and argument</span><span>
</span><span id="line-929"></span><span>                </span><span class="hs-comment">-- Types from the Con argument above, as they might be scoped</span><span>
</span><span id="line-930"></span><span>                </span><span class="hs-comment">-- over eta-reduced variables. Instead of trying to figure out</span><span>
</span><span id="line-931"></span><span>                </span><span class="hs-comment">-- what the eta-reduced variables should be substituted with</span><span>
</span><span id="line-932"></span><span>                </span><span class="hs-comment">-- post facto, we opt for the simpler approach of using the</span><span>
</span><span id="line-933"></span><span>                </span><span class="hs-comment">-- context and argument types from the reified constructor</span><span>
</span><span id="line-934"></span><span>                </span><span class="hs-comment">-- Info, which will at least be correctly scoped. This will</span><span>
</span><span id="line-935"></span><span>                </span><span class="hs-comment">-- make the task of substituting those types with the variables</span><span>
</span><span id="line-936"></span><span>                </span><span class="hs-comment">-- we put in place of the eta-reduced variables</span><span>
</span><span id="line-937"></span><span>                </span><span class="hs-comment">-- (in normalizeDec) much easier.</span><span>
</span><span id="line-938"></span><span>                </span><span class="hs-identifier">normalizeGadtC</span><span> </span><span class="hs-identifier">typename</span><span> </span><span class="hs-identifier">params</span><span> </span><span class="hs-identifier">instTys</span><span> </span><span class="hs-identifier">tyvars</span><span> </span><span class="hs-identifier">context</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">n</span><span class="hs-special">]</span><span>
</span><span id="line-939"></span><span>                               </span><span class="hs-identifier">returnTy'</span><span> </span><span class="hs-identifier">argTys</span><span> </span><span class="hs-identifier">stricts</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">const</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">variant</span><span class="hs-special">)</span><span>
</span><span id="line-940"></span><span>              </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">fail</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">unlines</span><span>
</span><span id="line-941"></span><span>                     </span><span class="hs-special">[</span><span> </span><span class="hs-string">&quot;normalizeCon: Cannot reify constructor &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">nameBase</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-942"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;You are likely calling normalizeDec on GHC 7.6 or 7.8 on a data family&quot;</span><span>
</span><span id="line-943"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;whose type variables have been eta-reduced due to GHC Trac #9692.&quot;</span><span>
</span><span id="line-944"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;Unfortunately, without being able to reify the constructor's type,&quot;</span><span>
</span><span id="line-945"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;there is no way to recover the eta-reduced type variables in general.&quot;</span><span>
</span><span id="line-946"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-string">&quot;A recommended workaround is to use reifyDatatype instead.&quot;</span><span>
</span><span id="line-947"></span><span>                     </span><span class="hs-special">]</span><span>
</span><span id="line-948"></span><span>
</span><span id="line-949"></span><span>          </span><span class="hs-comment">-- A very ad hoc way of determining if we need to perform some extra passes</span><span>
</span><span id="line-950"></span><span>          </span><span class="hs-comment">-- to repair an eta-reduction bug for data family instances that only occurs</span><span>
</span><span id="line-951"></span><span>          </span><span class="hs-comment">-- with GHC 7.6 and 7.8. We want to avoid doing these passes if at all possible,</span><span>
</span><span id="line-952"></span><span>          </span><span class="hs-comment">-- since they require reifying extra information, and reifying during</span><span>
</span><span id="line-953"></span><span>          </span><span class="hs-comment">-- normalization can be problematic for locally declared Template Haskell</span><span>
</span><span id="line-954"></span><span>          </span><span class="hs-comment">-- splices (see ##22).</span><span>
</span><span id="line-955"></span><span>          </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">Type</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Bool</span><span>
</span><span id="line-956"></span><span>          </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-957"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-958"></span><span>              </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">False</span><span>
</span><span id="line-959"></span><span>              </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">initTs</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">lastT</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-960"></span><span>                </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">lastT</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-961"></span><span>                  </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">False</span><span>
</span><span id="line-962"></span><span>                  </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">n</span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">not</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">n</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">initTs</span><span class="hs-special">)</span><span>
</span><span id="line-963"></span><span>
</span><span id="line-964"></span><span>          </span><span class="hs-comment">-- If the list is empty returns 'Nothing', otherwise returns the</span><span>
</span><span id="line-965"></span><span>          </span><span class="hs-comment">-- 'init' and the 'last'.</span><span>
</span><span id="line-966"></span><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">a</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">NonEmptySnoc</span><span> </span><span class="hs-identifier">a</span><span class="hs-special">)</span><span>
</span><span id="line-967"></span><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-968"></span><span>          </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-glyph">:</span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">unsnoc</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-969"></span><span>            </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">a</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-glyph">:</span><span class="hs-identifier">a</span><span class="hs-special">)</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">b</span><span class="hs-special">)</span><span>
</span><span id="line-970"></span><span>            </span><span class="hs-identifier">Nothing</span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span>    </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span>
</span><span id="line-971"></span><span>
</span><span id="line-972"></span><span>          </span><span class="hs-comment">-- If a Type is a VarT, find Just its Name. Otherwise, return Nothing.</span><span>
</span><span id="line-973"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-identifier">Name</span><span>
</span><span id="line-974"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">SigT</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">t</span><span>
</span><span id="line-975"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">VarT</span><span> </span><span class="hs-identifier">n</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-976"></span><span>          </span><span class="hs-identifier">varTName</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span>
</span><span id="line-977"></span><span>
</span><span id="line-978"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">variant</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-979"></span><span>           </span><span class="hs-comment">-- On GHC 7.6 and 7.8, there's quite a bit of post-processing that</span><span>
</span><span id="line-980"></span><span>           </span><span class="hs-comment">-- needs to be performed to work around an old bug that eta-reduces the</span><span>
</span><span id="line-981"></span><span>           </span><span class="hs-comment">-- type patterns of data families (but only for reified data family instances).</span><span>
</span><span id="line-982"></span><span>           </span><span class="hs-identifier">DataInstance</span><span>
</span><span id="line-983"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">reifiedDec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">instTys</span><span>
</span><span id="line-984"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamCompatCase</span><span>
</span><span id="line-985"></span><span>           </span><span class="hs-identifier">NewtypeInstance</span><span>
</span><span id="line-986"></span><span>             </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">reifiedDec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">mightHaveBeenEtaReduced</span><span> </span><span class="hs-identifier">instTys</span><span>
</span><span id="line-987"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">dataFamCompatCase</span><span>
</span><span id="line-988"></span><span>           </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">defaultCase</span><span class="hs-cpp">
#else
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Con -&gt; Q [ConstructorInfo]
</span><a href="#local-6989586621679083011"><span class="hs-identifier hs-var">defaultCase</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-type">normalizeStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span>
</span><span id="line-995"></span><span id="normalizeStrictness"><span class="annot"><span class="annottext">normalizeStrictness :: Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var hs-var">normalizeStrictness</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span> </span><span id="local-6989586621679082960"><span class="annot"><span class="annottext">upk :: SourceUnpackedness
</span><a href="#local-6989586621679082960"><span class="hs-identifier hs-var">upk</span></a></span></span><span> </span><span id="local-6989586621679082959"><span class="annot"><span class="annottext">str :: SourceStrictness
</span><a href="#local-6989586621679082959"><span class="hs-identifier hs-var">str</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-996"></span><span>  </span><span class="annot"><span class="annottext">Unpackedness -&gt; Strictness -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-var">FieldStrictness</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceUnpackedness -&gt; Unpackedness
</span><a href="#local-6989586621679082958"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceUnpackedness
</span><a href="#local-6989586621679082960"><span class="hs-identifier hs-var">upk</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-997"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">SourceStrictness -&gt; Strictness
</span><a href="#local-6989586621679082957"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">SourceStrictness
</span><a href="#local-6989586621679082959"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-998"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-999"></span><span>    </span><span class="annot"><a href="#local-6989586621679082958"><span class="hs-identifier hs-type">normalizeSourceUnpackedness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceUnpackedness</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Unpackedness"><span class="hs-identifier hs-type">Unpackedness</span></a></span><span>
</span><span id="line-1000"></span><span>    </span><span id="local-6989586621679082958"><span class="annot"><span class="annottext">normalizeSourceUnpackedness :: SourceUnpackedness -&gt; Unpackedness
</span><a href="#local-6989586621679082958"><span class="hs-identifier hs-var hs-var">normalizeSourceUnpackedness</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoSourceUnpackedness</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedUnpackedness"><span class="hs-identifier hs-var">UnspecifiedUnpackedness</span></a></span><span>
</span><span id="line-1001"></span><span>    </span><span class="annot"><a href="#local-6989586621679082958"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceNoUnpack</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#NoUnpack"><span class="hs-identifier hs-var">NoUnpack</span></a></span><span>
</span><span id="line-1002"></span><span>    </span><span class="annot"><a href="#local-6989586621679082958"><span class="hs-identifier hs-var">normalizeSourceUnpackedness</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceUnpack</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Unpackedness
</span><a href="Language.Haskell.TH.Datatype.html#Unpack"><span class="hs-identifier hs-var">Unpack</span></a></span><span>
</span><span id="line-1003"></span><span>
</span><span id="line-1004"></span><span>    </span><span class="annot"><a href="#local-6989586621679082957"><span class="hs-identifier hs-type">normalizeSourceStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceStrictness</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#Strictness"><span class="hs-identifier hs-type">Strictness</span></a></span><span>
</span><span id="line-1005"></span><span>    </span><span id="local-6989586621679082957"><span class="annot"><span class="annottext">normalizeSourceStrictness :: SourceStrictness -&gt; Strictness
</span><a href="#local-6989586621679082957"><span class="hs-identifier hs-var hs-var">normalizeSourceStrictness</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">NoSourceStrictness</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#UnspecifiedStrictness"><span class="hs-identifier hs-var">UnspecifiedStrictness</span></a></span><span>
</span><span id="line-1006"></span><span>    </span><span class="annot"><a href="#local-6989586621679082957"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceLazy</span></span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Lazy"><span class="hs-identifier hs-var">Lazy</span></a></span><span>
</span><span id="line-1007"></span><span>    </span><span class="annot"><a href="#local-6989586621679082957"><span class="hs-identifier hs-var">normalizeSourceStrictness</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">SourceStrict</span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Strictness
</span><a href="Language.Haskell.TH.Datatype.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Strict</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">FieldStrictness</span><span>
</span><span id="line-1010"></span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">IsStrict</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">isStrictAnnot</span><span>
</span><span id="line-1011"></span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">NotStrict</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">notStrictAnnot</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,7,0)
</span><span class="hs-identifier">normalizeStrictness</span><span> </span><span class="hs-identifier">Unpacked</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">unpackedAnnot</span><span class="hs-cpp">
# endif
</span><span class="hs-cpp">#endif
</span><span>
</span><span id="line-1017"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-type">normalizeGadtC</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1018"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>              </span><span class="hs-comment">{- ^ Type constructor             -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1019"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>       </span><span class="hs-comment">{- ^ Type parameters              -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1020"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="hs-comment">{- ^ Argument types               -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1021"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>       </span><span class="hs-comment">{- ^ Constructor parameters       -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1022"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span>               </span><span class="hs-comment">{- ^ Constructor context          -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1023"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>            </span><span class="hs-comment">{- ^ Constructor names            -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1024"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>              </span><span class="hs-comment">{- ^ Declared type of constructor -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1025"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>            </span><span class="hs-comment">{- ^ Constructor field types      -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1026"></span><span>  </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ Constructor field strictness -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1027"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorVariant"><span class="hs-identifier hs-type">ConstructorVariant</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1028"></span><span>                    </span><span class="hs-comment">{- ^ Determine a constructor variant
                         from its 'Name' -}</span><span>              </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1030"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1031"></span><span id="normalizeGadtC"><span class="annot"><span class="annottext">normalizeGadtC :: Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; [Name]
-&gt; Type
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; (Name -&gt; Q ConstructorVariant)
-&gt; Q [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#normalizeGadtC"><span class="hs-identifier hs-var hs-var">normalizeGadtC</span></a></span></span><span> </span><span id="local-6989586621679082950"><span class="annot"><span class="annottext">typename :: Name
</span><a href="#local-6989586621679082950"><span class="hs-identifier hs-var">typename</span></a></span></span><span> </span><span id="local-6989586621679082949"><span class="annot"><span class="annottext">params :: [TyVarBndr]
</span><a href="#local-6989586621679082949"><span class="hs-identifier hs-var">params</span></a></span></span><span> </span><span id="local-6989586621679082948"><span class="annot"><span class="annottext">instTys :: Cxt
</span><a href="#local-6989586621679082948"><span class="hs-identifier hs-var">instTys</span></a></span></span><span> </span><span id="local-6989586621679082947"><span class="annot"><span class="annottext">tyvars :: [TyVarBndr]
</span><a href="#local-6989586621679082947"><span class="hs-identifier hs-var">tyvars</span></a></span></span><span> </span><span id="local-6989586621679082946"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679082946"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679082945"><span class="annot"><span class="annottext">names :: [Name]
</span><a href="#local-6989586621679082945"><span class="hs-identifier hs-var">names</span></a></span></span><span> </span><span id="local-6989586621679082944"><span class="annot"><span class="annottext">innerType :: Type
</span><a href="#local-6989586621679082944"><span class="hs-identifier hs-var">innerType</span></a></span></span><span>
</span><span id="line-1032"></span><span>               </span><span id="local-6989586621679082943"><span class="annot"><span class="annottext">fields :: Cxt
</span><a href="#local-6989586621679082943"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span id="local-6989586621679082942"><span class="annot"><span class="annottext">stricts :: [FieldStrictness]
</span><a href="#local-6989586621679082942"><span class="hs-identifier hs-var">stricts</span></a></span></span><span> </span><span id="local-6989586621679082941"><span class="annot"><span class="annottext">getVariant :: Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679082941"><span class="hs-identifier hs-var">getVariant</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1033"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-comment">-- It's possible that the constructor has implicitly quantified type</span><span>
</span><span id="line-1034"></span><span>     </span><span class="hs-comment">-- variables, such as in the following example (from #58):</span><span>
</span><span id="line-1035"></span><span>     </span><span class="hs-comment">--</span><span>
</span><span id="line-1036"></span><span>     </span><span class="hs-comment">--   [d| data Foo where</span><span>
</span><span id="line-1037"></span><span>     </span><span class="hs-comment">--         MkFoo :: a -&gt; Foo |]</span><span>
</span><span id="line-1038"></span><span>     </span><span class="hs-comment">--</span><span>
</span><span id="line-1039"></span><span>     </span><span class="hs-comment">-- normalizeGadtC assumes that all type variables have binders, however,</span><span>
</span><span id="line-1040"></span><span>     </span><span class="hs-comment">-- so we use freeVariablesWellScoped to obtain the implicit type</span><span>
</span><span id="line-1041"></span><span>     </span><span class="hs-comment">-- variables' binders before proceeding.</span><span>
</span><span id="line-1042"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082940"><span class="annot"><span class="annottext">implicitTyvars :: [TyVarBndr]
</span><a href="#local-6989586621679082940"><span class="hs-identifier hs-var hs-var">implicitTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span>
</span><span id="line-1043"></span><span>                          </span><span class="hs-special">[</span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Cxt -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#curryType"><span class="hs-identifier hs-var">curryType</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082947"><span class="hs-identifier hs-var">tyvars</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082946"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082943"><span class="hs-identifier hs-var">fields</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082944"><span class="hs-identifier hs-var">innerType</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1044"></span><span>         </span><span id="local-6989586621679082938"><span class="annot"><span class="annottext">allTyvars :: [TyVarBndr]
</span><a href="#local-6989586621679082938"><span class="hs-identifier hs-var hs-var">allTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082940"><span class="hs-identifier hs-var">implicitTyvars</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082947"><span class="hs-identifier hs-var">tyvars</span></a></span><span>
</span><span id="line-1045"></span><span>
</span><span id="line-1046"></span><span>     </span><span class="hs-comment">-- Due to GHC Trac #13885, it's possible that the type variables bound by</span><span>
</span><span id="line-1047"></span><span>     </span><span class="hs-comment">-- a GADT constructor will shadow those that are bound by the data type.</span><span>
</span><span id="line-1048"></span><span>     </span><span class="hs-comment">-- This function assumes this isn't the case in certain parts (e.g., when</span><span>
</span><span id="line-1049"></span><span>     </span><span class="hs-comment">-- mergeArguments is invoked), so we do an alpha-renaming of the</span><span>
</span><span id="line-1050"></span><span>     </span><span class="hs-comment">-- constructor-bound variables before proceeding. See #36 for an example</span><span>
</span><span id="line-1051"></span><span>     </span><span class="hs-comment">-- of what can go wrong if this isn't done.</span><span>
</span><span id="line-1052"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082937"><span class="annot"><span class="annottext">conBoundNames :: [Name]
</span><a href="#local-6989586621679082937"><span class="hs-identifier hs-var hs-var">conBoundNames</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1053"></span><span>           </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; [Name]) -&gt; [TyVarBndr] -&gt; [Name]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679082935"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082935"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082935"><span class="hs-identifier hs-var">tvb</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082935"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082938"><span class="hs-identifier hs-var">allTyvars</span></a></span><span>
</span><span id="line-1054"></span><span>     </span><span id="local-6989586621679082933"><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082933"><span class="hs-identifier hs-var">conSubst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Map Name (Q Name) -&gt; Q (Map Name Name)
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><span class="hs-identifier hs-var">T.sequence</span></span><span> </span><span class="annot"><span class="annottext">(Map Name (Q Name) -&gt; Q (Map Name Name))
-&gt; Map Name (Q Name) -&gt; Q (Map Name Name)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[(Name, Q Name)] -&gt; Map Name (Q Name)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082930"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082930"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1055"></span><span>                                           </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679082930"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082930"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082937"><span class="hs-identifier hs-var">conBoundNames</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1056"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082929"><span class="annot"><span class="annottext">conSubst' :: Map Name Type
</span><a href="#local-6989586621679082929"><span class="hs-identifier hs-var hs-var">conSubst'</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Map Name Name -&gt; Map Name Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082933"><span class="hs-identifier hs-var">conSubst</span></a></span><span>
</span><span id="line-1057"></span><span>         </span><span id="local-6989586621679082928"><span class="annot"><span class="annottext">renamedTyvars :: [TyVarBndr]
</span><a href="#local-6989586621679082928"><span class="hs-identifier hs-var hs-var">renamedTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1058"></span><span>           </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; TyVarBndr) -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679082927"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082927"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082927"><span class="hs-identifier hs-var">tvb</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1059"></span><span>                          </span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span> </span><span id="local-6989586621679082926"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082926"><span class="hs-identifier hs-var">n</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">PlainTV</span></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082933"><span class="hs-identifier hs-var">conSubst</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; Name -&gt; Name
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><span class="hs-operator hs-var">Map.!</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082926"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1060"></span><span>                          </span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082924"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082924"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082923"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082923"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082933"><span class="hs-identifier hs-var">conSubst</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; Name -&gt; Name
forall k a. Ord k =&gt; Map k a -&gt; k -&gt; a
</span><span class="hs-operator hs-var">Map.!</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082924"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1061"></span><span>                                                   </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082929"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082923"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082938"><span class="hs-identifier hs-var">allTyvars</span></a></span><span>
</span><span id="line-1062"></span><span>         </span><span id="local-6989586621679082921"><span class="annot"><span class="annottext">renamedContext :: Cxt
</span><a href="#local-6989586621679082921"><span class="hs-identifier hs-var hs-var">renamedContext</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082929"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082946"><span class="hs-identifier hs-var">context</span></a></span><span>
</span><span id="line-1063"></span><span>         </span><span id="local-6989586621679082920"><span class="annot"><span class="annottext">renamedInnerType :: Type
</span><a href="#local-6989586621679082920"><span class="hs-identifier hs-var hs-var">renamedInnerType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082929"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082944"><span class="hs-identifier hs-var">innerType</span></a></span><span>
</span><span id="line-1064"></span><span>         </span><span id="local-6989586621679082919"><span class="annot"><span class="annottext">renamedFields :: Cxt
</span><a href="#local-6989586621679082919"><span class="hs-identifier hs-var hs-var">renamedFields</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082929"><span class="hs-identifier hs-var">conSubst'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082943"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-1065"></span><span>
</span><span id="line-1066"></span><span>     </span><span id="local-6989586621679082918"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082918"><span class="hs-identifier hs-var">innerType'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082920"><span class="hs-identifier hs-var">renamedInnerType</span></a></span><span>
</span><span id="line-1067"></span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082918"><span class="hs-identifier hs-var">innerType'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1068"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679082917"><span class="annot"><span class="annottext">innerTyCon :: Name
</span><a href="#local-6989586621679082917"><span class="hs-identifier hs-var">innerTyCon</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679082916"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679082916"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082950"><span class="hs-identifier hs-var">typename</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082917"><span class="hs-identifier hs-var">innerTyCon</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1069"></span><span>
</span><span id="line-1070"></span><span>         </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082915"><span class="annot"><span class="annottext">substName :: Map Name Name
</span><a href="#local-6989586621679082915"><span class="hs-identifier hs-var">substName</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082914"><span class="annot"><span class="annottext">context1 :: Cxt
</span><a href="#local-6989586621679082914"><span class="hs-identifier hs-var">context1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1071"></span><span>               </span><span class="annot"><span class="annottext">Map Name Type
-&gt; Map Name Type -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-var">closeOverKinds</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var">kindsOfFVsOfTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082928"><span class="hs-identifier hs-var">renamedTyvars</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1072"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var">kindsOfFVsOfTvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082949"><span class="hs-identifier hs-var">params</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1073"></span><span>                              </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082948"><span class="hs-identifier hs-var">instTys</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082916"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1074"></span><span>             </span><span id="local-6989586621679082910"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679082910"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Map Name Name -&gt; Map Name Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082915"><span class="hs-identifier hs-var">substName</span></a></span><span>
</span><span id="line-1075"></span><span>             </span><span id="local-6989586621679082909"><span class="annot"><span class="annottext">exTyvars :: [TyVarBndr]
</span><a href="#local-6989586621679082909"><span class="hs-identifier hs-var hs-var">exTyvars</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082908"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679082908"><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082908"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082928"><span class="hs-identifier hs-var">renamedTyvars</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.notMember</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082908"><span class="hs-identifier hs-var">tv</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082910"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-1076"></span><span>
</span><span id="line-1077"></span><span>             </span><span id="local-6989586621679082906"><span class="annot"><span class="annottext">exTyvars' :: [TyVarBndr]
</span><a href="#local-6989586621679082906"><span class="hs-identifier hs-var hs-var">exTyvars'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [TyVarBndr] -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-var">substTyVarBndrs</span></a></span><span>   </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082910"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082909"><span class="hs-identifier hs-var">exTyvars</span></a></span><span>
</span><span id="line-1078"></span><span>             </span><span id="local-6989586621679082904"><span class="annot"><span class="annottext">context2 :: Cxt
</span><a href="#local-6989586621679082904"><span class="hs-identifier hs-var hs-var">context2</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082910"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082914"><span class="hs-identifier hs-var">context1</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; Cxt
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082921"><span class="hs-identifier hs-var">renamedContext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1079"></span><span>             </span><span id="local-6989586621679082903"><span class="annot"><span class="annottext">fields' :: Cxt
</span><a href="#local-6989586621679082903"><span class="hs-identifier hs-var hs-var">fields'</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082910"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082919"><span class="hs-identifier hs-var">renamedFields</span></a></span><span>
</span><span id="line-1080"></span><span>         </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[Q ConstructorInfo] -&gt; Q [ConstructorInfo]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">Name
-&gt; [TyVarBndr]
-&gt; Cxt
-&gt; Cxt
-&gt; [FieldStrictness]
-&gt; ConstructorVariant
-&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-var">ConstructorInfo</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082902"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082906"><span class="hs-identifier hs-var">exTyvars'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082904"><span class="hs-identifier hs-var">context2</span></a></span><span>
</span><span id="line-1081"></span><span>                                       </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082903"><span class="hs-identifier hs-var">fields'</span></a></span><span> </span><span class="annot"><span class="annottext">[FieldStrictness]
</span><a href="#local-6989586621679082942"><span class="hs-identifier hs-var">stricts</span></a></span><span> </span><span class="annot"><span class="annottext">(ConstructorVariant -&gt; ConstructorInfo)
-&gt; Q ConstructorVariant -&gt; Q ConstructorInfo
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Q ConstructorVariant
</span><a href="#local-6989586621679082901"><span class="hs-identifier hs-var">variantQ</span></a></span><span>
</span><span id="line-1082"></span><span>                     </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679082902"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082902"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082945"><span class="hs-identifier hs-var">names</span></a></span><span>
</span><span id="line-1083"></span><span>                     </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082901"><span class="annot"><span class="annottext">variantQ :: Q ConstructorVariant
</span><a href="#local-6989586621679082901"><span class="hs-identifier hs-var hs-var">variantQ</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q ConstructorVariant
</span><a href="#local-6989586621679082941"><span class="hs-identifier hs-var">getVariant</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082902"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1084"></span><span>                     </span><span class="hs-special">]</span><span>
</span><span id="line-1085"></span><span>
</span><span id="line-1086"></span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q [ConstructorInfo]
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="hs-string">&quot;normalizeGadtC: Expected type constructor application&quot;</span></span><span>
</span><span id="line-1087"></span><span>
</span><span id="line-1088"></span><span class="hs-comment">{-
Extend a type variable renaming subtitution and a list of equality
predicates by looking into kind information as much as possible.

Why is this necessary? Consider the following example:

  data (a1 :: k1) :~: (b1 :: k1) where
    Refl :: forall k2 (a2 :: k2). a2 :~: a2

After an initial call to mergeArguments, we will have the following
substitution and context:

* Substitution: [a2 :-&gt; a1]
* Context: (a2 ~ b1)

We shouldn't stop there, however! We determine the existentially quantified
type variables of a constructor by filtering out those constructor-bound
variables which do not appear in the substitution that mergeArguments
returns. In this example, Refl's bound variables are k2 and a2. a2 appears
in the returned substitution, but k2 does not, which means that we would
mistakenly conclude that k2 is existential!

Although we don't have the full power of kind inference to guide us here, we
can at least do the next best thing. Generally, the datatype-bound type
variables and the constructor type variable binders contain all of the kind
information we need, so we proceed as follows:

1. Construct a map from each constructor-bound variable to its kind. (Do the
   same for each datatype-bound variable). These maps are the first and second
   arguments to closeOverKinds, respectively.
2. Call mergeArguments once on the GADT return type and datatype-bound types,
   and pass that in as the third argument to closeOverKinds.
3. For each name-name pair in the supplied substitution, check if the first and
   second names map to kinds in the first and second kind maps in
   closeOverKinds, respectively. If so, associate the first kind with the
   second kind.
4. For each kind association discovered in part (3), call mergeArguments
   on the lists of kinds. This will yield a kind substitution and kind
   equality context.
5. If the kind substitution is non-empty, then go back to step (3) and repeat
   the process on the new kind substitution and context.

   Otherwise, if the kind substitution is empty, then we have reached a fixed-
   point (i.e., we have closed over the kinds), so proceed.
6. Union up all of the substitutions and contexts, and return those.

This algorithm is not perfect, as it will only catch everything if all of
the kinds are explicitly mentioned somewhere (and not left quantified
implicitly). Thankfully, reifying data types via Template Haskell tends to
yield a healthy amount of kind signatures, so this works quite well in
practice.
-}</span><span>
</span><span id="line-1140"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-type">closeOverKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1141"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1142"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1143"></span><span>               </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1144"></span><span id="closeOverKinds"><span class="annot"><span class="annottext">closeOverKinds :: Map Name Type
-&gt; Map Name Type -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#closeOverKinds"><span class="hs-identifier hs-var hs-var">closeOverKinds</span></a></span></span><span> </span><span id="local-6989586621679082900"><span class="annot"><span class="annottext">domainFVKinds :: Map Name Type
</span><a href="#local-6989586621679082900"><span class="hs-identifier hs-var">domainFVKinds</span></a></span></span><span> </span><span id="local-6989586621679082899"><span class="annot"><span class="annottext">rangeFVKinds :: Map Name Type
</span><a href="#local-6989586621679082899"><span class="hs-identifier hs-var">rangeFVKinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082898"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1145"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1146"></span><span>    </span><span class="annot"><a href="#local-6989586621679082898"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1147"></span><span>    </span><span id="local-6989586621679082898"><span class="annot"><span class="annottext">go :: (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082898"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082897"><span class="annot"><span class="annottext">subst :: Map Name Name
</span><a href="#local-6989586621679082897"><span class="hs-identifier hs-var">subst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082896"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679082896"><span class="hs-identifier hs-var">context</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1148"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082895"><span class="annot"><span class="annottext">substList :: [(Name, Name)]
</span><a href="#local-6989586621679082895"><span class="hs-identifier hs-var hs-var">substList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; [(Name, Name)]
forall k a. Map k a -&gt; [(k, a)]
</span><span class="hs-identifier hs-var">Map.toList</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082897"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-1149"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679082893"><span class="annot"><span class="annottext">kindsInner :: Cxt
</span><a href="#local-6989586621679082893"><span class="hs-identifier hs-var">kindsInner</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082892"><span class="annot"><span class="annottext">kindsOuter :: Cxt
</span><a href="#local-6989586621679082892"><span class="hs-identifier hs-var">kindsOuter</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1150"></span><span>            </span><span class="annot"><span class="annottext">[(Type, Type)] -&gt; (Cxt, Cxt)
forall a b. [(a, b)] -&gt; ([a], [b])
</span><span class="hs-identifier hs-var">unzip</span></span><span> </span><span class="annot"><span class="annottext">([(Type, Type)] -&gt; (Cxt, Cxt)) -&gt; [(Type, Type)] -&gt; (Cxt, Cxt)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1151"></span><span>            </span><span class="annot"><span class="annottext">((Name, Name) -&gt; Maybe (Type, Type))
-&gt; [(Name, Name)] -&gt; [(Type, Type)]
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-special">(</span><span id="local-6989586621679082890"><span class="annot"><span class="annottext">d :: Name
</span><a href="#local-6989586621679082890"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082889"><span class="annot"><span class="annottext">r :: Name
</span><a href="#local-6989586621679082889"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679082888"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082888"><span class="hs-identifier hs-var">d'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082890"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082900"><span class="hs-identifier hs-var">domainFVKinds</span></a></span><span>
</span><span id="line-1152"></span><span>                                    </span><span id="local-6989586621679082886"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082886"><span class="hs-identifier hs-var">r'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082889"><span class="hs-identifier hs-var">r</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082899"><span class="hs-identifier hs-var">rangeFVKinds</span></a></span><span>
</span><span id="line-1153"></span><span>                                    </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082888"><span class="hs-identifier hs-var">d'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082886"><span class="hs-identifier hs-var">r'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1154"></span><span>                     </span><span class="annot"><span class="annottext">[(Name, Name)]
</span><a href="#local-6989586621679082895"><span class="hs-identifier hs-var">substList</span></a></span><span>
</span><span id="line-1155"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679082885"><span class="annot"><span class="annottext">kindSubst :: Map Name Name
</span><a href="#local-6989586621679082885"><span class="hs-identifier hs-var">kindSubst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082884"><span class="annot"><span class="annottext">kindContext :: Cxt
</span><a href="#local-6989586621679082884"><span class="hs-identifier hs-var">kindContext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-var">mergeArgumentKinds</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082892"><span class="hs-identifier hs-var">kindsOuter</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082893"><span class="hs-identifier hs-var">kindsInner</span></a></span><span>
</span><span id="line-1156"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679082882"><span class="annot"><span class="annottext">restSubst :: Map Name Name
</span><a href="#local-6989586621679082882"><span class="hs-identifier hs-var">restSubst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082881"><span class="annot"><span class="annottext">restContext :: Cxt
</span><a href="#local-6989586621679082881"><span class="hs-identifier hs-var">restContext</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1157"></span><span>            </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">Map Name Name -&gt; Bool
forall k a. Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.null</span></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082885"><span class="hs-identifier hs-var">kindSubst</span></a></span><span> </span><span class="hs-comment">-- Fixed-point calculation</span><span>
</span><span id="line-1158"></span><span>                 </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1159"></span><span>                 </span><span class="hs-keyword">else</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082898"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082885"><span class="hs-identifier hs-var">kindSubst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082884"><span class="hs-identifier hs-var">kindContext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1160"></span><span>          </span><span id="local-6989586621679082878"><span class="annot"><span class="annottext">finalSubst :: Map Name Name
</span><a href="#local-6989586621679082878"><span class="hs-identifier hs-var hs-var">finalSubst</span></a></span></span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Map Name Name] -&gt; Map Name Name
forall (f :: * -&gt; *) k a.
(Foldable f, Ord k) =&gt;
f (Map k a) -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.unions</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082897"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082885"><span class="hs-identifier hs-var">kindSubst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082882"><span class="hs-identifier hs-var">restSubst</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1161"></span><span>          </span><span id="local-6989586621679082876"><span class="annot"><span class="annottext">finalContext :: Cxt
</span><a href="#local-6989586621679082876"><span class="hs-identifier hs-var hs-var">finalContext</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">(Cxt -&gt; Cxt) -&gt; Cxt -&gt; Cxt
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[Cxt] -&gt; Cxt
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082896"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082884"><span class="hs-identifier hs-var">kindContext</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082881"><span class="hs-identifier hs-var">restContext</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1162"></span><span>            </span><span class="hs-comment">-- Use `nub` here in an effort to minimize the number of</span><span>
</span><span id="line-1163"></span><span>            </span><span class="hs-comment">-- redundant equality constraints in the returned context.</span><span>
</span><span id="line-1164"></span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082878"><span class="hs-identifier hs-var">finalSubst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082876"><span class="hs-identifier hs-var">finalContext</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1165"></span><span>
</span><span id="line-1166"></span><span class="hs-comment">-- Look into a list of types and map each free variable name to its kind.</span><span>
</span><span id="line-1167"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-type">kindsOfFVsOfTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1168"></span><span id="kindsOfFVsOfTypes"><span class="annot"><span class="annottext">kindsOfFVsOfTypes :: Cxt -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-var hs-var">kindsOfFVsOfTypes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Map Name Type) -&gt; Cxt -&gt; Map Name Type
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1169"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1170"></span><span>    </span><span class="annot"><a href="#local-6989586621679082874"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1171"></span><span>    </span><span id="local-6989586621679082874"><span class="annot"><span class="annottext">go :: Type -&gt; Map Name Type
</span><a href="#local-6989586621679082874"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082873"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679082873"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679082872"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679082872"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082873"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-operator hs-var">`Map.union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082872"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1172"></span><span>    </span><span class="annot"><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082870"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082870"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082869"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082869"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1173"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082868"><span class="annot"><span class="annottext">kSigs :: Map Name Type
</span><a href="#local-6989586621679082868"><span class="hs-identifier hs-var hs-var">kSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082869"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-cpp">
#else
</span><span>                  </span><span class="hs-identifier">Map.empty</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082870"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1180"></span><span>           </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082867"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082867"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082867"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082869"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082868"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-1181"></span><span>           </span><span class="hs-identifier">_</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082870"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-operator hs-var">`Map.union`</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082868"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-1182"></span><span>
</span><span id="line-1183"></span><span>    </span><span class="annot"><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall a. a
</span><a href="#local-6989586621679082864"><span class="hs-identifier hs-var">forallError</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,16,0)
</span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">forallError</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1188"></span><span>    </span><span class="annot"><a href="#local-6989586621679082874"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-1189"></span><span>
</span><span id="line-1190"></span><span>    </span><span id="local-6989586621679083807"><span class="annot"><a href="#local-6989586621679082864"><span class="hs-identifier hs-type">forallError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679083807"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-1191"></span><span>    </span><span id="local-6989586621679082864"><span class="annot"><span class="annottext">forallError :: a
</span><a href="#local-6989586621679082864"><span class="hs-identifier hs-var hs-var">forallError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; a
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="hs-string">&quot;`forall` type used in data family pattern&quot;</span></span><span>
</span><span id="line-1192"></span><span>
</span><span id="line-1193"></span><span class="hs-comment">-- Look into a list of type variable binder and map each free variable name</span><span>
</span><span id="line-1194"></span><span class="hs-comment">-- to its kind (also map the names that KindedTVs bind to their respective</span><span>
</span><span id="line-1195"></span><span class="hs-comment">-- kinds). This function considers the kind of a PlainTV to be *.</span><span>
</span><span id="line-1196"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-type">kindsOfFVsOfTvbs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1197"></span><span id="kindsOfFVsOfTvbs"><span class="annot"><span class="annottext">kindsOfFVsOfTvbs :: [TyVarBndr] -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTvbs"><span class="hs-identifier hs-var hs-var">kindsOfFVsOfTvbs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Map Name Type) -&gt; [TyVarBndr] -&gt; Map Name Type
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Map Name Type
</span><a href="#local-6989586621679082863"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1198"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1199"></span><span>    </span><span class="annot"><a href="#local-6989586621679082863"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1200"></span><span>    </span><span id="local-6989586621679082863"><span class="annot"><span class="annottext">go :: TyVarBndr -&gt; Map Name Type
</span><a href="#local-6989586621679082863"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span> </span><span id="local-6989586621679082862"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082862"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082862"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span>
</span><span id="line-1201"></span><span>    </span><span class="annot"><a href="#local-6989586621679082863"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082860"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082860"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082859"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082859"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1202"></span><span>      </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082858"><span class="annot"><span class="annottext">kSigs :: Map Name Type
</span><a href="#local-6989586621679082858"><span class="hs-identifier hs-var hs-var">kSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><span class="annot"><span class="annottext">Cxt -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#kindsOfFVsOfTypes"><span class="hs-identifier hs-var">kindsOfFVsOfTypes</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082859"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">]</span><span class="hs-cpp">
#else
</span><span>                  </span><span class="hs-identifier">Map.empty</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082860"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082859"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082858"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-1209"></span><span>
</span><span id="line-1210"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-type">mergeArguments</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1211"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ outer parameters                    -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1212"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ inner parameters (specializations ) -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1213"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span>
</span><span id="line-1214"></span><span id="mergeArguments"><span class="annot"><span class="annottext">mergeArguments :: Cxt -&gt; Cxt -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var hs-var">mergeArguments</span></a></span></span><span> </span><span id="local-6989586621679082857"><span class="annot"><span class="annottext">ns :: Cxt
</span><a href="#local-6989586621679082857"><span class="hs-identifier hs-var">ns</span></a></span></span><span> </span><span id="local-6989586621679082856"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679082856"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">((Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt))
-&gt; (Map Name Name, Cxt) -&gt; [(Type, Type)] -&gt; (Map Name Name, Cxt)
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; [(Type, Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082857"><span class="hs-identifier hs-var">ns</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082856"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1215"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1216"></span><span>
</span><span id="line-1217"></span><span>    </span><span id="local-6989586621679082854"><span class="annot"><span class="annottext">aux :: (Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082854"><span class="hs-identifier hs-var hs-var">aux</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082853"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082853"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082852"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082852"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082851"><span class="annot"><span class="annottext">g :: Type
</span><a href="#local-6989586621679082851"><span class="hs-identifier hs-var">g</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082850"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082850"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082849"><span class="annot"><span class="annottext">sc :: (Map Name Name, Cxt)
</span><a href="#local-6989586621679082849"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1218"></span><span>      </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082852"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082850"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082853"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082851"><span class="hs-identifier hs-var">g</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, Cxt)
</span><a href="#local-6989586621679082849"><span class="hs-identifier hs-var">sc</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1219"></span><span>
</span><span id="line-1220"></span><span>    </span><span class="annot"><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082848"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082848"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679082847"><span class="annot"><span class="annottext">p :: Type
</span><a href="#local-6989586621679082847"><span class="hs-identifier hs-var">p</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082846"><span class="annot"><span class="annottext">subst :: Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082845"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679082845"><span class="hs-identifier hs-var">context</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1221"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082847"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1222"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082844"><span class="annot"><span class="annottext">m :: Name
</span><a href="#local-6989586621679082844"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082844"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082848"><span class="hs-identifier hs-var">n</span></a></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082845"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1223"></span><span>                   </span><span class="hs-comment">-- If the two variables are the same, don't bother extending</span><span>
</span><span id="line-1224"></span><span>                   </span><span class="hs-comment">-- the substitution. (This is purely an optimization.)</span><span>
</span><span id="line-1225"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679082843"><span class="annot"><span class="annottext">n' :: Name
</span><a href="#local-6989586621679082843"><span class="hs-identifier hs-var">n'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Name -&gt; Maybe Name
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082844"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span><span>
</span><span id="line-1226"></span><span>               </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082848"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082843"><span class="hs-identifier hs-var">n'</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082845"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1227"></span><span>                   </span><span class="hs-comment">-- If a variable is already in a substitution and it maps</span><span>
</span><span id="line-1228"></span><span>                   </span><span class="hs-comment">-- to the variable that we are trying to unify with, then</span><span>
</span><span id="line-1229"></span><span>                   </span><span class="hs-comment">-- leave the context alone. (Not doing so caused #46.)</span><span>
</span><span id="line-1230"></span><span>               </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Name -&gt; Bool
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Bool
</span><span class="hs-identifier hs-var">Map.notMember</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082844"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Map Name Name -&gt; Map Name Name
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082844"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082848"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082845"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1231"></span><span>        </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Name
</span><a href="#local-6989586621679082846"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-var">equalPred</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082848"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082847"><span class="hs-identifier hs-var">p</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Cxt -&gt; Cxt
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082845"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1232"></span><span>
</span><span id="line-1233"></span><span>    </span><span class="annot"><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082842"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082842"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082841"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082841"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082840"><span class="annot"><span class="annottext">sc :: (Map Name Name, Cxt)
</span><a href="#local-6989586621679082840"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082842"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082841"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, Cxt)
</span><a href="#local-6989586621679082840"><span class="hs-identifier hs-var">sc</span></a></span><span> </span><span class="hs-comment">-- learn about kinds??</span><span>
</span><span id="line-1234"></span><span>    </span><span class="hs-comment">-- This matches *after* VarT so that we can compute a substitution</span><span>
</span><span id="line-1235"></span><span>    </span><span class="hs-comment">-- that includes the kind signature.</span><span>
</span><span id="line-1236"></span><span>    </span><span class="annot"><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082839"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082839"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082838"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082838"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082837"><span class="annot"><span class="annottext">sc :: (Map Name Name, Cxt)
</span><a href="#local-6989586621679082837"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; (Map Name Name, Cxt) -&gt; (Map Name Name, Cxt)
</span><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082839"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082838"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, Cxt)
</span><a href="#local-6989586621679082837"><span class="hs-identifier hs-var">sc</span></a></span><span>
</span><span id="line-1237"></span><span>
</span><span id="line-1238"></span><span>    </span><span class="annot"><a href="#local-6989586621679082854"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679082836"><span class="annot"><span class="annottext">sc :: (Map Name Name, Cxt)
</span><a href="#local-6989586621679082836"><span class="hs-identifier hs-var">sc</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Name, Cxt)
</span><a href="#local-6989586621679082836"><span class="hs-identifier hs-var">sc</span></a></span><span>
</span><span id="line-1239"></span><span>
</span><span id="line-1240"></span><span class="hs-comment">-- | A specialization of 'mergeArguments' to 'Kind'.</span><span>
</span><span id="line-1241"></span><span class="hs-comment">-- Needed only for backwards compatibility with older versions of</span><span>
</span><span id="line-1242"></span><span class="hs-comment">-- @template-haskell@.</span><span>
</span><span id="line-1243"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-type">mergeArgumentKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1244"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1245"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1246"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="mergeArgumentKinds"><span class="annot"><span class="annottext">mergeArgumentKinds :: Cxt -&gt; Cxt -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#mergeArgumentKinds"><span class="hs-identifier hs-var hs-var">mergeArgumentKinds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; (Map Name Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#mergeArguments"><span class="hs-identifier hs-var">mergeArguments</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">mergeArgumentKinds</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">Map.empty</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1253"></span><span class="hs-comment">-- | Expand all of the type synonyms in a type.</span><span>
</span><span id="line-1254"></span><span class="hs-comment">--</span><span>
</span><span id="line-1255"></span><span class="hs-comment">-- Note that this function will drop parentheses as a side effect.</span><span>
</span><span id="line-1256"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-type">resolveTypeSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1257"></span><span id="resolveTypeSynonyms"><span class="annot"><span class="annottext">resolveTypeSynonyms :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var hs-var">resolveTypeSynonyms</span></a></span></span><span> </span><span id="local-6989586621679082835"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082835"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1258"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082834"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082834"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082833"><span class="annot"><span class="annottext">xs :: [TypeArg]
</span><a href="#local-6989586621679082833"><span class="hs-identifier hs-var">xs</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-var">decomposeTypeArgs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082835"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1259"></span><span>
</span><span id="line-1260"></span><span>      </span><span class="annot"><a href="#local-6989586621679082831"><span class="hs-identifier hs-type">notTypeSynCase</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1261"></span><span>      </span><span id="local-6989586621679082831"><span class="annot"><span class="annottext">notTypeSynCase :: Type -&gt; Q Type
</span><a href="#local-6989586621679082831"><span class="hs-identifier hs-var hs-var">notTypeSynCase</span></a></span></span><span> </span><span id="local-6989586621679082830"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679082830"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg -&gt; Type) -&gt; Type -&gt; [TypeArg] -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-var">appTypeArg</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082830"><span class="hs-identifier hs-var">ty</span></a></span><span> </span><span class="annot"><span class="annottext">([TypeArg] -&gt; Type) -&gt; Q [TypeArg] -&gt; Q Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(TypeArg -&gt; Q TypeArg) -&gt; [TypeArg] -&gt; Q [TypeArg]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">TypeArg -&gt; Q TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-var">resolveTypeArgSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082833"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-1262"></span><span>
</span><span id="line-1263"></span><span>      </span><span class="annot"><a href="#local-6989586621679082827"><span class="hs-identifier hs-type">expandCon</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">-- The Name to check whether it is a type synonym or not</span><span>
</span><span id="line-1264"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-comment">-- The argument type to fall back on if the supplied</span><span>
</span><span id="line-1265"></span><span>                        </span><span class="hs-comment">-- Name isn't a type synonym</span><span>
</span><span id="line-1266"></span><span>                </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1267"></span><span>      </span><span id="local-6989586621679082827"><span class="annot"><span class="annottext">expandCon :: Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679082827"><span class="hs-identifier hs-var hs-var">expandCon</span></a></span></span><span> </span><span id="local-6989586621679082826"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082826"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082825"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679082825"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1268"></span><span>        </span><span id="local-6989586621679082824"><span class="annot"><span class="annottext">Maybe Info
</span><a href="#local-6989586621679082824"><span class="hs-identifier hs-var">mbInfo</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Info)
</span><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-var">reifyMaybe</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082826"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1269"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Maybe Info
</span><a href="#local-6989586621679082824"><span class="hs-identifier hs-var">mbInfo</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1270"></span><span>          </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TyConI</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">TySynD</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679082821"><span class="annot"><span class="annottext">synvars :: [TyVarBndr]
</span><a href="#local-6989586621679082821"><span class="hs-identifier hs-var">synvars</span></a></span></span><span> </span><span id="local-6989586621679082820"><span class="annot"><span class="annottext">def :: Type
</span><a href="#local-6989586621679082820"><span class="hs-identifier hs-var">def</span></a></span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1271"></span><span>            </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-var">expandSynonymRHS</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082821"><span class="hs-identifier hs-var">synvars</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TypeArg] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-var">filterTANormals</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082833"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082820"><span class="hs-identifier hs-var">def</span></a></span><span>
</span><span id="line-1272"></span><span>          </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679082831"><span class="hs-identifier hs-var">notTypeSynCase</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082825"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-1273"></span><span>
</span><span id="line-1274"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082834"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1275"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082817"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082817"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679082816"><span class="annot"><span class="annottext">ctxt :: Cxt
</span><a href="#local-6989586621679082816"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679082815"><span class="annot"><span class="annottext">body :: Type
</span><a href="#local-6989586621679082815"><span class="hs-identifier hs-var">body</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1276"></span><span>         </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type)
-&gt; Q [TyVarBndr] -&gt; Q (Cxt -&gt; Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">`fmap`</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Q TyVarBndr) -&gt; [TyVarBndr] -&gt; Q [TyVarBndr]
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Q TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var">resolve_tvb_syns</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082817"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-1277"></span><span>                   </span><span class="annot"><span class="annottext">Q (Cxt -&gt; Type -&gt; Type) -&gt; Q Cxt -&gt; Q (Type -&gt; Type)
forall (m :: * -&gt; *) a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">`ap`</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Cxt -&gt; Q Cxt
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-var">resolvePredSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082816"><span class="hs-identifier hs-var">ctxt</span></a></span><span>
</span><span id="line-1278"></span><span>                   </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *) a b. Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">`ap`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082815"><span class="hs-identifier hs-var">body</span></a></span><span>
</span><span id="line-1279"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082812"><span class="annot"><span class="annottext">ty :: Type
</span><a href="#local-6989586621679082812"><span class="hs-identifier hs-var">ty</span></a></span></span><span> </span><span id="local-6989586621679082811"><span class="annot"><span class="annottext">ki :: Type
</span><a href="#local-6989586621679082811"><span class="hs-identifier hs-var">ki</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1280"></span><span>         </span><span id="local-6989586621679082810"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082810"><span class="hs-identifier hs-var">ty'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082812"><span class="hs-identifier hs-var">ty</span></a></span><span>
</span><span id="line-1281"></span><span>         </span><span id="local-6989586621679082809"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082809"><span class="hs-identifier hs-var">ki'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082811"><span class="hs-identifier hs-var">ki</span></a></span><span>
</span><span id="line-1282"></span><span>         </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679082831"><span class="hs-identifier hs-var">notTypeSynCase</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082810"><span class="hs-identifier hs-var">ty'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082809"><span class="hs-identifier hs-var">ki'</span></a></span><span>
</span><span id="line-1283"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679082808"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082808"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679082827"><span class="hs-identifier hs-var">expandCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082808"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082808"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679082806"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679082806"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679082805"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082805"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082804"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679082804"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1286"></span><span>         </span><span id="local-6989586621679082803"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082803"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082806"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-1287"></span><span>         </span><span id="local-6989586621679082802"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082802"><span class="hs-identifier hs-var">t2'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082804"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1288"></span><span>         </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679082827"><span class="hs-identifier hs-var">expandCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082805"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">InfixT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082803"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082805"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082802"><span class="hs-identifier hs-var">t2'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1289"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679082800"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679082800"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679082799"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082799"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082798"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679082798"><span class="hs-identifier hs-var">t2</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1290"></span><span>         </span><span id="local-6989586621679082797"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082797"><span class="hs-identifier hs-var">t1'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082800"><span class="hs-identifier hs-var">t1</span></a></span><span>
</span><span id="line-1291"></span><span>         </span><span id="local-6989586621679082796"><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082796"><span class="hs-identifier hs-var">t2'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082798"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1292"></span><span>         </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Q Type
</span><a href="#local-6989586621679082827"><span class="hs-identifier hs-var">expandCon</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082799"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">UInfixT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082797"><span class="hs-identifier hs-var">t1'</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082799"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082796"><span class="hs-identifier hs-var">t2'</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>       </span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679082794"><span class="annot"><span class="annottext">n :: String
</span><a href="#local-6989586621679082794"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082793"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082793"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1296"></span><span>         </span><span class="annot"><span class="annottext">String -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679082794"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082793"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>       </span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-identifier">tvbs</span><span> </span><span class="hs-identifier">body</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1300"></span><span>         </span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">fmap</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">mapM</span><span> </span><span class="hs-identifier">resolve_tvb_syns</span><span> </span><span class="hs-identifier">tvbs</span><span>
</span><span id="line-1301"></span><span>                      </span><span class="hs-special">`</span><span class="hs-identifier">ap</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">body</span><span class="hs-cpp">
#endif
</span><span>       </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="#local-6989586621679082831"><span class="hs-identifier hs-var">notTypeSynCase</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082834"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-1304"></span><span>
</span><span id="line-1305"></span><span class="hs-comment">-- | Expand all of the type synonyms in a 'TypeArg'.</span><span>
</span><span id="line-1306"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-type">resolveTypeArgSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span>
</span><span id="line-1307"></span><span id="resolveTypeArgSynonyms"><span class="annot"><span class="annottext">resolveTypeArgSynonyms :: TypeArg -&gt; Q TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-var hs-var">resolveTypeArgSynonyms</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679082791"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082791"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg) -&gt; Q Type -&gt; Q TypeArg
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082791"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1308"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveTypeArgSynonyms"><span class="hs-identifier hs-var">resolveTypeArgSynonyms</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679082789"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082789"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span><span>    </span><span class="annot"><span class="annottext">(Type -&gt; TypeArg) -&gt; Q Type -&gt; Q TypeArg
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082789"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1309"></span><span>
</span><span id="line-1310"></span><span class="hs-comment">-- | Expand all of the type synonyms in a 'Kind'.</span><span>
</span><span id="line-1311"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-type">resolveKindSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="resolveKindSynonyms"><span class="annot"><span class="annottext">resolveKindSynonyms :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var hs-var">resolveKindSynonyms</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">resolveKindSynonyms</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span> </span><span class="hs-comment">-- One simply couldn't put type synonyms into</span><span>
</span><span id="line-1316"></span><span>                             </span><span class="hs-comment">-- kinds on old versions of GHC.</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1319"></span><span class="hs-comment">-- | Expand all of the type synonyms in a the kind of a 'TyVarBndr'.</span><span>
</span><span id="line-1320"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-type">resolve_tvb_syns</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span>
</span><span id="line-1321"></span><span id="resolve_tvb_syns"><span class="annot"><span class="annottext">resolve_tvb_syns :: TyVarBndr -&gt; Q TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var hs-var">resolve_tvb_syns</span></a></span></span><span> </span><span id="local-6989586621679082788"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082788"><span class="hs-identifier hs-var">tvb</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Q TyVarBndr
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082788"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-1322"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolve_tvb_syns"><span class="hs-identifier hs-var">resolve_tvb_syns</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082787"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082787"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082786"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082786"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082787"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TyVarBndr) -&gt; Q Type -&gt; Q TyVarBndr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveKindSynonyms"><span class="hs-identifier hs-var">resolveKindSynonyms</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082786"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1323"></span><span>
</span><span id="line-1324"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-type">expandSynonymRHS</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-1325"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ Substitute these variables... -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1326"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ ...with these types... -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1327"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>        </span><span class="hs-comment">{- ^ ...inside of this type. -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1328"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1329"></span><span id="expandSynonymRHS"><span class="annot"><span class="annottext">expandSynonymRHS :: [TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#expandSynonymRHS"><span class="hs-identifier hs-var hs-var">expandSynonymRHS</span></a></span></span><span> </span><span id="local-6989586621679082785"><span class="annot"><span class="annottext">synvars :: [TyVarBndr]
</span><a href="#local-6989586621679082785"><span class="hs-identifier hs-var">synvars</span></a></span></span><span> </span><span id="local-6989586621679082784"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679082784"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679082783"><span class="annot"><span class="annottext">def :: Type
</span><a href="#local-6989586621679082783"><span class="hs-identifier hs-var">def</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1330"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082782"><span class="annot"><span class="annottext">argNames :: [Name]
</span><a href="#local-6989586621679082782"><span class="hs-identifier hs-var hs-var">argNames</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Name) -&gt; [TyVarBndr] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082785"><span class="hs-identifier hs-var">synvars</span></a></span><span>
</span><span id="line-1331"></span><span>      </span><span class="hs-special">(</span><span id="local-6989586621679082781"><span class="annot"><span class="annottext">args :: Cxt
</span><a href="#local-6989586621679082781"><span class="hs-identifier hs-var">args</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679082780"><span class="annot"><span class="annottext">rest :: Cxt
</span><a href="#local-6989586621679082780"><span class="hs-identifier hs-var">rest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Cxt -&gt; (Cxt, Cxt)
forall a. Int -&gt; [a] -&gt; ([a], [a])
</span><span class="hs-identifier hs-var">splitAt</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; Int
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Int
</span><span class="hs-identifier hs-var">length</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082782"><span class="hs-identifier hs-var">argNames</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082784"><span class="hs-identifier hs-var">ts</span></a></span><span>
</span><span id="line-1332"></span><span>      </span><span id="local-6989586621679082778"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679082778"><span class="hs-identifier hs-var hs-var">subst</span></a></span></span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Name, Type)] -&gt; Map Name Type
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; Cxt -&gt; [(Name, Type)]
forall a b. [a] -&gt; [b] -&gt; [(a, b)]
</span><span class="hs-identifier hs-var">zip</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082782"><span class="hs-identifier hs-var">argNames</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082781"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1333"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; Cxt -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082778"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082783"><span class="hs-identifier hs-var">def</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082780"><span class="hs-identifier hs-var">rest</span></a></span><span>
</span><span id="line-1334"></span><span>
</span><span id="line-1335"></span><span class="hs-comment">-- | Expand all of the type synonyms in a 'Pred'.</span><span>
</span><span id="line-1336"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-type">resolvePredSynonyms</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="resolvePredSynonyms"><span class="annot"><span class="annottext">resolvePredSynonyms :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolvePredSynonyms"><span class="hs-identifier hs-var hs-var">resolvePredSynonyms</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1341"></span><span>  </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reifyMaybe</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1342"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">mbInfo</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1343"></span><span>    </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TyConI</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TySynD</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-identifier">def</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1344"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">expandSynonymRHS</span><span> </span><span class="hs-identifier">synvars</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">def</span><span>
</span><span id="line-1345"></span><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">mapM</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-1346"></span><span class="hs-identifier">resolvePredSynonyms</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-1347"></span><span>  </span><span class="hs-identifier">t1'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">t1</span><span>
</span><span id="line-1348"></span><span>  </span><span class="hs-identifier">t2'</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">resolveTypeSynonyms</span><span> </span><span class="hs-identifier">t2</span><span>
</span><span id="line-1349"></span><span>  </span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1'</span><span> </span><span class="hs-identifier">t2'</span><span class="hs-special">)</span><span>
</span><span id="line-1350"></span><span>
</span><span id="line-1351"></span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier">Type</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Pred</span><span>
</span><span id="line-1352"></span><span class="hs-identifier">typeToPred</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1353"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-operator">:|</span><span> </span><span class="hs-identifier">xs</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">decomposeType</span><span> </span><span class="hs-identifier">t</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1354"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1355"></span><span>    </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-1356"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">==</span><span> </span><span class="hs-identifier">eqTypeName</span><span class="hs-cpp">
# if __GLASGOW_HASKELL__ == 704
</span><span>        </span><span class="hs-comment">-- There's an unfortunate bug in GHC 7.4 where the (~) type is reified</span><span>
</span><span id="line-1359"></span><span>        </span><span class="hs-comment">-- with an explicit kind argument. To work around this, we ignore it.</span><span>
</span><span id="line-1360"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">t1</span><span class="hs-special">,</span><span class="hs-identifier">t2</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">xs</span><span class="hs-cpp">
# else
</span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">t1</span><span class="hs-special">,</span><span class="hs-identifier">t2</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">xs</span><span class="hs-cpp">
# endif
</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span>
</span><span id="line-1365"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="hs-identifier">otherwise</span><span>
</span><span id="line-1366"></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span>
</span><span id="line-1367"></span><span>    </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">error</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-string">&quot;typeToPred: Can't handle type &quot;</span><span> </span><span class="hs-operator">++</span><span> </span><span class="hs-identifier">show</span><span> </span><span class="hs-identifier">t</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1370"></span><span class="hs-comment">-- | Decompose a type into a list of it's outermost applications. This process</span><span>
</span><span id="line-1371"></span><span class="hs-comment">-- forgets about infix application, explicit parentheses, and visible kind</span><span>
</span><span id="line-1372"></span><span class="hs-comment">-- applications.</span><span>
</span><span id="line-1373"></span><span class="hs-comment">--</span><span>
</span><span id="line-1374"></span><span class="hs-comment">-- This operation should be used after all 'UInfixT' cases have been resolved</span><span>
</span><span id="line-1375"></span><span class="hs-comment">-- by 'resolveFixities' if the argument is being user generated.</span><span>
</span><span id="line-1376"></span><span class="hs-comment">--</span><span>
</span><span id="line-1377"></span><span class="hs-comment">-- &gt; t ~= foldl1 AppT (decomposeType t)</span><span>
</span><span id="line-1378"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-type">decomposeType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmpty"><span class="hs-identifier hs-type">NonEmpty</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1379"></span><span id="decomposeType"><span class="annot"><span class="annottext">decomposeType :: Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var hs-var">decomposeType</span></a></span></span><span> </span><span id="local-6989586621679082777"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082777"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1380"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-var">decomposeTypeArgs</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082777"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1381"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621679082776"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082776"><span class="hs-identifier hs-var">f</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082775"><span class="annot"><span class="annottext">x :: [TypeArg]
</span><a href="#local-6989586621679082775"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082776"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Cxt -&gt; NonEmpty Type
forall a. a -&gt; [a] -&gt; NonEmpty a
</span><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-var">filterTANormals</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082775"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1382"></span><span>
</span><span id="line-1383"></span><span class="hs-comment">-- | A variant of 'decomposeType' that preserves information about visible kind</span><span>
</span><span id="line-1384"></span><span class="hs-comment">-- applications by returning a 'NonEmpty' list of 'TypeArg's.</span><span>
</span><span id="line-1385"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-type">decomposeTypeArgs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1386"></span><span id="decomposeTypeArgs"><span class="annot"><span class="annottext">decomposeTypeArgs :: Type -&gt; (Type, [TypeArg])
</span><a href="Language.Haskell.TH.Datatype.html#decomposeTypeArgs"><span class="hs-identifier hs-var hs-var">decomposeTypeArgs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1387"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1388"></span><span>    </span><span class="annot"><a href="#local-6989586621679082774"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1389"></span><span>    </span><span id="local-6989586621679082774"><span class="annot"><span class="annottext">go :: [TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679082774"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679082773"><span class="annot"><span class="annottext">args :: [TypeArg]
</span><a href="#local-6989586621679082773"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082772"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082772"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679082771"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082771"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082771"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">TypeArg -&gt; [TypeArg] -&gt; [TypeArg]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082773"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082772"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>    </span><span class="annot"><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082770"><span class="annot"><span class="annottext">args :: [TypeArg]
</span><a href="#local-6989586621679082770"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679082768"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082768"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082770"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082768"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>    </span><span class="annot"><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082767"><span class="annot"><span class="annottext">args :: [TypeArg]
</span><a href="#local-6989586621679082767"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679082765"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082765"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679082764"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082764"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TypeArg] -&gt; Type -&gt; (Type, [TypeArg])
</span><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; TypeArg
</span><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082764"><span class="hs-identifier hs-var">x</span></a></span><span class="annot"><span class="annottext">TypeArg -&gt; [TypeArg] -&gt; [TypeArg]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082767"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082765"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-cpp">
#endif
</span><span>    </span><span class="annot"><a href="#local-6989586621679082774"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082763"><span class="annot"><span class="annottext">args :: [TypeArg]
</span><a href="#local-6989586621679082763"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621679082762"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082762"><span class="hs-identifier hs-var">t</span></a></span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082762"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">[TypeArg]
</span><a href="#local-6989586621679082763"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1397"></span><span>
</span><span id="line-1398"></span><span class="hs-comment">-- | An argument to a type, either a normal type ('TANormal') or a visible</span><span>
</span><span id="line-1399"></span><span class="hs-comment">-- kind application ('TyArg').</span><span>
</span><span id="line-1400"></span><span class="hs-keyword">data</span><span> </span><span id="TypeArg"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-var">TypeArg</span></a></span></span><span>
</span><span id="line-1401"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span id="TANormal"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-var">TANormal</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1402"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TyArg"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-var">TyArg</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1403"></span><span>
</span><span id="line-1404"></span><span class="hs-comment">-- | Apply a 'Type' to a 'TypeArg'.</span><span>
</span><span id="line-1405"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-type">appTypeArg</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1406"></span><span id="appTypeArg"><span class="annot"><span class="annottext">appTypeArg :: Type -&gt; TypeArg -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-var hs-var">appTypeArg</span></a></span></span><span> </span><span id="local-6989586621679082761"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082761"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679082760"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082760"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082761"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082760"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1407"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#appTypeArg"><span class="hs-identifier hs-var">appTypeArg</span></a></span><span> </span><span id="local-6989586621679082759"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082759"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span id="local-6989586621679082758"><span class="annot"><span class="annottext">_k :: Type
</span><a href="#local-6989586621679082758"><span class="hs-identifier hs-var">_k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,15,0)
</span><span>  </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082759"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppKindT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082758"><span class="hs-identifier hs-var">_k</span></a></span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-identifier">f</span><span> </span><span class="hs-comment">-- VKA isn't supported, so conservatively drop the argument</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1414"></span><span class="hs-comment">-- | Filter out all of the normal type arguments from a list of 'TypeArg's.</span><span>
</span><span id="line-1415"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-type">filterTANormals</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span>
</span><span id="line-1416"></span><span id="filterTANormals"><span class="annot"><span class="annottext">filterTANormals :: [TypeArg] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#filterTANormals"><span class="hs-identifier hs-var hs-var">filterTANormals</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TypeArg -&gt; Maybe Type) -&gt; [TypeArg] -&gt; Cxt
forall a b. (a -&gt; Maybe b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">mapMaybe</span></span><span> </span><span class="annot"><span class="annottext">TypeArg -&gt; Maybe Type
</span><a href="#local-6989586621679082757"><span class="hs-identifier hs-var">f</span></a></span><span>
</span><span id="line-1417"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1418"></span><span>    </span><span class="annot"><a href="#local-6989586621679082757"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeArg"><span class="hs-identifier hs-type">TypeArg</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1419"></span><span>    </span><span id="local-6989586621679082757"><span class="annot"><span class="annottext">f :: TypeArg -&gt; Maybe Type
</span><a href="#local-6989586621679082757"><span class="hs-identifier hs-var hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TANormal"><span class="hs-identifier hs-type">TANormal</span></a></span><span> </span><span id="local-6989586621679082756"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082756"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Maybe Type
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082756"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1420"></span><span>    </span><span class="annot"><a href="#local-6989586621679082757"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TyArg"><span class="hs-identifier hs-type">TyArg</span></a></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1421"></span><span>
</span><span id="line-1422"></span><span class="hs-comment">-- 'NonEmpty' didn't move into base until recently. Reimplementing it locally</span><span>
</span><span id="line-1423"></span><span class="hs-comment">-- saves dependencies for supporting older GHCs</span><span>
</span><span id="line-1424"></span><span class="hs-keyword">data</span><span> </span><span id="NonEmpty"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmpty"><span class="hs-identifier hs-var">NonEmpty</span></a></span></span><span> </span><span id="local-6989586621679083794"><span class="annot"><a href="#local-6989586621679083794"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><a href="#local-6989586621679083794"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span id="%3A%7C"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-var">:|</span></a></span></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679083794"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1425"></span><span>
</span><span id="line-1426"></span><span class="hs-keyword">data</span><span> </span><span id="NonEmptySnoc"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier hs-var">NonEmptySnoc</span></a></span></span><span> </span><span id="local-6989586621679083792"><span class="annot"><a href="#local-6989586621679083792"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679083792"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span id="%3A%7C-"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-var">:|-</span></a></span></span><span> </span><span class="annot"><a href="#local-6989586621679083792"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-1427"></span><span>
</span><span id="line-1428"></span><span class="hs-comment">-- Decompose a function type into its context, argument types,</span><span>
</span><span id="line-1429"></span><span class="hs-comment">-- and return type. For instance, this</span><span>
</span><span id="line-1430"></span><span class="hs-comment">--</span><span>
</span><span id="line-1431"></span><span class="hs-comment">--   forall a b. (Show a, b ~ Int) =&gt; (a -&gt; b) -&gt; Char -&gt; Int</span><span>
</span><span id="line-1432"></span><span class="hs-comment">--</span><span>
</span><span id="line-1433"></span><span class="hs-comment">-- becomes</span><span>
</span><span id="line-1434"></span><span class="hs-comment">--</span><span>
</span><span id="line-1435"></span><span class="hs-comment">--   ([a, b], [Show a, b ~ Int], [a -&gt; b, Char] :|- Int)</span><span>
</span><span id="line-1436"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-type">uncurryType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier hs-type">NonEmptySnoc</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-1437"></span><span id="uncurryType"><span class="annot"><span class="annottext">uncurryType :: Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-var hs-var">uncurryType</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
-&gt; Cxt -&gt; Cxt -&gt; Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="#local-6989586621679082755"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1438"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1439"></span><span>    </span><span id="local-6989586621679082755"><span class="annot"><span class="annottext">go :: [TyVarBndr]
-&gt; Cxt -&gt; Cxt -&gt; Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="#local-6989586621679082755"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679082754"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082754"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679082753"><span class="annot"><span class="annottext">ctxt :: Cxt
</span><a href="#local-6989586621679082753"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679082752"><span class="annot"><span class="annottext">args :: Cxt
</span><a href="#local-6989586621679082752"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">ArrowT</span></span><span> </span><span id="local-6989586621679082750"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679082750"><span class="hs-identifier hs-var">t1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082749"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679082749"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
-&gt; Cxt -&gt; Cxt -&gt; Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="#local-6989586621679082755"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082754"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082753"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082750"><span class="hs-identifier hs-var">t1</span></a></span><span class="annot"><span class="annottext">Type -&gt; Cxt -&gt; Cxt
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082752"><span class="hs-identifier hs-var">args</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082749"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1440"></span><span>    </span><span class="annot"><a href="#local-6989586621679082755"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082748"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082748"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679082747"><span class="annot"><span class="annottext">ctxt :: Cxt
</span><a href="#local-6989586621679082747"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679082746"><span class="annot"><span class="annottext">args :: Cxt
</span><a href="#local-6989586621679082746"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082745"><span class="annot"><span class="annottext">tvbs' :: [TyVarBndr]
</span><a href="#local-6989586621679082745"><span class="hs-identifier hs-var">tvbs'</span></a></span></span><span> </span><span id="local-6989586621679082744"><span class="annot"><span class="annottext">ctxt' :: Cxt
</span><a href="#local-6989586621679082744"><span class="hs-identifier hs-var">ctxt'</span></a></span></span><span> </span><span id="local-6989586621679082743"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082743"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
-&gt; Cxt -&gt; Cxt -&gt; Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="#local-6989586621679082755"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082748"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082745"><span class="hs-identifier hs-var">tvbs'</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082747"><span class="hs-identifier hs-var">ctxt</span></a></span><span class="annot"><span class="annottext">Cxt -&gt; Cxt -&gt; Cxt
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082744"><span class="hs-identifier hs-var">ctxt'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082746"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082743"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1441"></span><span>    </span><span class="annot"><a href="#local-6989586621679082755"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082742"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082742"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679082741"><span class="annot"><span class="annottext">ctxt :: Cxt
</span><a href="#local-6989586621679082741"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679082740"><span class="annot"><span class="annottext">args :: Cxt
</span><a href="#local-6989586621679082740"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621679082739"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082739"><span class="hs-identifier hs-var">t</span></a></span></span><span>                          </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082742"><span class="hs-identifier hs-var">tvbs</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082741"><span class="hs-identifier hs-var">ctxt</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Cxt
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082740"><span class="hs-identifier hs-var">args</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; Type -&gt; NonEmptySnoc Type
forall a. [a] -&gt; a -&gt; NonEmptySnoc a
</span><a href="Language.Haskell.TH.Datatype.html#%3A%7C-"><span class="hs-operator hs-var">:|-</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082739"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1442"></span><span>
</span><span id="line-1443"></span><span class="hs-comment">-- | Decompose a function kind into its context, argument kinds,</span><span>
</span><span id="line-1444"></span><span class="hs-comment">-- and return kind. For instance, this</span><span>
</span><span id="line-1445"></span><span class="hs-comment">--</span><span>
</span><span id="line-1446"></span><span class="hs-comment">--  forall a b. Maybe a -&gt; Maybe b -&gt; Type</span><span>
</span><span id="line-1447"></span><span class="hs-comment">--</span><span>
</span><span id="line-1448"></span><span class="hs-comment">-- becomes</span><span>
</span><span id="line-1449"></span><span class="hs-comment">--</span><span>
</span><span id="line-1450"></span><span class="hs-comment">--   ([a, b], [], [Maybe a, Maybe b] :|- Type)</span><span>
</span><span id="line-1451"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#uncurryKind"><span class="hs-identifier hs-type">uncurryKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NonEmptySnoc"><span class="hs-identifier hs-type">NonEmptySnoc</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="uncurryKind"><span class="annot"><span class="annottext">uncurryKind :: Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryKind"><span class="hs-identifier hs-var hs-var">uncurryKind</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; ([TyVarBndr], Cxt, NonEmptySnoc Type)
</span><a href="Language.Haskell.TH.Datatype.html#uncurryType"><span class="hs-identifier hs-var">uncurryType</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">uncurryKind</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1456"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1457"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">args</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ArrowK</span><span> </span><span class="hs-identifier">k1</span><span> </span><span class="hs-identifier">k2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">k1</span><span class="hs-glyph">:</span><span class="hs-identifier">args</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">k2</span><span>
</span><span id="line-1458"></span><span>    </span><span class="hs-identifier">go</span><span> </span><span class="hs-identifier">args</span><span> </span><span class="hs-identifier">StarK</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">reverse</span><span> </span><span class="hs-identifier">args</span><span> </span><span class="hs-operator">:|-</span><span> </span><span class="hs-identifier">StarK</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1461"></span><span class="hs-comment">-- Reconstruct a function type from its type variable binders, context,</span><span>
</span><span id="line-1462"></span><span class="hs-comment">-- argument types and return type.</span><span>
</span><span id="line-1463"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#curryType"><span class="hs-identifier hs-type">curryType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Cxt</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1464"></span><span id="curryType"><span class="annot"><span class="annottext">curryType :: [TyVarBndr] -&gt; Cxt -&gt; Cxt -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#curryType"><span class="hs-identifier hs-var hs-var">curryType</span></a></span></span><span> </span><span id="local-6989586621679082737"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082737"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679082736"><span class="annot"><span class="annottext">ctxt :: Cxt
</span><a href="#local-6989586621679082736"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679082735"><span class="annot"><span class="annottext">args :: Cxt
</span><a href="#local-6989586621679082735"><span class="hs-identifier hs-var">args</span></a></span></span><span> </span><span id="local-6989586621679082734"><span class="annot"><span class="annottext">res :: Type
</span><a href="#local-6989586621679082734"><span class="hs-identifier hs-var">res</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1465"></span><span>  </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082737"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082736"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Type -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; Cxt -&gt; Type
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679082733"><span class="annot"><span class="annottext">arg :: Type
</span><a href="#local-6989586621679082733"><span class="hs-identifier hs-var">arg</span></a></span></span><span> </span><span id="local-6989586621679082732"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082732"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">ArrowT</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082733"><span class="hs-identifier hs-var">arg</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082732"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082734"><span class="hs-identifier hs-var">res</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082735"><span class="hs-identifier hs-var">args</span></a></span><span>
</span><span id="line-1466"></span><span>
</span><span id="line-1467"></span><span class="hs-comment">-- | Resolve any infix type application in a type using the fixities that</span><span>
</span><span id="line-1468"></span><span class="hs-comment">-- are currently available. Starting in `template-haskell-2.11` types could</span><span>
</span><span id="line-1469"></span><span class="hs-comment">-- contain unresolved infix applications.</span><span>
</span><span id="line-1470"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-type">resolveInfixT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,11,0)
</span><span id="resolveInfixT"><span class="annot"><span class="annottext">resolveInfixT :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var hs-var">resolveInfixT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082731"><span class="annot"><span class="annottext">vs :: [TyVarBndr]
</span><a href="#local-6989586621679082731"><span class="hs-identifier hs-var">vs</span></a></span></span><span> </span><span id="local-6989586621679082730"><span class="annot"><span class="annottext">cx :: Cxt
</span><a href="#local-6989586621679082730"><span class="hs-identifier hs-var">cx</span></a></span></span><span> </span><span id="local-6989586621679082729"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082729"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">([TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type)
-&gt; Q [TyVarBndr] -&gt; Q (Cxt -&gt; Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Q TyVarBndr) -&gt; [TyVarBndr] -&gt; Q [TyVarBndr]
forall (t :: * -&gt; *) (f :: * -&gt; *) a b.
(Traversable t, Applicative f) =&gt;
(a -&gt; f b) -&gt; t a -&gt; f (t b)
</span><span class="hs-identifier hs-var">traverse</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; TyVarBndr -&gt; Q TyVarBndr
forall (f :: * -&gt; *).
Applicative f =&gt;
(Type -&gt; f Type) -&gt; TyVarBndr -&gt; f TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#traverseTvbKind"><span class="hs-identifier hs-var">traverseTvbKind</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082731"><span class="hs-identifier hs-var">vs</span></a></span><span>
</span><span id="line-1474"></span><span>                                          </span><span class="annot"><span class="annottext">Q (Cxt -&gt; Type -&gt; Type) -&gt; Q Cxt -&gt; Q (Type -&gt; Type)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Cxt -&gt; Q Cxt
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082730"><span class="hs-identifier hs-var">cx</span></a></span><span>
</span><span id="line-1475"></span><span>                                          </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082729"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1476"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082726"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082726"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082725"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082725"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082726"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082725"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1477"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679082724"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082724"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082724"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1478"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679082723"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082723"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679082722"><span class="annot"><span class="annottext">o :: Name
</span><a href="#local-6989586621679082722"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679082721"><span class="annot"><span class="annottext">r :: Type
</span><a href="#local-6989586621679082721"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082722"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082723"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
</span><span class="hs-operator hs-var">`appT`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082721"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-1479"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082720"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082720"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082719"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082719"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Q Type -&gt; Q (Type -&gt; Type)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082720"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Q (Type -&gt; Type) -&gt; Q Type -&gt; Q Type
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082719"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1480"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span id="local-6989586621679082718"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082718"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Q Type -&gt; Q Type
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">InfixList -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-var">resolveInfixT1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082718"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
# if MIN_VERSION_template_haskell(2,15,0)
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082715"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082715"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppKindT`</span></span><span> </span><span id="local-6989586621679082714"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082714"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
</span><span class="hs-identifier hs-var">appKindT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082715"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082714"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1483"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679082713"><span class="annot"><span class="annottext">n :: String
</span><a href="#local-6989586621679082713"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082712"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082712"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1484"></span><span>                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Type -&gt; Q Type
</span><span class="hs-identifier hs-var">implicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679082713"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(Q Type -&gt; Q Type) -&gt; Q Type -&gt; Q Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082712"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
# endif
</span><span class="hs-cpp"># if MIN_VERSION_template_haskell(2,16,0)
</span><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-identifier">vs</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">traverse</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">traverseTvbKind</span><span> </span><span class="hs-identifier">resolveInfixT</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">vs</span><span>
</span><span id="line-1488"></span><span>                                             </span><span class="hs-operator">&lt;*&gt;</span><span> </span><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-identifier">t</span><span class="hs-cpp">
# endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT"><span class="hs-identifier hs-var">resolveInfixT</span></a></span><span> </span><span id="local-6989586621679082711"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082711"><span class="hs-identifier hs-var">t</span></a></span></span><span>                 </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082711"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1491"></span><span>
</span><span id="line-1492"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-type">gatherUInfixT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span>
</span><span id="line-1493"></span><span id="gatherUInfixT"><span class="annot"><span class="annottext">gatherUInfixT :: Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var hs-var">gatherUInfixT</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679082710"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082710"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679082709"><span class="annot"><span class="annottext">o :: Name
</span><a href="#local-6989586621679082709"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679082708"><span class="annot"><span class="annottext">r :: Type
</span><a href="#local-6989586621679082708"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">InfixList -&gt; Name -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082710"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082709"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082708"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1494"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#gatherUInfixT"><span class="hs-identifier hs-var">gatherUInfixT</span></a></span><span> </span><span id="local-6989586621679082706"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082706"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082706"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1495"></span><span>
</span><span id="line-1496"></span><span class="hs-comment">-- This can fail due to incompatible fixities</span><span>
</span><span id="line-1497"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-type">resolveInfixT1</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span>
</span><span id="line-1498"></span><span id="resolveInfixT1"><span class="annot"><span class="annottext">resolveInfixT1 :: InfixList -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveInfixT1"><span class="hs-identifier hs-var hs-var">resolveInfixT1</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679082704"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1499"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1500"></span><span>    </span><span class="annot"><a href="#local-6989586621679082704"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span>
</span><span id="line-1501"></span><span>    </span><span id="local-6989586621679082704"><span class="annot"><span class="annottext">go :: [(Type, Name, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679082704"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679082703"><span class="annot"><span class="annottext">ts :: [(Type, Name, Fixity)]
</span><a href="#local-6989586621679082703"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-type">ILNil</span></a></span><span> </span><span id="local-6989586621679082702"><span class="annot"><span class="annottext">u :: Type
</span><a href="#local-6989586621679082702"><span class="hs-identifier hs-var">u</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; (Type, Name, Fixity) -&gt; Type)
-&gt; Type -&gt; [(Type, Name, Fixity)] -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679082701"><span class="annot"><span class="annottext">acc :: Type
</span><a href="#local-6989586621679082701"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082700"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082700"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679082699"><span class="annot"><span class="annottext">o :: Name
</span><a href="#local-6989586621679082699"><span class="hs-identifier hs-var">o</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082699"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082700"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082701"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082702"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Fixity)]
</span><a href="#local-6989586621679082703"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1502"></span><span>    </span><span class="annot"><a href="#local-6989586621679082704"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082698"><span class="annot"><span class="annottext">ts :: [(Type, Name, Fixity)]
</span><a href="#local-6989586621679082698"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-type">ILCons</span></a></span><span> </span><span id="local-6989586621679082696"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082696"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679082695"><span class="annot"><span class="annottext">o :: Name
</span><a href="#local-6989586621679082695"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679082694"><span class="annot"><span class="annottext">r :: InfixList
</span><a href="#local-6989586621679082694"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1503"></span><span>      </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679082693"><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082693"><span class="hs-identifier hs-var">ofx</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; Maybe Fixity -&gt; Fixity
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><span class="hs-identifier hs-var">defaultFixity</span></span><span> </span><span class="annot"><span class="annottext">(Maybe Fixity -&gt; Fixity) -&gt; Q (Maybe Fixity) -&gt; Q Fixity
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-var">reifyFixityCompat</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082695"><span class="hs-identifier hs-var">o</span></a></span><span>
</span><span id="line-1504"></span><span>         </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082691"><span class="annot"><span class="annottext">push :: Q Type
</span><a href="#local-6989586621679082691"><span class="hs-identifier hs-var hs-var">push</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679082704"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082696"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082695"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082693"><span class="hs-identifier hs-var">ofx</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">(Type, Name, Fixity)
-&gt; [(Type, Name, Fixity)] -&gt; [(Type, Name, Fixity)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(Type, Name, Fixity)]
</span><a href="#local-6989586621679082698"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679082694"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-1505"></span><span>         </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Fixity)]
</span><a href="#local-6989586621679082698"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1506"></span><span>           </span><span class="hs-special">(</span><span id="local-6989586621679082690"><span class="annot"><span class="annottext">l1 :: Type
</span><a href="#local-6989586621679082690"><span class="hs-identifier hs-var">l1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679082689"><span class="annot"><span class="annottext">o1 :: Name
</span><a href="#local-6989586621679082689"><span class="hs-identifier hs-var">o1</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679082688"><span class="annot"><span class="annottext">o1fx :: Fixity
</span><a href="#local-6989586621679082688"><span class="hs-identifier hs-var">o1fx</span></a></span></span><span class="hs-special">)</span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679082687"><span class="annot"><span class="annottext">ts' :: [(Type, Name, Fixity)]
</span><a href="#local-6989586621679082687"><span class="hs-identifier hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1507"></span><span>             </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; Fixity -&gt; Maybe Bool
</span><a href="#local-6989586621679082686"><span class="hs-identifier hs-var">compareFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082688"><span class="hs-identifier hs-var">o1fx</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082693"><span class="hs-identifier hs-var">ofx</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1508"></span><span>               </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">True</span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">[(Type, Name, Fixity)] -&gt; InfixList -&gt; Q Type
</span><a href="#local-6989586621679082704"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082689"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082690"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`AppT`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082696"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082695"><span class="hs-identifier hs-var">o</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082693"><span class="hs-identifier hs-var">ofx</span></a></span><span class="hs-special">)</span><span class="annot"><span class="annottext">(Type, Name, Fixity)
-&gt; [(Type, Name, Fixity)] -&gt; [(Type, Name, Fixity)]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[(Type, Name, Fixity)]
</span><a href="#local-6989586621679082687"><span class="hs-identifier hs-var">ts'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679082694"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-1509"></span><span>               </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">False</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679082691"><span class="hs-identifier hs-var">push</span></a></span><span>
</span><span id="line-1510"></span><span>               </span><span class="annot"><span class="hs-identifier hs-type">Nothing</span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Type
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Fixity -&gt; Name -&gt; Fixity -&gt; String
</span><a href="#local-6989586621679082685"><span class="hs-identifier hs-var">precedenceError</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082689"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082688"><span class="hs-identifier hs-var">o1fx</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082695"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082693"><span class="hs-identifier hs-var">ofx</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1511"></span><span>           </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679082691"><span class="hs-identifier hs-var">push</span></a></span><span>
</span><span id="line-1512"></span><span>
</span><span id="line-1513"></span><span>    </span><span class="annot"><a href="#local-6989586621679082686"><span class="hs-identifier hs-type">compareFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1514"></span><span>    </span><span id="local-6989586621679082686"><span class="annot"><span class="annottext">compareFixity :: Fixity -&gt; Fixity -&gt; Maybe Bool
</span><a href="#local-6989586621679082686"><span class="hs-identifier hs-var hs-var">compareFixity</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082683"><span class="annot"><span class="annottext">n1 :: Int
</span><a href="#local-6989586621679082683"><span class="hs-identifier hs-var">n1</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixL</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082681"><span class="annot"><span class="annottext">n2 :: Int
</span><a href="#local-6989586621679082681"><span class="hs-identifier hs-var">n2</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixL</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082683"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;=</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082681"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1515"></span><span>    </span><span class="annot"><a href="#local-6989586621679082686"><span class="hs-identifier hs-var">compareFixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082680"><span class="annot"><span class="annottext">n1 :: Int
</span><a href="#local-6989586621679082680"><span class="hs-identifier hs-var">n1</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixR</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082678"><span class="annot"><span class="annottext">n2 :: Int
</span><a href="#local-6989586621679082678"><span class="hs-identifier hs-var">n2</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixR</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082680"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Bool
forall a. Ord a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">&gt;</span></span><span>  </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082678"><span class="hs-identifier hs-var">n2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1516"></span><span>    </span><span class="annot"><a href="#local-6989586621679082686"><span class="hs-identifier hs-var">compareFixity</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082676"><span class="annot"><span class="annottext">n1 :: Int
</span><a href="#local-6989586621679082676"><span class="hs-identifier hs-var">n1</span></a></span></span><span> </span><span class="hs-identifier">_</span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082675"><span class="annot"><span class="annottext">n2 :: Int
</span><a href="#local-6989586621679082675"><span class="hs-identifier hs-var">n2</span></a></span></span><span> </span><span class="hs-identifier">_</span><span>     </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1517"></span><span>      </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Int -&gt; Int -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082676"><span class="hs-identifier hs-var">n1</span></a></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082675"><span class="hs-identifier hs-var">n2</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1518"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">GT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-1519"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">LT</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; Maybe Bool
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1520"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">EQ</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe Bool
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1521"></span><span>
</span><span id="line-1522"></span><span>    </span><span class="annot"><a href="#local-6989586621679082685"><span class="hs-identifier hs-type">precedenceError</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1523"></span><span>    </span><span id="local-6989586621679082685"><span class="annot"><span class="annottext">precedenceError :: Name -&gt; Fixity -&gt; Name -&gt; Fixity -&gt; String
</span><a href="#local-6989586621679082685"><span class="hs-identifier hs-var hs-var">precedenceError</span></a></span></span><span> </span><span id="local-6989586621679082673"><span class="annot"><span class="annottext">o1 :: Name
</span><a href="#local-6989586621679082673"><span class="hs-identifier hs-var">o1</span></a></span></span><span> </span><span id="local-6989586621679082672"><span class="annot"><span class="annottext">ofx1 :: Fixity
</span><a href="#local-6989586621679082672"><span class="hs-identifier hs-var">ofx1</span></a></span></span><span> </span><span id="local-6989586621679082671"><span class="annot"><span class="annottext">o2 :: Name
</span><a href="#local-6989586621679082671"><span class="hs-identifier hs-var">o2</span></a></span></span><span> </span><span id="local-6989586621679082670"><span class="annot"><span class="annottext">ofx2 :: Fixity
</span><a href="#local-6989586621679082670"><span class="hs-identifier hs-var">ofx2</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1524"></span><span>      </span><span class="annot"><span class="hs-string">&quot;Precedence parsing error: cannot mix &#8216;&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-1525"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082673"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8217; [&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082672"><span class="hs-identifier hs-var">ofx1</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;] and &#8216;&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-1526"></span><span>      </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082671"><span class="hs-identifier hs-var">o2</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&#8217; [&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var">showFixity</span></a></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><a href="#local-6989586621679082670"><span class="hs-identifier hs-var">ofx2</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span>
</span><span id="line-1527"></span><span>      </span><span class="annot"><span class="hs-string">&quot;] in the same infix type expression&quot;</span></span><span>
</span><span id="line-1528"></span><span>
</span><span id="line-1529"></span><span class="hs-keyword">data</span><span> </span><span id="InfixList"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-var">InfixList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ILCons"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="ILNil"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-var">ILNil</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1530"></span><span>
</span><span id="line-1531"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-type">ilAppend</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixList"><span class="hs-identifier hs-type">InfixList</span></a></span><span>
</span><span id="line-1532"></span><span id="ilAppend"><span class="annot"><span class="annottext">ilAppend :: InfixList -&gt; Name -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var hs-var">ilAppend</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILNil"><span class="hs-identifier hs-type">ILNil</span></a></span><span> </span><span id="local-6989586621679082669"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082669"><span class="hs-identifier hs-var">l</span></a></span></span><span class="hs-special">)</span><span>         </span><span id="local-6989586621679082668"><span class="annot"><span class="annottext">o :: Name
</span><a href="#local-6989586621679082668"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679082667"><span class="annot"><span class="annottext">r :: InfixList
</span><a href="#local-6989586621679082667"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082669"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082668"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679082667"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-1533"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-type">ILCons</span></a></span><span> </span><span id="local-6989586621679082666"><span class="annot"><span class="annottext">l1 :: Type
</span><a href="#local-6989586621679082666"><span class="hs-identifier hs-var">l1</span></a></span></span><span> </span><span id="local-6989586621679082665"><span class="annot"><span class="annottext">o1 :: Name
</span><a href="#local-6989586621679082665"><span class="hs-identifier hs-var">o1</span></a></span></span><span> </span><span id="local-6989586621679082664"><span class="annot"><span class="annottext">r1 :: InfixList
</span><a href="#local-6989586621679082664"><span class="hs-identifier hs-var">r1</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082663"><span class="annot"><span class="annottext">o :: Name
</span><a href="#local-6989586621679082663"><span class="hs-identifier hs-var">o</span></a></span></span><span> </span><span id="local-6989586621679082662"><span class="annot"><span class="annottext">r :: InfixList
</span><a href="#local-6989586621679082662"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ILCons"><span class="hs-identifier hs-var">ILCons</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082666"><span class="hs-identifier hs-var">l1</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082665"><span class="hs-identifier hs-var">o1</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">InfixList -&gt; Name -&gt; InfixList -&gt; InfixList
</span><a href="Language.Haskell.TH.Datatype.html#ilAppend"><span class="hs-identifier hs-var">ilAppend</span></a></span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679082664"><span class="hs-identifier hs-var">r1</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082663"><span class="hs-identifier hs-var">o</span></a></span><span> </span><span class="annot"><span class="annottext">InfixList
</span><a href="#local-6989586621679082662"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">

#else
</span><span class="hs-comment">-- older template-haskell packages don't have UInfixT</span><span>
</span><span id="line-1537"></span><span class="hs-identifier">resolveInfixT</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">return</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1540"></span><span>
</span><span id="line-1541"></span><span class="hs-comment">-- | Render a 'Fixity' as it would appear in Haskell source.</span><span>
</span><span id="line-1542"></span><span class="hs-comment">--</span><span>
</span><span id="line-1543"></span><span class="hs-comment">-- Example: @infixl 5@</span><span>
</span><span id="line-1544"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-type">showFixity</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1545"></span><span id="showFixity"><span class="annot"><span class="annottext">showFixity :: Fixity -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixity"><span class="hs-identifier hs-var hs-var">showFixity</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span> </span><span id="local-6989586621679082661"><span class="annot"><span class="annottext">n :: Int
</span><a href="#local-6989586621679082661"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082660"><span class="annot"><span class="annottext">d :: FixityDirection
</span><a href="#local-6989586621679082660"><span class="hs-identifier hs-var">d</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">FixityDirection -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a></span><span> </span><span class="annot"><span class="annottext">FixityDirection
</span><a href="#local-6989586621679082660"><span class="hs-identifier hs-var">d</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="hs-string">&quot; &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082661"><span class="hs-identifier hs-var">n</span></a></span><span>
</span><span id="line-1546"></span><span>
</span><span id="line-1547"></span><span>
</span><span id="line-1548"></span><span class="hs-comment">-- | Render a 'FixityDirection' like it would appear in Haskell source.</span><span>
</span><span id="line-1549"></span><span class="hs-comment">--</span><span>
</span><span id="line-1550"></span><span class="hs-comment">-- Examples: @infixl@ @infixr@ @infix@</span><span>
</span><span id="line-1551"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-type">showFixityDirection</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">FixityDirection</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-1552"></span><span id="showFixityDirection"><span class="annot"><span class="annottext">showFixityDirection :: FixityDirection -&gt; String
</span><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var hs-var">showFixityDirection</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixL</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-string">&quot;infixl&quot;</span></span><span>
</span><span id="line-1553"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixR</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-string">&quot;infixr&quot;</span></span><span>
</span><span id="line-1554"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#showFixityDirection"><span class="hs-identifier hs-var">showFixityDirection</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">InfixN</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-string">&quot;infix&quot;</span></span><span>
</span><span id="line-1555"></span><span>
</span><span id="line-1556"></span><span>
</span><span id="line-1557"></span><span class="hs-comment">-- | Extract the type variable name from a 'TyVarBndr' ignoring the</span><span>
</span><span id="line-1558"></span><span class="hs-comment">-- kind signature if one exists.</span><span>
</span><span id="line-1559"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-type">tvName</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>
</span><span id="line-1560"></span><span id="tvName"><span class="annot"><span class="annottext">tvName :: TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var hs-var">tvName</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span>  </span><span id="local-6989586621679082658"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679082658"><span class="hs-identifier hs-var">name</span></a></span></span><span>  </span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082658"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1561"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082657"><span class="annot"><span class="annottext">name :: Name
</span><a href="#local-6989586621679082657"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082657"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-1562"></span><span>
</span><span id="line-1563"></span><span id="local-6989586621679083850"><span id="local-6989586621679083851"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-type">takeFieldNames</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679083851"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679083850"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-1564"></span><span id="takeFieldNames"><span class="annot"><span class="annottext">takeFieldNames :: [(Name, a, b)] -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldNames"><span class="hs-identifier hs-var hs-var">takeFieldNames</span></a></span></span><span> </span><span id="local-6989586621679082656"><span class="annot"><span class="annottext">xs :: [(Name, a, b)]
</span><a href="#local-6989586621679082656"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082655"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082655"><span class="annot"><span class="annottext">a :: Name
</span><a href="#local-6989586621679082655"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(Name, a, b)]
</span><a href="#local-6989586621679082656"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">]</span><span class="hs-cpp">

#if MIN_VERSION_template_haskell(2,11,0)
</span><span id="local-6989586621679083848"><span id="local-6989586621679083849"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-type">takeFieldStrictness</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679083849"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Bang</span></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679083848"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#FieldStrictness"><span class="hs-identifier hs-type">FieldStrictness</span></a></span><span class="hs-special">]</span></span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">takeFieldStrictness</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="hs-identifier">a</span><span class="hs-special">,</span><span class="hs-identifier">Strict</span><span class="hs-special">,</span><span class="hs-identifier">b</span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-identifier">FieldStrictness</span><span class="hs-special">]</span><span class="hs-cpp">
#endif
</span><span id="takeFieldStrictness"><span class="annot"><span class="annottext">takeFieldStrictness :: [(a, Bang, b)] -&gt; [FieldStrictness]
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldStrictness"><span class="hs-identifier hs-var hs-var">takeFieldStrictness</span></a></span></span><span> </span><span id="local-6989586621679082654"><span class="annot"><span class="annottext">xs :: [(a, Bang, b)]
</span><a href="#local-6989586621679082654"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Bang -&gt; FieldStrictness
</span><a href="Language.Haskell.TH.Datatype.html#normalizeStrictness"><span class="hs-identifier hs-var">normalizeStrictness</span></a></span><span> </span><span class="annot"><span class="annottext">Bang
</span><a href="#local-6989586621679082653"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span id="local-6989586621679082653"><span class="annot"><span class="annottext">a :: Bang
</span><a href="#local-6989586621679082653"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(a, Bang, b)]
</span><a href="#local-6989586621679082654"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1572"></span><span>
</span><span id="line-1573"></span><span id="local-6989586621679083846"><span id="local-6989586621679083847"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-type">takeFieldTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621679083847"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span class="annot"><a href="#local-6989586621679083846"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span></span></span><span>
</span><span id="line-1574"></span><span id="takeFieldTypes"><span class="annot"><span class="annottext">takeFieldTypes :: [(a, b, Type)] -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#takeFieldTypes"><span class="hs-identifier hs-var hs-var">takeFieldTypes</span></a></span></span><span> </span><span id="local-6989586621679082652"><span class="annot"><span class="annottext">xs :: [(a, b, Type)]
</span><a href="#local-6989586621679082652"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082651"><span class="hs-identifier hs-var">a</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span class="hs-identifier">_</span><span class="hs-special">,</span><span id="local-6989586621679082651"><span class="annot"><span class="annottext">a :: Type
</span><a href="#local-6989586621679082651"><span class="hs-identifier hs-var">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[(a, b, Type)]
</span><a href="#local-6989586621679082652"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1575"></span><span>
</span><span id="line-1576"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-type">conHasRecord</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1577"></span><span id="conHasRecord"><span class="annot"><span class="annottext">conHasRecord :: Name -&gt; ConstructorInfo -&gt; Bool
</span><a href="Language.Haskell.TH.Datatype.html#conHasRecord"><span class="hs-identifier hs-var hs-var">conHasRecord</span></a></span></span><span> </span><span id="local-6989586621679082650"><span class="annot"><span class="annottext">recName :: Name
</span><a href="#local-6989586621679082650"><span class="hs-identifier hs-var">recName</span></a></span></span><span> </span><span id="local-6989586621679082649"><span class="annot"><span class="annottext">info :: ConstructorInfo
</span><a href="#local-6989586621679082649"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1578"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; ConstructorVariant
</span><a href="Language.Haskell.TH.Datatype.html#constructorVariant"><span class="hs-identifier hs-var hs-var">constructorVariant</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082649"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1579"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#NormalConstructor"><span class="hs-identifier hs-type">NormalConstructor</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1580"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#InfixConstructor"><span class="hs-identifier hs-type">InfixConstructor</span></a></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-1581"></span><span>    </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#RecordConstructor"><span class="hs-identifier hs-type">RecordConstructor</span></a></span><span> </span><span id="local-6989586621679082648"><span class="annot"><span class="annottext">fields :: [Name]
</span><a href="#local-6989586621679082648"><span class="hs-identifier hs-var">fields</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082650"><span class="hs-identifier hs-var">recName</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082648"><span class="hs-identifier hs-var">fields</span></a></span><span>
</span><span id="line-1582"></span><span>
</span><span id="line-1583"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-1584"></span><span>
</span><span id="line-1585"></span><span class="hs-comment">-- | Add universal quantifier for all free variables in the type. This is</span><span>
</span><span id="line-1586"></span><span class="hs-comment">-- useful when constructing a type signature for a declaration.</span><span>
</span><span id="line-1587"></span><span class="hs-comment">-- This code is careful to ensure that the order of the variables quantified</span><span>
</span><span id="line-1588"></span><span class="hs-comment">-- is determined by their order of appearance in the type signature. (In</span><span>
</span><span id="line-1589"></span><span class="hs-comment">-- contrast with being dependent upon the Ord instance for 'Name')</span><span>
</span><span id="line-1590"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier hs-type">quantifyType</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1591"></span><span id="quantifyType"><span class="annot"><span class="annottext">quantifyType :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#quantifyType"><span class="hs-identifier hs-var hs-var">quantifyType</span></a></span></span><span> </span><span id="local-6989586621679082647"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082647"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-1592"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082645"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-1593"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082647"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1594"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082644"><span class="annot"><span class="annottext">tvbs' :: [TyVarBndr]
</span><a href="#local-6989586621679082644"><span class="hs-identifier hs-var">tvbs'</span></a></span></span><span> </span><span id="local-6989586621679082643"><span class="annot"><span class="annottext">ctxt' :: Cxt
</span><a href="#local-6989586621679082643"><span class="hs-identifier hs-var">ctxt'</span></a></span></span><span> </span><span id="local-6989586621679082642"><span class="annot"><span class="annottext">t' :: Type
</span><a href="#local-6989586621679082642"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082647"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-comment">-- Collapse two consecutive foralls (#63)</span><span>
</span><span id="line-1595"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082645"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082644"><span class="hs-identifier hs-var">tvbs'</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082643"><span class="hs-identifier hs-var">ctxt'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082642"><span class="hs-identifier hs-var">t'</span></a></span><span>
</span><span id="line-1596"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1597"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082645"><span class="hs-identifier hs-var">tvbs</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082647"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1598"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1599"></span><span>    </span><span id="local-6989586621679082645"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082645"><span class="hs-identifier hs-var hs-var">tvbs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var">freeVariablesWellScoped</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082647"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1600"></span><span>
</span><span id="line-1601"></span><span class="hs-comment">-- | Take a list of 'Type's, find their free variables, and sort them</span><span>
</span><span id="line-1602"></span><span class="hs-comment">-- according to dependency order.</span><span>
</span><span id="line-1603"></span><span class="hs-comment">--</span><span>
</span><span id="line-1604"></span><span class="hs-comment">-- As an example of how this function works, consider the following type:</span><span>
</span><span id="line-1605"></span><span class="hs-comment">--</span><span>
</span><span id="line-1606"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1607"></span><span class="hs-comment">-- Proxy (a :: k)</span><span>
</span><span id="line-1608"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-1609"></span><span class="hs-comment">--</span><span>
</span><span id="line-1610"></span><span class="hs-comment">-- Calling 'freeVariables' on this type would yield @[a, k]@, since that is</span><span>
</span><span id="line-1611"></span><span class="hs-comment">-- the order in which those variables appear in a left-to-right fashion. But</span><span>
</span><span id="line-1612"></span><span class="hs-comment">-- this order does not preserve the fact that @k@ is the kind of @a@. Moreover,</span><span>
</span><span id="line-1613"></span><span class="hs-comment">-- if you tried writing the type @forall a k. Proxy (a :: k)@, GHC would reject</span><span>
</span><span id="line-1614"></span><span class="hs-comment">-- this, since GHC would demand that @k@ come before @a@.</span><span>
</span><span id="line-1615"></span><span class="hs-comment">--</span><span>
</span><span id="line-1616"></span><span class="hs-comment">-- 'freeVariablesWellScoped' orders the free variables of a type in a way that</span><span>
</span><span id="line-1617"></span><span class="hs-comment">-- preserves this dependency ordering. If one were to call</span><span>
</span><span id="line-1618"></span><span class="hs-comment">-- 'freeVariablesWellScoped' on the type above, it would return</span><span>
</span><span id="line-1619"></span><span class="hs-comment">-- @[k, (a :: k)]@. (This is why 'freeVariablesWellScoped' returns a list of</span><span>
</span><span id="line-1620"></span><span class="hs-comment">-- 'TyVarBndr's instead of 'Name's, since it must make it explicit that @k@</span><span>
</span><span id="line-1621"></span><span class="hs-comment">-- is the kind of @a@.)</span><span>
</span><span id="line-1622"></span><span class="hs-comment">--</span><span>
</span><span id="line-1623"></span><span class="hs-comment">-- 'freeVariablesWellScoped' guarantees the free variables returned will be</span><span>
</span><span id="line-1624"></span><span class="hs-comment">-- ordered such that:</span><span>
</span><span id="line-1625"></span><span class="hs-comment">--</span><span>
</span><span id="line-1626"></span><span class="hs-comment">-- 1. Whenever an explicit kind signature of the form @(A :: K)@ is</span><span>
</span><span id="line-1627"></span><span class="hs-comment">--    encountered, the free variables of @K@ will always appear to the left of</span><span>
</span><span id="line-1628"></span><span class="hs-comment">--    the free variables of @A@ in the returned result.</span><span>
</span><span id="line-1629"></span><span class="hs-comment">--</span><span>
</span><span id="line-1630"></span><span class="hs-comment">-- 2. The constraint in (1) notwithstanding, free variables will appear in</span><span>
</span><span id="line-1631"></span><span class="hs-comment">--    left-to-right order of their original appearance.</span><span>
</span><span id="line-1632"></span><span class="hs-comment">--</span><span>
</span><span id="line-1633"></span><span class="hs-comment">-- On older GHCs, this takes measures to avoid returning explicitly bound</span><span>
</span><span id="line-1634"></span><span class="hs-comment">-- kind variables, which was not possible before @TypeInType@.</span><span>
</span><span id="line-1635"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-type">freeVariablesWellScoped</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>
</span><span id="line-1636"></span><span id="freeVariablesWellScoped"><span class="annot"><span class="annottext">freeVariablesWellScoped :: Cxt -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariablesWellScoped"><span class="hs-identifier hs-var hs-var">freeVariablesWellScoped</span></a></span></span><span> </span><span id="local-6989586621679082641"><span class="annot"><span class="annottext">tys :: Cxt
</span><a href="#local-6989586621679082641"><span class="hs-identifier hs-var">tys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1637"></span><span>  </span><span class="hs-keyword">let</span><span> </span><span class="annot"><a href="#local-6989586621679082640"><span class="hs-identifier hs-type">fvs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-1638"></span><span>      </span><span id="local-6989586621679082640"><span class="annot"><span class="annottext">fvs :: [Name]
</span><a href="#local-6989586621679082640"><span class="hs-identifier hs-var hs-var">fvs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082641"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-1639"></span><span>
</span><span id="line-1640"></span><span>      </span><span class="annot"><a href="#local-6989586621679082639"><span class="hs-identifier hs-type">varKindSigs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1641"></span><span>      </span><span id="local-6989586621679082639"><span class="annot"><span class="annottext">varKindSigs :: Map Name Type
</span><a href="#local-6989586621679082639"><span class="hs-identifier hs-var hs-var">varKindSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Map Name Type) -&gt; Cxt -&gt; Map Name Type
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082641"><span class="hs-identifier hs-var">tys</span></a></span><span>
</span><span id="line-1642"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-1643"></span><span>          </span><span class="annot"><a href="#local-6989586621679082638"><span class="hs-identifier hs-type">go_ty</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span>
</span><span id="line-1644"></span><span>          </span><span id="local-6989586621679082638"><span class="annot"><span class="annottext">go_ty :: Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var hs-var">go_ty</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082637"><span class="annot"><span class="annottext">tvbs :: [TyVarBndr]
</span><a href="#local-6989586621679082637"><span class="hs-identifier hs-var">tvbs</span></a></span></span><span> </span><span id="local-6989586621679082636"><span class="annot"><span class="annottext">ctxt :: Cxt
</span><a href="#local-6989586621679082636"><span class="hs-identifier hs-var">ctxt</span></a></span></span><span> </span><span id="local-6989586621679082635"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082635"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1645"></span><span>            </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [TyVarBndr] -&gt; Map Name Type
forall (t :: * -&gt; *) a b.
Foldable t =&gt;
(a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldr</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621679082634"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082634"><span class="hs-identifier hs-var">tvb</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082634"><span class="hs-identifier hs-var">tvb</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1646"></span><span>                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Map Name Type) -&gt; Cxt -&gt; Map Name Type
forall (t :: * -&gt; *) m a.
(Foldable t, Monoid m) =&gt;
(a -&gt; m) -&gt; t a -&gt; m
</span><span class="hs-identifier hs-var">foldMap</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082632"><span class="hs-identifier hs-var">go_pred</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082636"><span class="hs-identifier hs-var">ctxt</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082635"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082637"><span class="hs-identifier hs-var">tvbs</span></a></span><span>
</span><span id="line-1647"></span><span>          </span><span class="annot"><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082631"><span class="annot"><span class="annottext">t1 :: Type
</span><a href="#local-6989586621679082631"><span class="hs-identifier hs-var">t1</span></a></span></span><span> </span><span id="local-6989586621679082630"><span class="annot"><span class="annottext">t2 :: Type
</span><a href="#local-6989586621679082630"><span class="hs-identifier hs-var">t2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082631"><span class="hs-identifier hs-var">t1</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082630"><span class="hs-identifier hs-var">t2</span></a></span><span>
</span><span id="line-1648"></span><span>          </span><span class="annot"><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082629"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082629"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082628"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082628"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1649"></span><span>            </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082627"><span class="annot"><span class="annottext">kSigs :: Map Name Type
</span><a href="#local-6989586621679082627"><span class="hs-identifier hs-var hs-var">kSigs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span>                  </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082628"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-cpp">
#else
</span><span>                  </span><span class="hs-identifier">mempty</span><span class="hs-cpp">
#endif
</span><span>            </span><span class="hs-keyword">in</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082629"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1656"></span><span>                 </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082626"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082626"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.insert</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082626"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082628"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082627"><span class="hs-identifier hs-var">kSigs</span></a></span><span>
</span><span id="line-1657"></span><span>                 </span><span class="hs-identifier">_</span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082629"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082627"><span class="hs-identifier hs-var">kSigs</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,15,0)
</span><span>          </span><span class="annot"><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679082625"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082625"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082624"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082624"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082625"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall a. Monoid a =&gt; a -&gt; a -&gt; a
</span><span class="hs-operator hs-var">`mappend`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082624"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1660"></span><span>          </span><span class="annot"><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679082623"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082623"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082623"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>          </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-identifier">tvbs</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1664"></span><span>            </span><span class="hs-identifier">foldr</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span class="hs-identifier">tvb</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Map.delete</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">tvName</span><span> </span><span class="hs-identifier">tvb</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">tvbs</span><span class="hs-cpp">
#endif
</span><span>          </span><span class="annot"><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span>
</span><span id="line-1667"></span><span>
</span><span id="line-1668"></span><span>          </span><span class="annot"><a href="#local-6989586621679082632"><span class="hs-identifier hs-type">go_pred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span>          </span><span id="local-6989586621679082632"><span class="annot"><span class="annottext">go_pred :: Type -&gt; Map Name Type
</span><a href="#local-6989586621679082632"><span class="hs-identifier hs-var hs-var">go_pred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Map Name Type
</span><a href="#local-6989586621679082638"><span class="hs-identifier hs-var">go_ty</span></a></span><span class="hs-cpp">
#else
</span><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ts</span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">foldMap</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">ts</span><span>
</span><span id="line-1673"></span><span>          </span><span class="hs-identifier">go_pred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-identifier">t2</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t1</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">mappend</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">go_ty</span><span> </span><span class="hs-identifier">t2</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1676"></span><span>      </span><span class="hs-comment">-- | Do a topological sort on a list of tyvars,</span><span>
</span><span id="line-1677"></span><span>      </span><span class="hs-comment">--   so that binders occur before occurrences</span><span>
</span><span id="line-1678"></span><span>      </span><span class="hs-comment">-- E.g. given  [ a::k, k::*, b::k ]</span><span>
</span><span id="line-1679"></span><span>      </span><span class="hs-comment">-- it'll return a well-scoped list [ k::*, a::k, b::k ]</span><span>
</span><span id="line-1680"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-1681"></span><span>      </span><span class="hs-comment">-- This is a deterministic sorting operation</span><span>
</span><span id="line-1682"></span><span>      </span><span class="hs-comment">-- (that is, doesn't depend on Uniques).</span><span>
</span><span id="line-1683"></span><span>      </span><span class="hs-comment">--</span><span>
</span><span id="line-1684"></span><span>      </span><span class="hs-comment">-- It is also meant to be stable: that is, variables should not</span><span>
</span><span id="line-1685"></span><span>      </span><span class="hs-comment">-- be reordered unnecessarily.</span><span>
</span><span id="line-1686"></span><span>      </span><span class="annot"><a href="#local-6989586621679082622"><span class="hs-identifier hs-type">scopedSort</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-1687"></span><span>      </span><span id="local-6989586621679082622"><span class="annot"><span class="annottext">scopedSort :: [Name] -&gt; [Name]
</span><a href="#local-6989586621679082622"><span class="hs-identifier hs-var hs-var">scopedSort</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Set Name] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679082621"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1688"></span><span>
</span><span id="line-1689"></span><span>      </span><span class="annot"><a href="#local-6989586621679082621"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- already sorted, in reverse order</span><span>
</span><span id="line-1690"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- each set contains all the variables which must be placed</span><span>
</span><span id="line-1691"></span><span>                       </span><span class="hs-comment">-- before the tv corresponding to the set; they are accumulations</span><span>
</span><span id="line-1692"></span><span>                       </span><span class="hs-comment">-- of the fvs in the sorted tvs' kinds</span><span>
</span><span id="line-1693"></span><span>
</span><span id="line-1694"></span><span>                       </span><span class="hs-comment">-- This list is in 1-to-1 correspondence with the sorted tyvars</span><span>
</span><span id="line-1695"></span><span>                       </span><span class="hs-comment">-- INVARIANT:</span><span>
</span><span id="line-1696"></span><span>                       </span><span class="hs-comment">--   all (\tl -&gt; all (`isSubsetOf` head tl) (tail tl)) (tails fv_list)</span><span>
</span><span id="line-1697"></span><span>                       </span><span class="hs-comment">-- That is, each set in the list is a superset of all later sets.</span><span>
</span><span id="line-1698"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- yet to be sorted</span><span>
</span><span id="line-1699"></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-1700"></span><span>      </span><span id="local-6989586621679082621"><span class="annot"><span class="annottext">go :: [Name] -&gt; [Set Name] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679082621"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679082620"><span class="annot"><span class="annottext">acc :: [Name]
</span><a href="#local-6989586621679082620"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span id="local-6989586621679082619"><span class="annot"><span class="annottext">_fv_list :: [Set Name]
</span><a href="#local-6989586621679082619"><span class="hs-identifier hs-var">_fv_list</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. [a] -&gt; [a]
</span><span class="hs-identifier hs-var">reverse</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082620"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-1701"></span><span>      </span><span class="annot"><a href="#local-6989586621679082621"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082618"><span class="annot"><span class="annottext">acc :: [Name]
</span><a href="#local-6989586621679082618"><span class="hs-identifier hs-var">acc</span></a></span></span><span>  </span><span id="local-6989586621679082617"><span class="annot"><span class="annottext">fv_list :: [Set Name]
</span><a href="#local-6989586621679082617"><span class="hs-identifier hs-var">fv_list</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082616"><span class="annot"><span class="annottext">tv :: Name
</span><a href="#local-6989586621679082616"><span class="hs-identifier hs-var">tv</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679082615"><span class="annot"><span class="annottext">tvs :: [Name]
</span><a href="#local-6989586621679082615"><span class="hs-identifier hs-var">tvs</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1702"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Set Name] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679082621"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082614"><span class="hs-identifier hs-var">acc'</span></a></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679082613"><span class="hs-identifier hs-var">fv_list'</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082615"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-1703"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-1704"></span><span>          </span><span class="hs-special">(</span><span id="local-6989586621679082614"><span class="annot"><span class="annottext">acc' :: [Name]
</span><a href="#local-6989586621679082614"><span class="hs-identifier hs-var">acc'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082613"><span class="annot"><span class="annottext">fv_list' :: [Set Name]
</span><a href="#local-6989586621679082613"><span class="hs-identifier hs-var">fv_list'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Set Name] -&gt; ([Name], [Set Name])
</span><a href="#local-6989586621679082612"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082616"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082618"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679082617"><span class="hs-identifier hs-var">fv_list</span></a></span><span>
</span><span id="line-1705"></span><span>
</span><span id="line-1706"></span><span>      </span><span class="annot"><a href="#local-6989586621679082612"><span class="hs-identifier hs-type">insert</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>       </span><span class="hs-comment">-- var to insert</span><span>
</span><span id="line-1707"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>     </span><span class="hs-comment">-- sorted list, in reverse order</span><span>
</span><span id="line-1708"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">-- list of fvs, as above</span><span>
</span><span id="line-1709"></span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Set</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span>   </span><span class="hs-comment">-- augmented lists</span><span>
</span><span id="line-1710"></span><span>      </span><span id="local-6989586621679082612"><span class="annot"><span class="annottext">insert :: Name -&gt; [Name] -&gt; [Set Name] -&gt; ([Name], [Set Name])
</span><a href="#local-6989586621679082612"><span class="hs-identifier hs-var hs-var">insert</span></a></span></span><span> </span><span id="local-6989586621679082611"><span class="annot"><span class="annottext">tv :: Name
</span><a href="#local-6989586621679082611"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>     </span><span class="hs-special">[</span><span class="hs-special">]</span><span>         </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082611"><span class="hs-identifier hs-var">tv</span></a></span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name -&gt; Set Name
</span><a href="#local-6989586621679082610"><span class="hs-identifier hs-var">kindFVSet</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082611"><span class="hs-identifier hs-var">tv</span></a></span><span class="hs-special">]</span><span class="hs-special">)</span><span>
</span><span id="line-1711"></span><span>      </span><span class="annot"><a href="#local-6989586621679082612"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span id="local-6989586621679082609"><span class="annot"><span class="annottext">tv :: Name
</span><a href="#local-6989586621679082609"><span class="hs-identifier hs-var">tv</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082608"><span class="annot"><span class="annottext">a :: Name
</span><a href="#local-6989586621679082608"><span class="hs-identifier hs-var">a</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679082607"><span class="annot"><span class="annottext">as :: [Name]
</span><a href="#local-6989586621679082607"><span class="hs-keyword hs-var">as</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082606"><span class="annot"><span class="annottext">fvs :: Set Name
</span><a href="#local-6989586621679082606"><span class="hs-identifier hs-var">fvs</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679082605"><span class="annot"><span class="annottext">fvss :: [Set Name]
</span><a href="#local-6989586621679082605"><span class="hs-identifier hs-var">fvss</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1712"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082609"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name -&gt; Bool
forall a. Ord a =&gt; a -&gt; Set a -&gt; Bool
</span><span class="hs-operator hs-var">`Set.member`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679082606"><span class="hs-identifier hs-var">fvs</span></a></span><span>
</span><span id="line-1713"></span><span>        </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082603"><span class="annot"><span class="annottext">as' :: [Name]
</span><a href="#local-6989586621679082603"><span class="hs-identifier hs-var">as'</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679082602"><span class="annot"><span class="annottext">fvss' :: [Set Name]
</span><a href="#local-6989586621679082602"><span class="hs-identifier hs-var">fvss'</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Set Name] -&gt; ([Name], [Set Name])
</span><a href="#local-6989586621679082612"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082609"><span class="hs-identifier hs-var">tv</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082607"><span class="hs-keyword hs-var">as</span></a></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679082605"><span class="hs-identifier hs-var">fvss</span></a></span><span>
</span><span id="line-1714"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082608"><span class="hs-identifier hs-var">a</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082603"><span class="hs-identifier hs-var">as'</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679082606"><span class="hs-identifier hs-var">fvs</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; Set Name -&gt; Set Name
forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><span class="hs-operator hs-var">`Set.union`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679082600"><span class="hs-identifier hs-var">fv_tv</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; [Set Name] -&gt; [Set Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679082602"><span class="hs-identifier hs-var">fvss'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1715"></span><span>
</span><span id="line-1716"></span><span>        </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>
</span><span id="line-1717"></span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082609"><span class="hs-identifier hs-var">tv</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082608"><span class="hs-identifier hs-var">a</span></a></span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; [Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082607"><span class="hs-keyword hs-var">as</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679082606"><span class="hs-identifier hs-var">fvs</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; Set Name -&gt; Set Name
forall a. Ord a =&gt; Set a -&gt; Set a -&gt; Set a
</span><span class="hs-operator hs-var">`Set.union`</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679082600"><span class="hs-identifier hs-var">fv_tv</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; [Set Name] -&gt; [Set Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">Set Name
</span><a href="#local-6989586621679082606"><span class="hs-identifier hs-var">fvs</span></a></span><span> </span><span class="annot"><span class="annottext">Set Name -&gt; [Set Name] -&gt; [Set Name]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[Set Name]
</span><a href="#local-6989586621679082605"><span class="hs-identifier hs-var">fvss</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1718"></span><span>        </span><span class="hs-keyword">where</span><span>
</span><span id="line-1719"></span><span>          </span><span id="local-6989586621679082600"><span class="annot"><span class="annottext">fv_tv :: Set Name
</span><a href="#local-6989586621679082600"><span class="hs-identifier hs-var hs-var">fv_tv</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Set Name
</span><a href="#local-6989586621679082610"><span class="hs-identifier hs-var">kindFVSet</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082609"><span class="hs-identifier hs-var">tv</span></a></span><span>
</span><span id="line-1720"></span><span>
</span><span id="line-1721"></span><span>         </span><span class="hs-comment">-- lists not in correspondence</span><span>
</span><span id="line-1722"></span><span>      </span><span class="annot"><a href="#local-6989586621679082612"><span class="hs-identifier hs-var">insert</span></a></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; ([Name], [Set Name])
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="hs-string">&quot;scopedSort&quot;</span></span><span>
</span><span id="line-1723"></span><span>
</span><span id="line-1724"></span><span>      </span><span id="local-6989586621679082610"><span class="annot"><span class="annottext">kindFVSet :: Name -&gt; Set Name
</span><a href="#local-6989586621679082610"><span class="hs-identifier hs-var hs-var">kindFVSet</span></a></span></span><span> </span><span id="local-6989586621679082599"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082599"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1725"></span><span>        </span><span class="annot"><span class="annottext">Set Name -&gt; (Type -&gt; Set Name) -&gt; Maybe Type -&gt; Set Name
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="annot"><span class="annottext">Set Name
forall a. Set a
</span><span class="hs-identifier hs-var">Set.empty</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[Name] -&gt; Set Name
forall a. Ord a =&gt; [a] -&gt; Set a
</span><span class="hs-identifier hs-var">Set.fromList</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; Set Name) -&gt; (Type -&gt; [Name]) -&gt; Type -&gt; Set Name
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082599"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082639"><span class="hs-identifier hs-var">varKindSigs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1726"></span><span>      </span><span id="local-6989586621679082595"><span class="annot"><span class="annottext">ascribeWithKind :: Name -&gt; TyVarBndr
</span><a href="#local-6989586621679082595"><span class="hs-identifier hs-var hs-var">ascribeWithKind</span></a></span></span><span> </span><span id="local-6989586621679082594"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082594"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1727"></span><span>        </span><span class="annot"><span class="annottext">TyVarBndr -&gt; (Type -&gt; TyVarBndr) -&gt; Maybe Type -&gt; TyVarBndr
forall b a. b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
</span><span class="hs-identifier hs-var">maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">PlainTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082594"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082594"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Maybe Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Map.lookup</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082594"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082639"><span class="hs-identifier hs-var">varKindSigs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1728"></span><span>
</span><span id="line-1729"></span><span>      </span><span class="hs-comment">-- An annoying wrinkle: GHCs before 8.0 don't support explicitly</span><span>
</span><span id="line-1730"></span><span>      </span><span class="hs-comment">-- quantifying kinds, so something like @forall k (a :: k)@ would be</span><span>
</span><span id="line-1731"></span><span>      </span><span class="hs-comment">-- rejected. To work around this, we filter out any binders whose names</span><span>
</span><span id="line-1732"></span><span>      </span><span class="hs-comment">-- also appear in a kind on old GHCs.</span><span>
</span><span id="line-1733"></span><span>      </span><span id="local-6989586621679082593"><span class="annot"><span class="annottext">isKindBinderOnOldGHCs :: b -&gt; Bool
</span><a href="#local-6989586621679082593"><span class="hs-identifier hs-var hs-var">isKindBinderOnOldGHCs</span></a></span></span><span class="hs-cpp">
#if __GLASGOW_HASKELL__ &gt;= 800
</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool -&gt; b -&gt; Bool
forall a b. a -&gt; b -&gt; a
</span><span class="hs-identifier hs-var">const</span></span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span class="hs-cpp">
#else
</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-special">`</span><span class="hs-identifier">elem</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">kindVars</span><span class="hs-special">)</span><span>
</span><span id="line-1738"></span><span>          </span><span class="hs-keyword">where</span><span>
</span><span id="line-1739"></span><span>            </span><span class="hs-identifier">kindVars</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-identifier">Map.elems</span><span> </span><span class="hs-identifier">varKindSigs</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1742"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">(Name -&gt; TyVarBndr) -&gt; [Name] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; TyVarBndr
</span><a href="#local-6989586621679082595"><span class="hs-identifier hs-var">ascribeWithKind</span></a></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [TyVarBndr]) -&gt; [Name] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1743"></span><span>     </span><span class="annot"><span class="annottext">(Name -&gt; Bool) -&gt; [Name] -&gt; [Name]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool) -&gt; (Name -&gt; Bool) -&gt; Name -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Bool
forall b. b -&gt; Bool
</span><a href="#local-6989586621679082593"><span class="hs-identifier hs-var">isKindBinderOnOldGHCs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Name]) -&gt; [Name] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-1744"></span><span>     </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
</span><a href="#local-6989586621679082622"><span class="hs-identifier hs-var">scopedSort</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082640"><span class="hs-identifier hs-var">fvs</span></a></span><span>
</span><span id="line-1745"></span><span>
</span><span id="line-1746"></span><span class="hs-comment">-- | Substitute all of the free variables in a type with fresh ones</span><span>
</span><span id="line-1747"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier hs-type">freshenFreeVariables</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1748"></span><span id="freshenFreeVariables"><span class="annot"><span class="annottext">freshenFreeVariables :: Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#freshenFreeVariables"><span class="hs-identifier hs-var hs-var">freshenFreeVariables</span></a></span></span><span> </span><span id="local-6989586621679082591"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082591"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1749"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082590"><span class="annot"><span class="annottext">xs :: [(Name, Q Type)]
</span><a href="#local-6989586621679082590"><span class="hs-identifier hs-var hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082589"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">(Name -&gt; Type) -&gt; Q Name -&gt; Q Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Name
</span><span class="hs-identifier hs-var">newName</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082589"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679082589"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082589"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082591"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-1750"></span><span>     </span><span id="local-6989586621679082588"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082588"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Map Name (Q Type) -&gt; Q (Map Name Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><span class="hs-identifier hs-var">T.sequence</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Name, Q Type)] -&gt; Map Name (Q Type)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="annot"><span class="annottext">[(Name, Q Type)]
</span><a href="#local-6989586621679082590"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1751"></span><span>     </span><span class="annot"><span class="annottext">Type -&gt; Q Type
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082588"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082591"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1752"></span><span>
</span><span id="line-1753"></span><span>
</span><span id="line-1754"></span><span class="hs-comment">-- | Class for types that support type variable substitution.</span><span>
</span><span id="line-1755"></span><span class="hs-keyword">class</span><span> </span><span id="TypeSubstitution"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-var">TypeSubstitution</span></a></span></span><span> </span><span id="local-6989586621679083838"><span class="annot"><a href="#local-6989586621679083838"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1756"></span><span>  </span><span class="hs-comment">-- | Apply a type variable substitution.</span><span>
</span><span id="line-1757"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1758"></span><span>  </span><span class="hs-comment">-- Note that 'applySubstitution' is /not/ capture-avoiding. To illustrate</span><span>
</span><span id="line-1759"></span><span>  </span><span class="hs-comment">-- this, observe that if you call this function with the following</span><span>
</span><span id="line-1760"></span><span>  </span><span class="hs-comment">-- substitution:</span><span>
</span><span id="line-1761"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1762"></span><span>  </span><span class="hs-comment">-- * @b :-&gt; a@</span><span>
</span><span id="line-1763"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1764"></span><span>  </span><span class="hs-comment">-- On the following 'Type':</span><span>
</span><span id="line-1765"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1766"></span><span>  </span><span class="hs-comment">-- * @forall a. b@</span><span>
</span><span id="line-1767"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1768"></span><span>  </span><span class="hs-comment">-- Then it will return:</span><span>
</span><span id="line-1769"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1770"></span><span>  </span><span class="hs-comment">-- * @forall a. a@</span><span>
</span><span id="line-1771"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1772"></span><span>  </span><span class="hs-comment">-- However, because the same @a@ type variable was used in the range of the</span><span>
</span><span id="line-1773"></span><span>  </span><span class="hs-comment">-- substitution as was bound by the @forall@, the substituted @a@ is now</span><span>
</span><span id="line-1774"></span><span>  </span><span class="hs-comment">-- captured by the @forall@, resulting in a completely different function.</span><span>
</span><span id="line-1775"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-1776"></span><span>  </span><span class="hs-comment">-- For @th-abstraction@'s purposes, this is acceptable, as it usually only</span><span>
</span><span id="line-1777"></span><span>  </span><span class="hs-comment">-- deals with globally unique type variable 'Name's. If you use</span><span>
</span><span id="line-1778"></span><span>  </span><span class="hs-comment">-- 'applySubstitution' in a context where the 'Name's aren't globally unique,</span><span>
</span><span id="line-1779"></span><span>  </span><span class="hs-comment">-- however, be aware of this potential problem.</span><span>
</span><span id="line-1780"></span><span>  </span><span id="applySubstitution"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-type">applySubstitution</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679083838"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679083838"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-1781"></span><span>  </span><span class="hs-comment">-- | Compute the free type variables</span><span>
</span><span id="line-1782"></span><span>  </span><span id="freeVariables"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-type">freeVariables</span></a></span></span><span>     </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621679083838"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-1783"></span><span>
</span><span id="line-1784"></span><span id="local-6989586621679082587"><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="annot"><a href="#local-6989586621679082587"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="hs-special">[</span><span class="annot"><a href="#local-6989586621679082587"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1785"></span><span>  </span><span id="local-6989586621679082583"><span class="annot"><span class="annottext">freeVariables :: [a] -&gt; [Name]
</span><a href="#local-6989586621679082583"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeVariables</span></a></span></span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">([Name] -&gt; [Name]) -&gt; ([a] -&gt; [Name]) -&gt; [a] -&gt; [Name]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">[[Name]] -&gt; [Name]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="annot"><span class="annottext">([[Name]] -&gt; [Name]) -&gt; ([a] -&gt; [[Name]]) -&gt; [a] -&gt; [Name]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(a -&gt; [Name]) -&gt; [a] -&gt; [[Name]]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span>
</span><span id="line-1786"></span><span>  </span><span id="local-6989586621679082582"><span class="annot"><span class="annottext">applySubstitution :: Map Name Type -&gt; [a] -&gt; [a]
</span><a href="#local-6989586621679082582"><span class="hs-identifier hs-var hs-var hs-var hs-var">applySubstitution</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(a -&gt; a) -&gt; [a] -&gt; [a]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">((a -&gt; a) -&gt; [a] -&gt; [a])
-&gt; (Map Name Type -&gt; a -&gt; a) -&gt; Map Name Type -&gt; [a] -&gt; [a]
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; a -&gt; a
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span></span><span>
</span><span id="line-1787"></span><span>
</span><span id="line-1788"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1789"></span><span>  </span><span id="local-6989586621679082579"><span class="annot"><span class="annottext">applySubstitution :: Map Name Type -&gt; Type -&gt; Type
</span><a href="#local-6989586621679082579"><span class="hs-identifier hs-var hs-var hs-var hs-var">applySubstitution</span></a></span></span><span> </span><span id="local-6989586621679082578"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679082578"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1790"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-1791"></span><span>      </span><span id="local-6989586621679082577"><span class="annot"><span class="annottext">go :: Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082576"><span class="annot"><span class="annottext">tvs :: [TyVarBndr]
</span><a href="#local-6989586621679082576"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679082575"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679082575"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679082574"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082574"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1792"></span><span>        </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; (Map Name Type -&gt; Type) -&gt; Type
forall a. [TyVarBndr] -&gt; (Map Name Type -&gt; a) -&gt; a
</span><a href="#local-6989586621679082573"><span class="hs-identifier hs-var">subst_tvbs</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082576"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="annot"><span class="annottext">((Map Name Type -&gt; Type) -&gt; Type)
-&gt; (Map Name Type -&gt; Type) -&gt; Type
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-glyph">\</span><span id="local-6989586621679082572"><span class="annot"><span class="annottext">subst' :: Map Name Type
</span><a href="#local-6989586621679082572"><span class="hs-identifier hs-var">subst'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1793"></span><span>        </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; Cxt -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ForallT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr -&gt; TyVarBndr) -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; TyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#mapTvbKind"><span class="hs-identifier hs-var">mapTvbKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082572"><span class="hs-identifier hs-var">subst'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082576"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1794"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082572"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082575"><span class="hs-identifier hs-var">context</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1795"></span><span>                </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082572"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082574"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1796"></span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082570"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082570"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679082569"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082569"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082570"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082569"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1797"></span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082568"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082568"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082567"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082567"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082568"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082578"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082567"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-comment">-- k could be Kind</span><span>
</span><span id="line-1798"></span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082566"><span class="annot"><span class="annottext">v :: Name
</span><a href="#local-6989586621679082566"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">)</span><span>        </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Map Name Type -&gt; Type
forall k a. Ord k =&gt; a -&gt; k -&gt; Map k a -&gt; a
</span><span class="hs-identifier hs-var">Map.findWithDefault</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082566"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082566"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082578"><span class="hs-identifier hs-var">subst</span></a></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679082564"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082564"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679082563"><span class="annot"><span class="annottext">c :: Name
</span><a href="#local-6989586621679082563"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679082562"><span class="annot"><span class="annottext">r :: Type
</span><a href="#local-6989586621679082562"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">InfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082564"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082563"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082562"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1801"></span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679082561"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082561"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span id="local-6989586621679082560"><span class="annot"><span class="annottext">c :: Name
</span><a href="#local-6989586621679082560"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679082559"><span class="annot"><span class="annottext">r :: Type
</span><a href="#local-6989586621679082559"><span class="hs-identifier hs-var">r</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Name -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">UInfixT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082561"><span class="hs-identifier hs-var">l</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082560"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082559"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1802"></span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679082558"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082558"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><span class="hs-identifier hs-var">ParensT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082558"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679082557"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082557"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082556"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082556"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppKindT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082557"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082556"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1806"></span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span id="local-6989586621679082555"><span class="annot"><span class="annottext">n :: String
</span><a href="#local-6989586621679082555"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082554"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082554"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-1807"></span><span>                         </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">ImplicitParamT</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679082555"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082554"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>      </span><span class="hs-identifier">go</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-identifier">tvs</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1811"></span><span>        </span><span class="hs-identifier">subst_tvbs</span><span> </span><span class="hs-identifier">tvs</span><span> </span><span class="hs-operator">$</span><span> </span><span class="hs-glyph">\</span><span class="hs-identifier">subst'</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1812"></span><span>        </span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">mapTvbKind</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">subst'</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-identifier">tvs</span><span class="hs-special">)</span><span>
</span><span id="line-1813"></span><span>                   </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">subst'</span><span> </span><span class="hs-identifier">t</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="annot"><a href="#local-6989586621679082577"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679082553"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082553"><span class="hs-identifier hs-var">t</span></a></span></span><span>               </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082553"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-1816"></span><span>
</span><span id="line-1817"></span><span>      </span><span id="local-6989586621679083762"><span class="annot"><a href="#local-6989586621679082573"><span class="hs-identifier hs-type">subst_tvbs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679083762"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679083762"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-1818"></span><span>      </span><span id="local-6989586621679082573"><span class="annot"><span class="annottext">subst_tvbs :: [TyVarBndr] -&gt; (Map Name Type -&gt; a) -&gt; a
</span><a href="#local-6989586621679082573"><span class="hs-identifier hs-var hs-var">subst_tvbs</span></a></span></span><span> </span><span id="local-6989586621679082552"><span class="annot"><span class="annottext">tvs :: [TyVarBndr]
</span><a href="#local-6989586621679082552"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679082551"><span class="annot"><span class="annottext">k :: Map Name Type -&gt; a
</span><a href="#local-6989586621679082551"><span class="hs-identifier hs-var">k</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; a
</span><a href="#local-6989586621679082551"><span class="hs-identifier hs-var">k</span></a></span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; a) -&gt; Map Name Type -&gt; a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; Name -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [Name] -&gt; Map Name Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; Name -&gt; Map Name Type
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082578"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Name) -&gt; [TyVarBndr] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082552"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1819"></span><span>
</span><span id="line-1820"></span><span>  </span><span id="local-6989586621679082549"><span class="annot"><span class="annottext">freeVariables :: Type -&gt; [Name]
</span><a href="#local-6989586621679082549"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeVariables</span></a></span></span><span> </span><span id="local-6989586621679082548"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082548"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1821"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082548"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1822"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ForallT</span></span><span> </span><span id="local-6989586621679082547"><span class="annot"><span class="annottext">tvs :: [TyVarBndr]
</span><a href="#local-6989586621679082547"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679082546"><span class="annot"><span class="annottext">context :: Cxt
</span><a href="#local-6989586621679082546"><span class="hs-identifier hs-var">context</span></a></span></span><span> </span><span id="local-6989586621679082545"><span class="annot"><span class="annottext">t' :: Type
</span><a href="#local-6989586621679082545"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1823"></span><span>          </span><span class="annot"><span class="annottext">[TyVarBndr] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679082544"><span class="hs-identifier hs-var">fvs_under_forall</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082547"><span class="hs-identifier hs-var">tvs</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082546"><span class="hs-identifier hs-var">context</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082545"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1824"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082543"><span class="annot"><span class="annottext">f :: Type
</span><a href="#local-6989586621679082543"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679082542"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082542"><span class="hs-identifier hs-var">x</span></a></span></span><span>      </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082543"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082542"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1825"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082541"><span class="annot"><span class="annottext">t' :: Type
</span><a href="#local-6989586621679082541"><span class="hs-identifier hs-var">t'</span></a></span></span><span> </span><span id="local-6989586621679082540"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082540"><span class="hs-identifier hs-var">k</span></a></span></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082541"><span class="hs-identifier hs-var">t'</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082540"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1826"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082539"><span class="annot"><span class="annottext">v :: Name
</span><a href="#local-6989586621679082539"><span class="hs-identifier hs-var">v</span></a></span></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082539"><span class="hs-identifier hs-var">v</span></a></span><span class="hs-special">]</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span>      </span><span class="annot"><span class="hs-identifier hs-type">InfixT</span></span><span> </span><span id="local-6989586621679082538"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082538"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679082537"><span class="annot"><span class="annottext">r :: Type
</span><a href="#local-6989586621679082537"><span class="hs-identifier hs-var">r</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082538"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082537"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-1829"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">UInfixT</span></span><span> </span><span id="local-6989586621679082536"><span class="annot"><span class="annottext">l :: Type
</span><a href="#local-6989586621679082536"><span class="hs-identifier hs-var">l</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679082535"><span class="annot"><span class="annottext">r :: Type
</span><a href="#local-6989586621679082535"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082536"><span class="hs-identifier hs-var">l</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082535"><span class="hs-identifier hs-var">r</span></a></span><span>
</span><span id="line-1830"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ParensT</span></span><span> </span><span id="local-6989586621679082534"><span class="annot"><span class="annottext">t' :: Type
</span><a href="#local-6989586621679082534"><span class="hs-identifier hs-var">t'</span></a></span></span><span>    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082534"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,15,0)
</span><span>      </span><span class="annot"><span class="hs-identifier hs-type">AppKindT</span></span><span> </span><span id="local-6989586621679082533"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082533"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082532"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082532"><span class="hs-identifier hs-var">k</span></a></span></span><span>  </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082533"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082532"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1834"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">ImplicitParamT</span></span><span> </span><span class="hs-identifier">_</span><span> </span><span id="local-6989586621679082531"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082531"><span class="hs-identifier hs-var">t</span></a></span></span><span>
</span><span id="line-1835"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082531"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-cpp">
#endif
</span><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,16,0)
</span><span>      </span><span class="hs-identifier">ForallVisT</span><span> </span><span class="hs-identifier">tvs</span><span> </span><span class="hs-identifier">t'</span><span>
</span><span id="line-1839"></span><span>                    </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">fvs_under_forall</span><span> </span><span class="hs-identifier">tvs</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">t'</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>      </span><span class="hs-identifier">_</span><span>             </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1842"></span><span>    </span><span class="hs-keyword">where</span><span>
</span><span id="line-1843"></span><span>      </span><span class="annot"><a href="#local-6989586621679082544"><span class="hs-identifier hs-type">fvs_under_forall</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>
</span><span id="line-1844"></span><span>      </span><span id="local-6989586621679082544"><span class="annot"><span class="annottext">fvs_under_forall :: [TyVarBndr] -&gt; [Name] -&gt; [Name]
</span><a href="#local-6989586621679082544"><span class="hs-identifier hs-var hs-var">fvs_under_forall</span></a></span></span><span> </span><span id="local-6989586621679082530"><span class="annot"><span class="annottext">tvs :: [TyVarBndr]
</span><a href="#local-6989586621679082530"><span class="hs-identifier hs-var">tvs</span></a></span></span><span> </span><span id="local-6989586621679082529"><span class="annot"><span class="annottext">fvs :: [Name]
</span><a href="#local-6989586621679082529"><span class="hs-identifier hs-var">fvs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1845"></span><span>        </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Type) -&gt; [TyVarBndr] -&gt; Cxt
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082530"><span class="hs-identifier hs-var">tvs</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082529"><span class="hs-identifier hs-var">fvs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1846"></span><span>        </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Name) -&gt; [TyVarBndr] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082530"><span class="hs-identifier hs-var">tvs</span></a></span><span>
</span><span id="line-1847"></span><span>
</span><span id="line-1848"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#TypeSubstitution"><span class="hs-identifier hs-type">TypeSubstitution</span></a></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1849"></span><span>  </span><span id="local-6989586621679082526"><span class="annot"><span class="annottext">freeVariables :: ConstructorInfo -&gt; [Name]
</span><a href="#local-6989586621679082526"><span class="hs-identifier hs-var hs-var hs-var hs-var">freeVariables</span></a></span></span><span> </span><span id="local-6989586621679082525"><span class="annot"><span class="annottext">ci :: ConstructorInfo
</span><a href="#local-6989586621679082525"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1850"></span><span>      </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Cxt -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Type) -&gt; [TyVarBndr] -&gt; Cxt
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#tvKind"><span class="hs-identifier hs-var">tvKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082525"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1851"></span><span>          </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var hs-var">constructorContext</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082525"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1852"></span><span>          </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">`union`</span></span><span> </span><span class="annot"><span class="annottext">Cxt -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var hs-var">constructorFields</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082525"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1853"></span><span>      </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Name) -&gt; [TyVarBndr] -&gt; [Name]
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082525"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1854"></span><span>
</span><span id="line-1855"></span><span>  </span><span id="local-6989586621679082524"><span class="annot"><span class="annottext">applySubstitution :: Map Name Type -&gt; ConstructorInfo -&gt; ConstructorInfo
</span><a href="#local-6989586621679082524"><span class="hs-identifier hs-var hs-var hs-var hs-var">applySubstitution</span></a></span></span><span> </span><span id="local-6989586621679082523"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679082523"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span id="local-6989586621679082522"><span class="annot"><span class="annottext">ci :: ConstructorInfo
</span><a href="#local-6989586621679082522"><span class="hs-identifier hs-var">ci</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1856"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082521"><span class="annot"><span class="annottext">subst' :: Map Name Type
</span><a href="#local-6989586621679082521"><span class="hs-identifier hs-var hs-var">subst'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; Name -&gt; Map Name Type)
-&gt; Map Name Type -&gt; [Name] -&gt; Map Name Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Map Name Type -&gt; Map Name Type)
-&gt; Map Name Type -&gt; Name -&gt; Map Name Type
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; k -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.delete</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082523"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Name) -&gt; [TyVarBndr] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082522"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">in</span><span>
</span><span id="line-1857"></span><span>    </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082522"><span class="hs-identifier hs-var">ci</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">constructorVars :: [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; TyVarBndr) -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; TyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#mapTvbKind"><span class="hs-identifier hs-var">mapTvbKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082521"><span class="hs-identifier hs-var">subst'</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-1858"></span><span>                                  </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082522"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1859"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">constructorContext :: Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var">constructorContext</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082521"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorContext"><span class="hs-identifier hs-var hs-var">constructorContext</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082522"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1860"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">constructorFields :: Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var">constructorFields</span></a></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Cxt -&gt; Cxt
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082521"><span class="hs-identifier hs-var">subst'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#constructorFields"><span class="hs-identifier hs-var hs-var">constructorFields</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082522"><span class="hs-identifier hs-var">ci</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1861"></span><span>       </span><span class="hs-special">}</span><span>
</span><span id="line-1862"></span><span>
</span><span id="line-1863"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mapTvbKind"><span class="hs-identifier hs-type">mapTvbKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span>
</span><span id="line-1864"></span><span id="mapTvbKind"><span class="annot"><span class="annottext">mapTvbKind :: (Type -&gt; Type) -&gt; TyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#mapTvbKind"><span class="hs-identifier hs-var hs-var">mapTvbKind</span></a></span></span><span> </span><span id="local-6989586621679082520"><span class="annot"><span class="annottext">f :: Type -&gt; Type
</span><a href="#local-6989586621679082520"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679082519"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082519"><span class="hs-identifier hs-var">tvb</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082519"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-1865"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#mapTvbKind"><span class="hs-identifier hs-var">mapTvbKind</span></a></span><span> </span><span id="local-6989586621679082518"><span class="annot"><span class="annottext">f :: Type -&gt; Type
</span><a href="#local-6989586621679082518"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082517"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082517"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082516"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082516"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082517"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="#local-6989586621679082518"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082516"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1866"></span><span>
</span><span id="line-1867"></span><span id="local-6989586621679083788"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#traverseTvbKind"><span class="hs-identifier hs-type">traverseTvbKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Applicative</span></span><span> </span><span class="annot"><a href="#local-6989586621679083788"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679083788"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621679083788"><span class="hs-identifier hs-type">f</span></a></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span></span><span>
</span><span id="line-1868"></span><span id="traverseTvbKind"><span class="annot"><span class="annottext">traverseTvbKind :: (Type -&gt; f Type) -&gt; TyVarBndr -&gt; f TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#traverseTvbKind"><span class="hs-identifier hs-var hs-var">traverseTvbKind</span></a></span></span><span> </span><span id="local-6989586621679082515"><span class="annot"><span class="annottext">f :: Type -&gt; f Type
</span><a href="#local-6989586621679082515"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span id="local-6989586621679082514"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082514"><span class="hs-identifier hs-var">tvb</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; f TyVarBndr
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082514"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-1869"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#traverseTvbKind"><span class="hs-identifier hs-var">traverseTvbKind</span></a></span><span> </span><span id="local-6989586621679082513"><span class="annot"><span class="annottext">f :: Type -&gt; f Type
</span><a href="#local-6989586621679082513"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082512"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082512"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082511"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082511"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082512"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; TyVarBndr) -&gt; f Type -&gt; f TyVarBndr
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; f Type
</span><a href="#local-6989586621679082513"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082511"><span class="hs-identifier hs-var">k</span></a></span><span>
</span><span id="line-1870"></span><span>
</span><span id="line-1871"></span><span class="hs-comment">-- 'Pred' became a type synonym for 'Type'</span><span class="hs-cpp">
#if !MIN_VERSION_template_haskell(2,10,0)
</span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">TypeSubstitution</span><span> </span><span class="hs-identifier">Pred</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1874"></span><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">xs</span><span>
</span><span id="line-1875"></span><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-special">`</span><span class="hs-identifier">union</span><span class="hs-special">`</span><span> </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">y</span><span>
</span><span id="line-1876"></span><span>
</span><span id="line-1877"></span><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span>
</span><span id="line-1878"></span><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">x</span><span class="hs-special">)</span><span>
</span><span id="line-1879"></span><span>                                            </span><span class="hs-special">(</span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">p</span><span> </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1882"></span><span class="hs-comment">-- 'Kind' became a type synonym for 'Type'. Previously there were no kind variables</span><span class="hs-cpp">
#if !MIN_VERSION_template_haskell(2,8,0)
</span><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier">TypeSubstitution</span><span> </span><span class="hs-identifier">Kind</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-1885"></span><span>  </span><span class="hs-identifier">freeVariables</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-1886"></span><span>  </span><span class="hs-identifier">applySubstitution</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">k</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">k</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1889"></span><span class="hs-comment">-- | Substitutes into the kinds of type variable binders.</span><span>
</span><span id="line-1890"></span><span class="hs-comment">-- Not capture-avoiding.</span><span>
</span><span id="line-1891"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-type">substTyVarBndrs</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span>
</span><span id="line-1892"></span><span id="substTyVarBndrs"><span class="annot"><span class="annottext">substTyVarBndrs :: Map Name Type -&gt; [TyVarBndr] -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#substTyVarBndrs"><span class="hs-identifier hs-var hs-var">substTyVarBndrs</span></a></span></span><span> </span><span id="local-6989586621679082510"><span class="annot"><span class="annottext">subst :: Map Name Type
</span><a href="#local-6989586621679082510"><span class="hs-identifier hs-var">subst</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; TyVarBndr) -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; TyVarBndr
</span><a href="#local-6989586621679082509"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-1893"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-1894"></span><span>    </span><span id="local-6989586621679082509"><span class="annot"><span class="annottext">go :: TyVarBndr -&gt; TyVarBndr
</span><a href="#local-6989586621679082509"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679082508"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082508"><span class="hs-identifier hs-var">tvb</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span> </span><span class="hs-special">{</span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082508"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-1895"></span><span>    </span><span class="annot"><a href="#local-6989586621679082509"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span> </span><span id="local-6989586621679082507"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082507"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082506"><span class="annot"><span class="annottext">k :: Type
</span><a href="#local-6989586621679082506"><span class="hs-identifier hs-var">k</span></a></span></span><span class="hs-special">)</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082507"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082510"><span class="hs-identifier hs-var">subst</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082506"><span class="hs-identifier hs-var">k</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1896"></span><span>
</span><span id="line-1897"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-1898"></span><span>
</span><span id="line-1899"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-type">combineSubstitutions</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-1900"></span><span id="combineSubstitutions"><span class="annot"><span class="annottext">combineSubstitutions :: Map Name Type -&gt; Map Name Type -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var hs-var">combineSubstitutions</span></a></span></span><span> </span><span id="local-6989586621679082504"><span class="annot"><span class="annottext">x :: Map Name Type
</span><a href="#local-6989586621679082504"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679082503"><span class="annot"><span class="annottext">y :: Map Name Type
</span><a href="#local-6989586621679082503"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
forall k a. Ord k =&gt; Map k a -&gt; Map k a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.union</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Map Name Type -&gt; Map Name Type
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082503"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082504"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082503"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1901"></span><span>
</span><span id="line-1902"></span><span class="hs-comment">-- | Compute the type variable substitution that unifies a list of types,</span><span>
</span><span id="line-1903"></span><span class="hs-comment">-- or fail in 'Q'.</span><span>
</span><span id="line-1904"></span><span class="hs-comment">--</span><span>
</span><span id="line-1905"></span><span class="hs-comment">-- All infix issue should be resolved before using 'unifyTypes'</span><span>
</span><span id="line-1906"></span><span class="hs-comment">--</span><span>
</span><span id="line-1907"></span><span class="hs-comment">-- Alpha equivalent quantified types are not unified.</span><span>
</span><span id="line-1908"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-type">unifyTypes</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-1909"></span><span id="unifyTypes"><span class="annot"><span class="annottext">unifyTypes :: Cxt -&gt; Q (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-var hs-var">unifyTypes</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Q (Map Name Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-1910"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unifyTypes"><span class="hs-identifier hs-var">unifyTypes</span></a></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082502"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082502"><span class="hs-identifier hs-var">t</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679082501"><span class="annot"><span class="annottext">ts :: Cxt
</span><a href="#local-6989586621679082501"><span class="hs-identifier hs-var">ts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1911"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679082500"><span class="annot"><span class="annottext">t' :: Type
</span><a href="#local-6989586621679082500"><span class="hs-identifier hs-var">t'</span></a></span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679082499"><span class="annot"><span class="annottext">ts' :: Cxt
</span><a href="#local-6989586621679082499"><span class="hs-identifier hs-var">ts'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Q Type) -&gt; Cxt -&gt; Q Cxt
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Q Type
</span><a href="Language.Haskell.TH.Datatype.html#resolveTypeSynonyms"><span class="hs-identifier hs-var">resolveTypeSynonyms</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082502"><span class="hs-identifier hs-var">t</span></a></span><span class="annot"><span class="annottext">Type -&gt; Cxt -&gt; Cxt
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082501"><span class="hs-identifier hs-var">ts</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1912"></span><span>     </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082498"><span class="annot"><span class="annottext">aux :: Map Name Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="#local-6989586621679082498"><span class="hs-identifier hs-var hs-var">aux</span></a></span></span><span> </span><span id="local-6989586621679082497"><span class="annot"><span class="annottext">sub :: Map Name Type
</span><a href="#local-6989586621679082497"><span class="hs-identifier hs-var">sub</span></a></span></span><span> </span><span id="local-6989586621679082496"><span class="annot"><span class="annottext">u :: Type
</span><a href="#local-6989586621679082496"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1913"></span><span>           </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679082495"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082495"><span class="hs-identifier hs-var">sub'</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082497"><span class="hs-identifier hs-var">sub</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082500"><span class="hs-identifier hs-var">t'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1914"></span><span>                             </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082497"><span class="hs-identifier hs-var">sub</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082496"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1915"></span><span>              </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var">combineSubstitutions</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082497"><span class="hs-identifier hs-var">sub</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082495"><span class="hs-identifier hs-var">sub'</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1916"></span><span>
</span><span id="line-1917"></span><span>     </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">(Map Name Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type))
-&gt; Map Name Type -&gt; Cxt -&gt; Either (Type, Type) (Map Name Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) b a.
(Foldable t, Monad m) =&gt;
(b -&gt; a -&gt; m b) -&gt; b -&gt; t a -&gt; m b
</span><span class="hs-identifier hs-var">foldM</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="#local-6989586621679082498"><span class="hs-identifier hs-var">aux</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span> </span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082499"><span class="hs-identifier hs-var">ts'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1918"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">Right</span></span><span> </span><span id="local-6989586621679082492"><span class="annot"><span class="annottext">m :: Map Name Type
</span><a href="#local-6989586621679082492"><span class="hs-identifier hs-var">m</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Q (Map Name Type)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082492"><span class="hs-identifier hs-var">m</span></a></span><span>
</span><span id="line-1919"></span><span>       </span><span class="annot"><span class="hs-identifier hs-type">Left</span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621679082491"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082491"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679082490"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082490"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-1920"></span><span>         </span><span class="annot"><span class="annottext">String -&gt; Q (Map Name Type)
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Q (Map Name Type)) -&gt; String -&gt; Q (Map Name Type)
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">showString</span></span><span> </span><span class="annot"><span class="hs-string">&quot;Unable to unify types &quot;</span></span><span>
</span><span id="line-1921"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Type -&gt; ShowS
forall a. Show a =&gt; Int -&gt; a -&gt; ShowS
</span><span class="hs-identifier hs-var">showsPrec</span></span><span> </span><span class="annot"><span class="hs-number">11</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082491"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-1922"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
</span><span class="hs-identifier hs-var">showString</span></span><span> </span><span class="annot"><span class="hs-string">&quot; and &quot;</span></span><span>
</span><span id="line-1923"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS -&gt; ShowS
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Int -&gt; Type -&gt; ShowS
forall a. Show a =&gt; Int -&gt; a -&gt; ShowS
</span><span class="hs-identifier hs-var">showsPrec</span></span><span> </span><span class="annot"><span class="hs-number">11</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082490"><span class="hs-identifier hs-var">y</span></a></span><span>
</span><span id="line-1924"></span><span>              </span><span class="annot"><span class="annottext">ShowS -&gt; ShowS
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="hs-string">&quot;&quot;</span></span><span>
</span><span id="line-1925"></span><span>
</span><span id="line-1926"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-type">unify'</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Either</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Map</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span>
</span><span id="line-1927"></span><span>
</span><span id="line-1928"></span><span id="unify%27"><span class="annot"><span class="annottext">unify' :: Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var hs-var">unify'</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082487"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082487"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082486"><span class="annot"><span class="annottext">m :: Name
</span><a href="#local-6989586621679082486"><span class="hs-identifier hs-var">m</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082487"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082486"><span class="hs-identifier hs-var">m</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-1929"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082485"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082485"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082484"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082484"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082485"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082484"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Either (Type, Type) (Map Name Type)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082485"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082484"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1930"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082485"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082484"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1931"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span id="local-6989586621679082483"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082483"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082482"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082482"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082482"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-operator hs-var">`elem`</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082483"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Either (Type, Type) (Map Name Type)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">VarT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082482"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082483"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1932"></span><span>                  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span>                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; Map Name Type
forall k a. k -&gt; a -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.singleton</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082482"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082483"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1933"></span><span>
</span><span id="line-1934"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082481"><span class="annot"><span class="annottext">f1 :: Type
</span><a href="#local-6989586621679082481"><span class="hs-identifier hs-var">f1</span></a></span></span><span> </span><span id="local-6989586621679082480"><span class="annot"><span class="annottext">x1 :: Type
</span><a href="#local-6989586621679082480"><span class="hs-identifier hs-var">x1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">AppT</span></span><span> </span><span id="local-6989586621679082479"><span class="annot"><span class="annottext">f2 :: Type
</span><a href="#local-6989586621679082479"><span class="hs-identifier hs-var">f2</span></a></span></span><span> </span><span id="local-6989586621679082478"><span class="annot"><span class="annottext">x2 :: Type
</span><a href="#local-6989586621679082478"><span class="hs-identifier hs-var">x2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1935"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679082477"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082477"><span class="hs-identifier hs-var">sub1</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082481"><span class="hs-identifier hs-var">f1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082479"><span class="hs-identifier hs-var">f2</span></a></span><span>
</span><span id="line-1936"></span><span>     </span><span id="local-6989586621679082476"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082476"><span class="hs-identifier hs-var">sub2</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082477"><span class="hs-identifier hs-var">sub1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082480"><span class="hs-identifier hs-var">x1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Type -&gt; Type
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082477"><span class="hs-identifier hs-var">sub1</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082478"><span class="hs-identifier hs-var">x2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1937"></span><span>     </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Map Name Type -&gt; Map Name Type -&gt; Map Name Type
</span><a href="Language.Haskell.TH.Datatype.html#combineSubstitutions"><span class="hs-identifier hs-var">combineSubstitutions</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082477"><span class="hs-identifier hs-var">sub1</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082476"><span class="hs-identifier hs-var">sub2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1938"></span><span>
</span><span id="line-1939"></span><span class="hs-comment">-- Doesn't unify kind signatures</span><span>
</span><span id="line-1940"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082475"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082475"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span id="local-6989586621679082474"><span class="annot"><span class="annottext">u :: Type
</span><a href="#local-6989586621679082474"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082475"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082474"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-1941"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span id="local-6989586621679082473"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082473"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">SigT</span></span><span> </span><span id="local-6989586621679082472"><span class="annot"><span class="annottext">u :: Type
</span><a href="#local-6989586621679082472"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-identifier">_</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Either (Type, Type) (Map Name Type)
</span><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082473"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082472"><span class="hs-identifier hs-var">u</span></a></span><span>
</span><span id="line-1942"></span><span>
</span><span id="line-1943"></span><span class="hs-comment">-- only non-recursive cases should remain at this point</span><span>
</span><span id="line-1944"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#unify%27"><span class="hs-identifier hs-var">unify'</span></a></span><span> </span><span id="local-6989586621679082471"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082471"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span id="local-6989586621679082470"><span class="annot"><span class="annottext">u :: Type
</span><a href="#local-6989586621679082470"><span class="hs-identifier hs-var">u</span></a></span></span><span>
</span><span id="line-1945"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082471"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082470"><span class="hs-identifier hs-var">u</span></a></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; Either (Type, Type) (Map Name Type)
forall a b. b -&gt; Either a b
</span><span class="hs-identifier hs-var">Right</span></span><span> </span><span class="annot"><span class="annottext">Map Name Type
forall k a. Map k a
</span><span class="hs-identifier hs-var">Map.empty</span></span><span>
</span><span id="line-1946"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Either (Type, Type) (Map Name Type)
forall a b. a -&gt; Either a b
</span><span class="hs-identifier hs-var">Left</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082471"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082470"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1947"></span><span>
</span><span id="line-1948"></span><span>
</span><span id="line-1949"></span><span class="hs-comment">-- | Construct an equality constraint. The implementation of 'Pred' varies</span><span>
</span><span id="line-1950"></span><span class="hs-comment">-- across versions of Template Haskell.</span><span>
</span><span id="line-1951"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-type">equalPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span>
</span><span id="line-1952"></span><span id="equalPred"><span class="annot"><span class="annottext">equalPred :: Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#equalPred"><span class="hs-identifier hs-var hs-var">equalPred</span></a></span></span><span> </span><span id="local-6989586621679082469"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082469"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679082468"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082468"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span>  </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">EqualityT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082469"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082468"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-identifier">EqualP</span><span> </span><span class="hs-identifier">x</span><span> </span><span class="hs-identifier">y</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1959"></span><span class="hs-comment">-- | Construct a typeclass constraint. The implementation of 'Pred' varies</span><span>
</span><span id="line-1960"></span><span class="hs-comment">-- across versions of Template Haskell.</span><span>
</span><span id="line-1961"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier hs-type">classPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-comment">{- ^ class -}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ parameters -}</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span>
</span><span id="line-1962"></span><span id="classPred"><span class="annot"><span class="annottext">classPred :: Name -&gt; Cxt -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#classPred"><span class="hs-identifier hs-var hs-var">classPred</span></a></span></span><span> </span><span class="hs-glyph">=</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span>  </span><span class="annot"><span class="annottext">(Type -&gt; Type -&gt; Type) -&gt; Type -&gt; Cxt -&gt; Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">AppT</span></span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Cxt -&gt; Type) -&gt; (Name -&gt; Type) -&gt; Name -&gt; Cxt -&gt; Type
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type
</span><span class="hs-identifier hs-var">ConT</span></span><span class="hs-cpp">
#else
</span><span>  </span><span class="hs-identifier">ClassP</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1969"></span><span class="hs-comment">-- | Match a 'Pred' representing an equality constraint. Returns</span><span>
</span><span id="line-1970"></span><span class="hs-comment">-- arguments to the equality constraint if successful.</span><span>
</span><span id="line-1971"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-type">asEqualPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">,</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="asEqualPred"><span class="annot"><span class="annottext">asEqualPred :: Type -&gt; Maybe (Type, Type)
</span><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var hs-var">asEqualPred</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">EqualityT</span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082466"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082466"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082465"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082465"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span>                    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082466"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082465"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1974"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var">asEqualPred</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679082464"><span class="annot"><span class="annottext">eq :: Name
</span><a href="#local-6989586621679082464"><span class="hs-identifier hs-var">eq</span></a></span></span><span>   </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082463"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082463"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-operator hs-type">`AppT`</span></span><span> </span><span id="local-6989586621679082462"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082462"><span class="hs-identifier hs-var">y</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082464"><span class="hs-identifier hs-var">eq</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Datatype.Internal.html#eqTypeName"><span class="hs-identifier hs-var">eqTypeName</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type, Type) -&gt; Maybe (Type, Type)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082463"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082462"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">asEqualPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">EqualP</span><span>            </span><span class="hs-identifier">x</span><span>        </span><span class="hs-identifier">y</span><span class="hs-special">)</span><span>                   </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">x</span><span class="hs-special">,</span><span class="hs-identifier">y</span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asEqualPred"><span class="hs-identifier hs-var">asEqualPred</span></a></span><span> </span><span class="hs-identifier">_</span><span>                                                </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (Type, Type)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-1979"></span><span>
</span><span id="line-1980"></span><span class="hs-comment">-- | Match a 'Pred' representing a class constraint.</span><span>
</span><span id="line-1981"></span><span class="hs-comment">-- Returns the classname and parameters if successful.</span><span>
</span><span id="line-1982"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier hs-type">asClassPred</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Pred</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">,</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="asClassPred"><span class="annot"><span class="annottext">asClassPred :: Type -&gt; Maybe (Name, Cxt)
</span><a href="Language.Haskell.TH.Datatype.html#asClassPred"><span class="hs-identifier hs-var hs-var">asClassPred</span></a></span></span><span> </span><span id="local-6989586621679082460"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082460"><span class="hs-identifier hs-var">t</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-1985"></span><span>  </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Type -&gt; NonEmpty Type
</span><a href="Language.Haskell.TH.Datatype.html#decomposeType"><span class="hs-identifier hs-var">decomposeType</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082460"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-1986"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">ConT</span></span><span> </span><span id="local-6989586621679082459"><span class="annot"><span class="annottext">f :: Name
</span><a href="#local-6989586621679082459"><span class="hs-identifier hs-var">f</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#%3A%7C"><span class="hs-operator hs-type">:|</span></a></span><span> </span><span id="local-6989586621679082458"><span class="annot"><span class="annottext">xs :: Cxt
</span><a href="#local-6989586621679082458"><span class="hs-identifier hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082459"><span class="hs-identifier hs-var">f</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="Language.Haskell.TH.Datatype.Internal.html#eqTypeName"><span class="hs-identifier hs-var">eqTypeName</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">(Name, Cxt) -&gt; Maybe (Name, Cxt)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082459"><span class="hs-identifier hs-var">f</span></a></span><span class="hs-special">,</span><span class="annot"><span class="annottext">Cxt
</span><a href="#local-6989586621679082458"><span class="hs-identifier hs-var">xs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-1987"></span><span>    </span><span class="hs-identifier">_</span><span>                              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe (Name, Cxt)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">ClassP</span><span> </span><span class="hs-identifier">f</span><span> </span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">f</span><span class="hs-special">,</span><span class="hs-identifier">xs</span><span class="hs-special">)</span><span>
</span><span id="line-1990"></span><span class="hs-identifier">asClassPred</span><span> </span><span class="hs-identifier">_</span><span>             </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-1993"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-1994"></span><span>
</span><span id="line-1995"></span><span class="hs-comment">-- | If we are working with a 'Dec' obtained via 'reify' (as opposed to one</span><span>
</span><span id="line-1996"></span><span class="hs-comment">-- created from, say, [d| ... |] quotes), then we need to apply more hacks than</span><span>
</span><span id="line-1997"></span><span class="hs-comment">-- we otherwise would to sanitize the 'Dec'. See #28.</span><span>
</span><span id="line-1998"></span><span class="hs-keyword">type</span><span> </span><span id="IsReifiedDec"><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-var">IsReifiedDec</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Bool</span></span><span>
</span><span id="line-1999"></span><span>
</span><span id="line-2000"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-type">isReified</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-type">isn'tReified</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#IsReifiedDec"><span class="hs-identifier hs-type">IsReifiedDec</span></a></span><span>
</span><span id="line-2001"></span><span id="isReified"><span class="annot"><span class="annottext">isReified :: Bool
</span><a href="Language.Haskell.TH.Datatype.html#isReified"><span class="hs-identifier hs-var hs-var">isReified</span></a></span></span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">True</span></span><span>
</span><span id="line-2002"></span><span id="isn%27tReified"><span class="annot"><span class="annottext">isn'tReified :: Bool
</span><a href="Language.Haskell.TH.Datatype.html#isn%27tReified"><span class="hs-identifier hs-var hs-var">isn'tReified</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">False</span></span><span>
</span><span id="line-2003"></span><span>
</span><span id="line-2004"></span><span class="hs-comment">-- On old versions of GHC, reify would not give you kind signatures for</span><span>
</span><span id="line-2005"></span><span class="hs-comment">-- GADT type variables of kind *. To work around this, we insert the kinds</span><span>
</span><span id="line-2006"></span><span class="hs-comment">-- manually on any types without a signature.</span><span>
</span><span id="line-2007"></span><span>
</span><span id="line-2008"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveDIVarsStarKinds"><span class="hs-identifier hs-type">giveDIVarsStarKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-2009"></span><span id="giveDIVarsStarKinds"><span class="annot"><span class="annottext">giveDIVarsStarKinds :: DatatypeInfo -&gt; DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveDIVarsStarKinds"><span class="hs-identifier hs-var hs-var">giveDIVarsStarKinds</span></a></span></span><span> </span><span id="local-6989586621679082456"><span class="annot"><span class="annottext">info :: DatatypeInfo
</span><a href="#local-6989586621679082456"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2010"></span><span>  </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082456"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">datatypeVars :: [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var">datatypeVars</span></a></span><span>      </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; TyVarBndr) -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-var">giveTyVarBndrStarKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var hs-var">datatypeVars</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082456"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2011"></span><span>       </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">datatypeInstTypes :: Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var">datatypeInstTypes</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(Type -&gt; Type) -&gt; Cxt -&gt; Cxt
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-var">giveTypeStarKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Cxt
</span><a href="Language.Haskell.TH.Datatype.html#datatypeInstTypes"><span class="hs-identifier hs-var hs-var">datatypeInstTypes</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082456"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2012"></span><span>
</span><span id="line-2013"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveCIVarsStarKinds"><span class="hs-identifier hs-type">giveCIVarsStarKinds</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#ConstructorInfo"><span class="hs-identifier hs-type">ConstructorInfo</span></a></span><span>
</span><span id="line-2014"></span><span id="giveCIVarsStarKinds"><span class="annot"><span class="annottext">giveCIVarsStarKinds :: ConstructorInfo -&gt; ConstructorInfo
</span><a href="Language.Haskell.TH.Datatype.html#giveCIVarsStarKinds"><span class="hs-identifier hs-var hs-var">giveCIVarsStarKinds</span></a></span></span><span> </span><span id="local-6989586621679082453"><span class="annot"><span class="annottext">info :: ConstructorInfo
</span><a href="#local-6989586621679082453"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2015"></span><span>  </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082453"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">constructorVars :: [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var">constructorVars</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; TyVarBndr) -&gt; [TyVarBndr] -&gt; [TyVarBndr]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-var">giveTyVarBndrStarKind</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">ConstructorInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#constructorVars"><span class="hs-identifier hs-var hs-var">constructorVars</span></a></span><span> </span><span class="annot"><span class="annottext">ConstructorInfo
</span><a href="#local-6989586621679082453"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2016"></span><span>
</span><span id="line-2017"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-type">giveTyVarBndrStarKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span>
</span><span id="line-2018"></span><span id="giveTyVarBndrStarKind"><span class="annot"><span class="annottext">giveTyVarBndrStarKind :: TyVarBndr -&gt; TyVarBndr
</span><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-var hs-var">giveTyVarBndrStarKind</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">PlainTV</span></span><span> </span><span id="local-6989586621679082452"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082452"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span>    </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Type -&gt; TyVarBndr
</span><span class="hs-identifier hs-var">KindedTV</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082452"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span>
</span><span id="line-2019"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTyVarBndrStarKind"><span class="hs-identifier hs-var">giveTyVarBndrStarKind</span></a></span><span> </span><span id="local-6989586621679082451"><span class="annot"><span class="annottext">tvb :: TyVarBndr
</span><a href="#local-6989586621679082451"><span class="hs-identifier hs-var">tvb</span></a></span></span><span class="hs-glyph">@</span><span class="annot"><span class="hs-identifier hs-type">KindedTV</span></span><span class="hs-special">{</span><span class="hs-special">}</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TyVarBndr
</span><a href="#local-6989586621679082451"><span class="hs-identifier hs-var">tvb</span></a></span><span>
</span><span id="line-2020"></span><span>
</span><span id="line-2021"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-type">giveTypeStarKind</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Type</span></span><span>
</span><span id="line-2022"></span><span id="giveTypeStarKind"><span class="annot"><span class="annottext">giveTypeStarKind :: Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-var hs-var">giveTypeStarKind</span></a></span></span><span> </span><span id="local-6989586621679082450"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082450"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">VarT</span></span><span> </span><span id="local-6989586621679082449"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082449"><span class="hs-identifier hs-var">n</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-identifier hs-var">SigT</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082450"><span class="hs-identifier hs-var">t</span></a></span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">starK</span></span><span>
</span><span id="line-2023"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#giveTypeStarKind"><span class="hs-identifier hs-var">giveTypeStarKind</span></a></span><span> </span><span id="local-6989586621679082448"><span class="annot"><span class="annottext">t :: Type
</span><a href="#local-6989586621679082448"><span class="hs-identifier hs-var">t</span></a></span></span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082448"><span class="hs-identifier hs-var">t</span></a></span><span>
</span><span id="line-2024"></span><span>
</span><span id="line-2025"></span><span class="hs-comment">-- | Prior to GHC 8.2.1, reify was broken for data instances and newtype</span><span>
</span><span id="line-2026"></span><span class="hs-comment">-- instances. This code attempts to detect the problem and repair it if</span><span>
</span><span id="line-2027"></span><span class="hs-comment">-- possible.</span><span>
</span><span id="line-2028"></span><span class="hs-comment">--</span><span>
</span><span id="line-2029"></span><span class="hs-comment">-- The particular problem is that the type variables used in the patterns</span><span>
</span><span id="line-2030"></span><span class="hs-comment">-- while defining a data family instance do not completely match those</span><span>
</span><span id="line-2031"></span><span class="hs-comment">-- used when defining the fields of the value constructors beyond the</span><span>
</span><span id="line-2032"></span><span class="hs-comment">-- base names. This code attempts to recover the relationship between the</span><span>
</span><span id="line-2033"></span><span class="hs-comment">-- type variables.</span><span>
</span><span id="line-2034"></span><span class="hs-comment">--</span><span>
</span><span id="line-2035"></span><span class="hs-comment">-- It is possible, however, to generate these kinds of declarations by</span><span>
</span><span id="line-2036"></span><span class="hs-comment">-- means other than reify. In these cases the name bases might not be</span><span>
</span><span id="line-2037"></span><span class="hs-comment">-- unique and the declarations might be well formed. In such a case this</span><span>
</span><span id="line-2038"></span><span class="hs-comment">-- code attempts to avoid altering the declaration.</span><span>
</span><span id="line-2039"></span><span class="hs-comment">--</span><span>
</span><span id="line-2040"></span><span class="hs-comment">-- https://ghc.haskell.org/trac/ghc/ticket/13618</span><span>
</span><span id="line-2041"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-type">repair13618</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#DatatypeInfo"><span class="hs-identifier hs-type">DatatypeInfo</span></a></span><span>
</span><span id="line-2042"></span><span id="repair13618"><span class="annot"><span class="annottext">repair13618 :: DatatypeInfo -&gt; Q DatatypeInfo
</span><a href="Language.Haskell.TH.Datatype.html#repair13618"><span class="hs-identifier hs-var hs-var">repair13618</span></a></span></span><span> </span><span id="local-6989586621679082447"><span class="annot"><span class="annottext">info :: DatatypeInfo
</span><a href="#local-6989586621679082447"><span class="hs-identifier hs-var">info</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2043"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span id="local-6989586621679082446"><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082446"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Map Name (Q Type) -&gt; Q (Map Name Type)
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><span class="hs-identifier hs-var">T.sequence</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">[(Name, Q Type)] -&gt; Map Name (Q Type)
forall k a. Ord k =&gt; [(k, a)] -&gt; Map k a
</span><span class="hs-identifier hs-var">Map.fromList</span></span><span> </span><span class="annot"><span class="annottext">[(Name, Q Type)]
</span><a href="#local-6989586621679082445"><span class="hs-identifier hs-var">substList</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2044"></span><span>     </span><span class="annot"><span class="annottext">DatatypeInfo -&gt; Q DatatypeInfo
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082447"><span class="hs-identifier hs-var">info</span></a></span><span> </span><span class="hs-special">{</span><span> </span><span class="annot"><span class="annottext">datatypeCons :: [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var">datatypeCons</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Map Name Type -&gt; [ConstructorInfo] -&gt; [ConstructorInfo]
forall a. TypeSubstitution a =&gt; Map Name Type -&gt; a -&gt; a
</span><a href="Language.Haskell.TH.Datatype.html#applySubstitution"><span class="hs-identifier hs-var">applySubstitution</span></a></span><span> </span><span class="annot"><span class="annottext">Map Name Type
</span><a href="#local-6989586621679082446"><span class="hs-identifier hs-var">s</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082447"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">}</span><span>
</span><span id="line-2045"></span><span>
</span><span id="line-2046"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-2047"></span><span>    </span><span id="local-6989586621679082444"><span class="annot"><span class="annottext">used :: [Name]
</span><a href="#local-6989586621679082444"><span class="hs-identifier hs-var hs-var">used</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[ConstructorInfo] -&gt; [Name]
forall a. TypeSubstitution a =&gt; a -&gt; [Name]
</span><a href="Language.Haskell.TH.Datatype.html#freeVariables"><span class="hs-identifier hs-var">freeVariables</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [ConstructorInfo]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeCons"><span class="hs-identifier hs-var hs-var">datatypeCons</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082447"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2048"></span><span>    </span><span id="local-6989586621679082443"><span class="annot"><span class="annottext">bound :: [Name]
</span><a href="#local-6989586621679082443"><span class="hs-identifier hs-var hs-var">bound</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(TyVarBndr -&gt; Name) -&gt; [TyVarBndr] -&gt; [Name]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">TyVarBndr -&gt; Name
</span><a href="Language.Haskell.TH.Datatype.html#tvName"><span class="hs-identifier hs-var">tvName</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">DatatypeInfo -&gt; [TyVarBndr]
</span><a href="Language.Haskell.TH.Datatype.html#datatypeVars"><span class="hs-identifier hs-var hs-var">datatypeVars</span></a></span><span> </span><span class="annot"><span class="annottext">DatatypeInfo
</span><a href="#local-6989586621679082447"><span class="hs-identifier hs-var">info</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2049"></span><span>    </span><span id="local-6989586621679082442"><span class="annot"><span class="annottext">free :: [Name]
</span><a href="#local-6989586621679082442"><span class="hs-identifier hs-var hs-var">free</span></a></span></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082444"><span class="hs-identifier hs-var">used</span></a></span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; [Name] -&gt; [Name]
forall a. Eq a =&gt; [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">\\</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082443"><span class="hs-identifier hs-var">bound</span></a></span><span>
</span><span id="line-2050"></span><span>
</span><span id="line-2051"></span><span>    </span><span id="local-6989586621679082445"><span class="annot"><span class="annottext">substList :: [(Name, Q Type)]
</span><a href="#local-6989586621679082445"><span class="hs-identifier hs-var hs-var">substList</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2052"></span><span>      </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082441"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Name] -&gt; Q Type
forall a. Show a =&gt; a -&gt; [Name] -&gt; Q Type
</span><a href="#local-6989586621679082440"><span class="hs-identifier hs-var">substEntry</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082441"><span class="hs-identifier hs-var">u</span></a></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082439"><span class="hs-identifier hs-var">vs</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2053"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679082441"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082441"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082442"><span class="hs-identifier hs-var">free</span></a></span><span>
</span><span id="line-2054"></span><span>      </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679082439"><span class="annot"><span class="annottext">vs :: [Name]
</span><a href="#local-6989586621679082439"><span class="hs-identifier hs-var hs-var">vs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082438"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679082438"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082438"><span class="hs-identifier hs-var">v</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082443"><span class="hs-identifier hs-var">bound</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082438"><span class="hs-identifier hs-var">v</span></a></span><span> </span><span class="annot"><span class="annottext">String -&gt; String -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; String
</span><span class="hs-identifier hs-var">nameBase</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082441"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-2055"></span><span>      </span><span class="hs-special">]</span><span>
</span><span id="line-2056"></span><span>
</span><span id="line-2057"></span><span>    </span><span id="local-6989586621679082440"><span class="annot"><span class="annottext">substEntry :: a -&gt; [Name] -&gt; Q Type
</span><a href="#local-6989586621679082440"><span class="hs-identifier hs-var hs-var">substEntry</span></a></span></span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-special">[</span><span id="local-6989586621679082437"><span class="annot"><span class="annottext">v :: Name
</span><a href="#local-6989586621679082437"><span class="hs-identifier hs-var">v</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">varT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082437"><span class="hs-identifier hs-var">v</span></a></span><span>
</span><span id="line-2058"></span><span>    </span><span class="annot"><a href="#local-6989586621679082440"><span class="hs-identifier hs-var">substEntry</span></a></span><span> </span><span id="local-6989586621679082436"><span class="annot"><span class="annottext">u :: a
</span><a href="#local-6989586621679082436"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Type
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;Impossible free variable: &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679082436"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2059"></span><span>    </span><span class="annot"><a href="#local-6989586621679082440"><span class="hs-identifier hs-var">substEntry</span></a></span><span> </span><span id="local-6989586621679082435"><span class="annot"><span class="annottext">u :: a
</span><a href="#local-6989586621679082435"><span class="hs-identifier hs-var">u</span></a></span></span><span> </span><span class="hs-identifier">_</span><span>   </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Q Type
forall (m :: * -&gt; *) a. MonadFail m =&gt; String -&gt; m a
</span><span class="hs-identifier hs-var">fail</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-string">&quot;Ambiguous free variable: &quot;</span></span><span>  </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">a -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679082435"><span class="hs-identifier hs-var">u</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2060"></span><span>
</span><span id="line-2061"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2062"></span><span>
</span><span id="line-2063"></span><span class="hs-comment">-- | Backward compatible version of 'dataD'</span><span>
</span><span id="line-2064"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier hs-type">dataDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2065"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">CxtQ</span></span><span>        </span><span class="hs-comment">{- ^ context                 -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2066"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>        </span><span class="hs-comment">{- ^ type constructor        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2067"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ type parameters         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2068"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">ConQ</span></span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ constructor definitions -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2069"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ derived class names     -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2070"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,12,0)
</span><span id="dataDCompat"><span class="annot"><span class="annottext">dataDCompat :: Q Cxt -&gt; Name -&gt; [TyVarBndr] -&gt; [ConQ] -&gt; [Name] -&gt; DecQ
</span><a href="Language.Haskell.TH.Datatype.html#dataDCompat"><span class="hs-identifier hs-var hs-var">dataDCompat</span></a></span></span><span> </span><span id="local-6989586621679082433"><span class="annot"><span class="annottext">c :: Q Cxt
</span><a href="#local-6989586621679082433"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679082432"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082432"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082431"><span class="annot"><span class="annottext">ts :: [TyVarBndr]
</span><a href="#local-6989586621679082431"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679082430"><span class="annot"><span class="annottext">cs :: [ConQ]
</span><a href="#local-6989586621679082430"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679082429"><span class="annot"><span class="annottext">ds :: [Name]
</span><a href="#local-6989586621679082429"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2073"></span><span>  </span><span class="annot"><span class="annottext">Q Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Maybe Type
-&gt; [ConQ]
-&gt; [DerivClauseQ]
-&gt; DecQ
</span><span class="hs-identifier hs-var">dataD</span></span><span> </span><span class="annot"><span class="annottext">Q Cxt
</span><a href="#local-6989586621679082433"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082432"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082431"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">[ConQ]
</span><a href="#local-6989586621679082430"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-2074"></span><span>    </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082429"><span class="hs-identifier hs-var">ds</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe DerivStrategy -&gt; [Q Type] -&gt; DerivClauseQ
</span><span class="hs-identifier hs-var">derivClause</span></span><span> </span><span class="annot"><span class="annottext">Maybe DerivStrategy
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Q Type) -&gt; [Name] -&gt; [Q Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082429"><span class="hs-identifier hs-var">ds</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cs</span><span> </span><span class="hs-identifier">ds</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2077"></span><span>  </span><span class="hs-identifier">dataD</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cs</span><span>
</span><span id="line-2078"></span><span>    </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">ds</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">dataDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">dataD</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2083"></span><span class="hs-comment">-- | Backward compatible version of 'newtypeD'</span><span>
</span><span id="line-2084"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier hs-type">newtypeDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2085"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">CxtQ</span></span><span>        </span><span class="hs-comment">{- ^ context                 -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2086"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>        </span><span class="hs-comment">{- ^ type constructor        -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2087"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ type parameters         -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2088"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">ConQ</span></span><span>        </span><span class="hs-comment">{- ^ constructor definition  -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2089"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span class="hs-special">]</span><span>      </span><span class="hs-comment">{- ^ derived class names     -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2090"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,12,0)
</span><span id="newtypeDCompat"><span class="annot"><span class="annottext">newtypeDCompat :: Q Cxt -&gt; Name -&gt; [TyVarBndr] -&gt; ConQ -&gt; [Name] -&gt; DecQ
</span><a href="Language.Haskell.TH.Datatype.html#newtypeDCompat"><span class="hs-identifier hs-var hs-var">newtypeDCompat</span></a></span></span><span> </span><span id="local-6989586621679082426"><span class="annot"><span class="annottext">c :: Q Cxt
</span><a href="#local-6989586621679082426"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span id="local-6989586621679082425"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082425"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082424"><span class="annot"><span class="annottext">ts :: [TyVarBndr]
</span><a href="#local-6989586621679082424"><span class="hs-identifier hs-var">ts</span></a></span></span><span> </span><span id="local-6989586621679082423"><span class="annot"><span class="annottext">cs :: ConQ
</span><a href="#local-6989586621679082423"><span class="hs-identifier hs-var">cs</span></a></span></span><span> </span><span id="local-6989586621679082422"><span class="annot"><span class="annottext">ds :: [Name]
</span><a href="#local-6989586621679082422"><span class="hs-identifier hs-var">ds</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2093"></span><span>  </span><span class="annot"><span class="annottext">Q Cxt
-&gt; Name
-&gt; [TyVarBndr]
-&gt; Maybe Type
-&gt; ConQ
-&gt; [DerivClauseQ]
-&gt; DecQ
</span><span class="hs-identifier hs-var">newtypeD</span></span><span> </span><span class="annot"><span class="annottext">Q Cxt
</span><a href="#local-6989586621679082426"><span class="hs-identifier hs-var">c</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082425"><span class="hs-identifier hs-var">n</span></a></span><span> </span><span class="annot"><span class="annottext">[TyVarBndr]
</span><a href="#local-6989586621679082424"><span class="hs-identifier hs-var">ts</span></a></span><span> </span><span class="annot"><span class="annottext">Maybe Type
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">ConQ
</span><a href="#local-6989586621679082423"><span class="hs-identifier hs-var">cs</span></a></span><span>
</span><span id="line-2094"></span><span>    </span><span class="hs-special">(</span><span class="hs-keyword">if</span><span> </span><span class="annot"><span class="annottext">[Name] -&gt; Bool
forall (t :: * -&gt; *) a. Foldable t =&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">null</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082422"><span class="hs-identifier hs-var">ds</span></a></span><span> </span><span class="hs-keyword">then</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-keyword">else</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Maybe DerivStrategy -&gt; [Q Type] -&gt; DerivClauseQ
</span><span class="hs-identifier hs-var">derivClause</span></span><span> </span><span class="annot"><span class="annottext">Maybe DerivStrategy
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(Name -&gt; Q Type) -&gt; [Name] -&gt; [Q Type]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">[Name]
</span><a href="#local-6989586621679082422"><span class="hs-identifier hs-var">ds</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span class="hs-special">)</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,11,0)
</span><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">cs</span><span> </span><span class="hs-identifier">ds</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-2097"></span><span>  </span><span class="hs-identifier">newtypeD</span><span> </span><span class="hs-identifier">c</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">ts</span><span> </span><span class="hs-identifier">Nothing</span><span> </span><span class="hs-identifier">cs</span><span>
</span><span id="line-2098"></span><span>    </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">map</span><span> </span><span class="hs-identifier">ConT</span><span> </span><span class="hs-identifier">ds</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">newtypeDCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">newtypeD</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2103"></span><span class="hs-comment">-- | Backward compatible version of 'tySynInstD'</span><span>
</span><span id="line-2104"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier hs-type">tySynInstDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2105"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span>                </span><span class="hs-comment">{- ^ type family name    -}</span><span>   </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2106"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">TyVarBndr</span></span><span class="hs-special">]</span><span> </span><span class="hs-comment">{- ^ type variable binders -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2107"></span><span>  </span><span class="hs-special">[</span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span class="hs-special">]</span><span>             </span><span class="hs-comment">{- ^ instance parameters -}</span><span>   </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2108"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">TypeQ</span></span><span>               </span><span class="hs-comment">{- ^ instance result     -}</span><span>   </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2109"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,15,0)
</span><span id="tySynInstDCompat"><span class="annot"><span class="annottext">tySynInstDCompat :: Name -&gt; Maybe [Q TyVarBndr] -&gt; [Q Type] -&gt; Q Type -&gt; DecQ
</span><a href="Language.Haskell.TH.Datatype.html#tySynInstDCompat"><span class="hs-identifier hs-var hs-var">tySynInstDCompat</span></a></span></span><span> </span><span id="local-6989586621679082420"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082420"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span id="local-6989586621679082419"><span class="annot"><span class="annottext">mtvbs :: Maybe [Q TyVarBndr]
</span><a href="#local-6989586621679082419"><span class="hs-identifier hs-var">mtvbs</span></a></span></span><span> </span><span id="local-6989586621679082418"><span class="annot"><span class="annottext">ps :: [Q Type]
</span><a href="#local-6989586621679082418"><span class="hs-identifier hs-var">ps</span></a></span></span><span> </span><span id="local-6989586621679082417"><span class="annot"><span class="annottext">r :: Q Type
</span><a href="#local-6989586621679082417"><span class="hs-identifier hs-var">r</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">TySynEqn -&gt; Dec
</span><span class="hs-identifier hs-var">TySynInstD</span></span><span> </span><span class="annot"><span class="annottext">(TySynEqn -&gt; Dec) -&gt; Q TySynEqn -&gt; DecQ
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe [TyVarBndr] -&gt; Type -&gt; Type -&gt; TySynEqn
</span><span class="hs-identifier hs-var">TySynEqn</span></span><span> </span><span class="annot"><span class="annottext">(Maybe [TyVarBndr] -&gt; Type -&gt; Type -&gt; TySynEqn)
-&gt; Q (Maybe [TyVarBndr]) -&gt; Q (Type -&gt; Type -&gt; TySynEqn)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">([Q TyVarBndr] -&gt; Q [TyVarBndr])
-&gt; Maybe [Q TyVarBndr] -&gt; Q (Maybe [TyVarBndr])
forall (t :: * -&gt; *) (m :: * -&gt; *) a b.
(Traversable t, Monad m) =&gt;
(a -&gt; m b) -&gt; t a -&gt; m (t b)
</span><span class="hs-identifier hs-var">mapM</span></span><span> </span><span class="annot"><span class="annottext">[Q TyVarBndr] -&gt; Q [TyVarBndr]
forall (t :: * -&gt; *) (m :: * -&gt; *) a.
(Traversable t, Monad m) =&gt;
t (m a) -&gt; m (t a)
</span><span class="hs-identifier hs-var">sequence</span></span><span> </span><span class="annot"><span class="annottext">Maybe [Q TyVarBndr]
</span><a href="#local-6989586621679082419"><span class="hs-identifier hs-var">mtvbs</span></a></span><span>
</span><span id="line-2112"></span><span>                                                         </span><span class="annot"><span class="annottext">Q (Type -&gt; Type -&gt; TySynEqn) -&gt; Q Type -&gt; Q (Type -&gt; TySynEqn)
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">(Q Type -&gt; Q Type -&gt; Q Type) -&gt; Q Type -&gt; [Q Type] -&gt; Q Type
forall (t :: * -&gt; *) b a.
Foldable t =&gt;
(b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
</span><span class="hs-identifier hs-var">foldl'</span></span><span> </span><span class="annot"><span class="annottext">Q Type -&gt; Q Type -&gt; Q Type
</span><span class="hs-identifier hs-var">appT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Q Type
</span><span class="hs-identifier hs-var">conT</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082420"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Q Type]
</span><a href="#local-6989586621679082418"><span class="hs-identifier hs-var">ps</span></a></span><span>
</span><span id="line-2113"></span><span>                                                         </span><span class="annot"><span class="annottext">Q (Type -&gt; TySynEqn) -&gt; Q Type -&gt; Q TySynEqn
forall (f :: * -&gt; *) a b. Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;*&gt;</span></span><span> </span><span class="annot"><span class="annottext">Q Type
</span><a href="#local-6989586621679082417"><span class="hs-identifier hs-var">r</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#elif MIN_VERSION_template_haskell(2,9,0)
</span><span class="hs-identifier">tySynInstDCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">ps</span><span> </span><span class="hs-identifier">r</span><span>     </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">TySynInstD</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">TySynEqn</span><span> </span><span class="hs-operator">&lt;$&gt;</span><span> </span><span class="hs-identifier">sequence</span><span> </span><span class="hs-identifier">ps</span><span> </span><span class="hs-operator">&lt;*&gt;</span><span> </span><span class="hs-identifier">r</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">tySynInstDCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-identifier">_</span><span>          </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">tySynInstD</span><span> </span><span class="hs-identifier">n</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2120"></span><span class="hs-comment">-- | Backward compatible version of 'pragLineD'. Returns</span><span>
</span><span id="line-2121"></span><span class="hs-comment">-- 'Nothing' if line pragmas are not suported.</span><span>
</span><span id="line-2122"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier hs-type">pragLineDCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-2123"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Int</span></span><span>     </span><span class="hs-comment">{- ^ line number -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2124"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>  </span><span class="hs-comment">{- ^ file name   -}</span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-2125"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">DecQ</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,10,0)
</span><span id="pragLineDCompat"><span class="annot"><span class="annottext">pragLineDCompat :: Int -&gt; String -&gt; Maybe DecQ
</span><a href="Language.Haskell.TH.Datatype.html#pragLineDCompat"><span class="hs-identifier hs-var hs-var">pragLineDCompat</span></a></span></span><span> </span><span id="local-6989586621679082414"><span class="annot"><span class="annottext">ln :: Int
</span><a href="#local-6989586621679082414"><span class="hs-identifier hs-var">ln</span></a></span></span><span> </span><span id="local-6989586621679082413"><span class="annot"><span class="annottext">fn :: String
</span><a href="#local-6989586621679082413"><span class="hs-identifier hs-var">fn</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">DecQ -&gt; Maybe DecQ
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Int -&gt; String -&gt; DecQ
</span><span class="hs-identifier hs-var">pragLineD</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><a href="#local-6989586621679082414"><span class="hs-identifier hs-var">ln</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679082413"><span class="hs-identifier hs-var">fn</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">pragLineDCompat</span><span> </span><span class="hs-identifier">_</span><span>  </span><span class="hs-identifier">_</span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2132"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier hs-type">arrowKCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Kind</span></span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,8,0)
</span><span id="arrowKCompat"><span class="annot"><span class="annottext">arrowKCompat :: Type -&gt; Type -&gt; Type
</span><a href="Language.Haskell.TH.Datatype.html#arrowKCompat"><span class="hs-identifier hs-var hs-var">arrowKCompat</span></a></span></span><span> </span><span id="local-6989586621679082411"><span class="annot"><span class="annottext">x :: Type
</span><a href="#local-6989586621679082411"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span id="local-6989586621679082410"><span class="annot"><span class="annottext">y :: Type
</span><a href="#local-6989586621679082410"><span class="hs-identifier hs-var">y</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Type
</span><span class="hs-identifier hs-var">arrowK</span></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`appK`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082411"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">Type -&gt; Type -&gt; Type
</span><span class="hs-operator hs-var">`appK`</span></span><span> </span><span class="annot"><span class="annottext">Type
</span><a href="#local-6989586621679082410"><span class="hs-identifier hs-var">y</span></a></span><span class="hs-cpp">
#else
</span><span class="hs-identifier">arrowKCompat</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">arrowK</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2139"></span><span class="hs-comment">------------------------------------------------------------------------</span><span>
</span><span id="line-2140"></span><span>
</span><span id="line-2141"></span><span class="hs-comment">-- | Backwards compatibility wrapper for 'Fixity' lookup.</span><span>
</span><span id="line-2142"></span><span class="hs-comment">--</span><span>
</span><span id="line-2143"></span><span class="hs-comment">-- In @template-haskell-2.11.0.0@ and later, the answer will always</span><span>
</span><span id="line-2144"></span><span class="hs-comment">-- be 'Just' of a fixity.</span><span>
</span><span id="line-2145"></span><span class="hs-comment">--</span><span>
</span><span id="line-2146"></span><span class="hs-comment">-- Before @template-haskell-2.11.0.0@ it was only possible to determine</span><span>
</span><span id="line-2147"></span><span class="hs-comment">-- fixity information for variables, class methods, and data constructors.</span><span>
</span><span id="line-2148"></span><span class="hs-comment">-- In this case for type operators the answer could be 'Nothing', which</span><span>
</span><span id="line-2149"></span><span class="hs-comment">-- indicates that the answer is unavailable.</span><span>
</span><span id="line-2150"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-type">reifyFixityCompat</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Fixity</span></span><span class="hs-special">)</span><span class="hs-cpp">
#if MIN_VERSION_template_haskell(2,11,0)
</span><span id="reifyFixityCompat"><span class="annot"><span class="annottext">reifyFixityCompat :: Name -&gt; Q (Maybe Fixity)
</span><a href="Language.Haskell.TH.Datatype.html#reifyFixityCompat"><span class="hs-identifier hs-var hs-var">reifyFixityCompat</span></a></span></span><span> </span><span id="local-6989586621679082409"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082409"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Q (Maybe Fixity) -&gt; Q (Maybe Fixity) -&gt; Q (Maybe Fixity)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-identifier hs-var">recover</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Q (Maybe Fixity)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Fixity
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="annottext">Maybe Fixity -&gt; Maybe Fixity -&gt; Maybe Fixity
forall (m :: * -&gt; *) a. MonadPlus m =&gt; m a -&gt; m a -&gt; m a
</span><span class="hs-operator hs-var">`mplus`</span></span><span> </span><span class="annot"><span class="annottext">Fixity -&gt; Maybe Fixity
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">Fixity
</span><span class="hs-identifier hs-var">defaultFixity</span></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe Fixity -&gt; Maybe Fixity)
-&gt; Q (Maybe Fixity) -&gt; Q (Maybe Fixity)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Q (Maybe Fixity)
</span><span class="hs-identifier hs-var">reifyFixity</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082409"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-identifier">reifyFixityCompat</span><span> </span><span class="hs-identifier">n</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">recover</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">return</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-special">)</span><span> </span><span class="hs-operator">$</span><span>
</span><span id="line-2155"></span><span>  </span><span class="hs-keyword">do</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier">reify</span><span> </span><span class="hs-identifier">n</span><span>
</span><span id="line-2156"></span><span>     </span><span class="hs-identifier">return</span><span> </span><span class="hs-operator">$!</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">info</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-2157"></span><span>       </span><span class="hs-identifier">ClassOpI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><span id="line-2158"></span><span>       </span><span class="hs-identifier">DataConI</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><span id="line-2159"></span><span>       </span><span class="hs-identifier">VarI</span><span>     </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-identifier">fixity</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Just</span><span> </span><span class="hs-identifier">fixity</span><span>
</span><span id="line-2160"></span><span>       </span><span class="hs-identifier">_</span><span>                     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier">Nothing</span><span class="hs-cpp">
#endif
</span><span>
</span><span id="line-2163"></span><span class="hs-comment">-- | Call 'reify' and return @'Just' info@ if successful or 'Nothing' if</span><span>
</span><span id="line-2164"></span><span class="hs-comment">-- reification failed.</span><span>
</span><span id="line-2165"></span><span class="annot"><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-type">reifyMaybe</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Q</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Info</span></span><span class="hs-special">)</span><span>
</span><span id="line-2166"></span><span id="reifyMaybe"><span class="annot"><span class="annottext">reifyMaybe :: Name -&gt; Q (Maybe Info)
</span><a href="Language.Haskell.TH.Datatype.html#reifyMaybe"><span class="hs-identifier hs-var hs-var">reifyMaybe</span></a></span></span><span> </span><span id="local-6989586621679082407"><span class="annot"><span class="annottext">n :: Name
</span><a href="#local-6989586621679082407"><span class="hs-identifier hs-var">n</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe Info -&gt; Q (Maybe Info)
forall (m :: * -&gt; *) a. Monad m =&gt; a -&gt; m a
</span><span class="hs-identifier hs-var">return</span></span><span> </span><span class="annot"><span class="annottext">Maybe Info
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="annot"><span class="annottext">Q (Maybe Info) -&gt; Q (Maybe Info) -&gt; Q (Maybe Info)
forall a. Q a -&gt; Q a -&gt; Q a
</span><span class="hs-operator hs-var">`recover`</span></span><span> </span><span class="annot"><span class="annottext">(Info -&gt; Maybe Info) -&gt; Q Info -&gt; Q (Maybe Info)
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-identifier hs-var">fmap</span></span><span> </span><span class="annot"><span class="annottext">Info -&gt; Maybe Info
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Q Info
</span><span class="hs-identifier hs-var">reify</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621679082407"><span class="hs-identifier hs-var">n</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-2167"></span></pre></body></html>
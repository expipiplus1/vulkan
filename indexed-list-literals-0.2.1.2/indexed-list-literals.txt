-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type safe indexed list literals
--   
--   This is an incredibly simple library, which makes writing lists where
--   the length is known at compile time a little bit nicer.
--   
--   If you write a function with the signature
--   
--   <pre>
--   vector :: ILL input length output =&gt; input -&gt; Vector length output
--   </pre>
--   
--   then
--   
--   <pre>
--   v :: Vector 3 Int
--   v = vector (1,2,3)
--   
--   x :: Vector 0 Double
--   x = vector $ ZeroTuple @Double
--   
--   y :: Vector 1 Double
--   y = vector (Only 1)
--   
--   z :: Vector 2 String
--   z = vector ("Hello", "World")
--   </pre>
--   
--   If want matrix literals you can write a function
--   
--   <pre>
--   matrix :: (ILL row width ty, ILL matrix height row) =&gt; matrix -&gt; Matrix width height ty
--   </pre>
--   
--   then
--   
--   <pre>
--   a :: Matrix 0 0 Bool
--   a = matrix $ ZeroTuple @(ZeroTuple Bool)
--   
--   b :: Matrix 1 2 String
--   b = matrix $ Only ("Hello","World")
--   
--   c :: Matrix 4 5 Double
--   c = matrix ((1,2,3,0,0)
--              ,(4,5,6,0,0)
--              ,(7,8,9,0,0)
--              ,(0,0,0,0,0))
--   </pre>
--   
--   The full code is in test/Docs.hs
--   
--   This only supports literals of length up to 20, though that can be
--   easily extended using the code generator in
--   src/Data/IndexedListLiterals.hs
@package indexed-list-literals
@version 0.2.1.2

module Data.IndexedListLiterals

-- | A type class which allows you to write tuples which can be transformed
--   to and from a list the length of the list is also provided as a Nat
class IndexedListLiterals (input :: Type) (length :: Nat) (output :: Type) | output length -> input, input -> output length

-- | <pre>
--   &gt; toList (Only 1)
--     [1]
--   </pre>
--   
--   <pre>
--   &gt; toList (1,2,3)
--     [1,2,3]
--   </pre>
--   
--   <pre>
--   &gt; toList ZeroTuple
--     []
--   </pre>
toList :: IndexedListLiterals input length output => input -> [output]

-- | a partial fromList with bad error messages
fromList' :: IndexedListLiterals input length output => [output] -> input

-- | An alias for IndexedListLiterals
type ILL = IndexedListLiterals

-- | Intuitively the zero tuple is () or Void but this breaks the
--   Functional Dependency "input -&gt; output length" stopping reliable
--   inference, so this constructor is used to preserve type information
data ZeroTuple a
ZeroTuple :: ZeroTuple a
len :: Proxy a

-- | <pre>
--   &gt; fromList [1,2,3] :: Maybe (Int, Int, Int)
--     Just (1,2,3)
--   </pre>
--   
--   <pre>
--   &gt; fromList ["word","up"] :: Maybe (String, String, String)
--     Nothing
--   </pre>
--   
--   <pre>
--   &gt; fromList ['z'] :: Maybe (Only Char)
--     Just (Only 'z')
--   </pre>
fromList :: forall input (length :: Nat) output. (KnownNat length, ILL input length output) => [output] -> Maybe input

-- | the fromList variants take a list and convert it into a tuple it's
--   sort of the inverse of toList
--   
--   <pre>
--   &gt; fromListP (len @3) [1,2,3]
--     Just (1,2,3)
--   </pre>
--   
--   <pre>
--   &gt; fromListP (len @3) ["word","up"]
--     Nothing
--   </pre>
--   
--   <pre>
--   &gt; fromListP (len @1) ['z']
--     Just (Only 'z') @
--   </pre>
fromListP :: forall input (length :: Nat) output len. (KnownNat length, ILL input length output) => len length -> [output] -> Maybe input
instance Data.IndexedListLiterals.IndexedListLiterals (Data.IndexedListLiterals.ZeroTuple a) 0 a
instance Data.IndexedListLiterals.IndexedListLiterals (Data.Tuple.Only.Only a) 1 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a) 2 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a) 3 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a) 4 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a) 5 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a) 6 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a) 7 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a) 8 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a) 9 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a) 10 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a) 11 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a) 12 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a) 13 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a) 14 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) 15 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) 16 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) 17 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) 18 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) 19 a
instance Data.IndexedListLiterals.IndexedListLiterals (a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a, a) 20 a
